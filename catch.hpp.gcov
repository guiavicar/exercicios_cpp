        -:    0:Source:catch.hpp
        -:    1:/*
        -:    2: *  Catch v1.12.1
        -:    3: *  Generated: 2018-03-02 21:17:41.036711
        -:    4: *  ----------------------------------------------------------
        -:    5: *  This file has been merged from multiple headers. Please don't edit it directly
        -:    6: *  Copyright (c) 2012 Two Blue Cubes Ltd. All rights reserved.
        -:    7: *
        -:    8: *  Distributed under the Boost Software License, Version 1.0. (See accompanying
        -:    9: *  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)
        -:   10: */
        -:   11:#ifndef TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:   12:#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:   13:
        -:   14:#define TWOBLUECUBES_CATCH_HPP_INCLUDED
        -:   15:
        -:   16:#ifdef __clang__
        -:   17:#    pragma clang system_header
        -:   18:#elif defined __GNUC__
        -:   19:#    pragma GCC system_header
        -:   20:#endif
        -:   21:
        -:   22:// #included from: internal/catch_suppress_warnings.h
        -:   23:
        -:   24:#ifdef __clang__
        -:   25:#   ifdef __ICC // icpc defines the __clang__ macro
        -:   26:#       pragma warning(push)
        -:   27:#       pragma warning(disable: 161 1682)
        -:   28:#   else // __ICC
        -:   29:#       pragma clang diagnostic ignored "-Wglobal-constructors"
        -:   30:#       pragma clang diagnostic ignored "-Wvariadic-macros"
        -:   31:#       pragma clang diagnostic ignored "-Wc99-extensions"
        -:   32:#       pragma clang diagnostic ignored "-Wunused-variable"
        -:   33:#       pragma clang diagnostic push
        -:   34:#       pragma clang diagnostic ignored "-Wpadded"
        -:   35:#       pragma clang diagnostic ignored "-Wc++98-compat"
        -:   36:#       pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
        -:   37:#       pragma clang diagnostic ignored "-Wswitch-enum"
        -:   38:#       pragma clang diagnostic ignored "-Wcovered-switch-default"
        -:   39:#    endif
        -:   40:#elif defined __GNUC__
        -:   41:#    pragma GCC diagnostic ignored "-Wvariadic-macros"
        -:   42:#    pragma GCC diagnostic ignored "-Wunused-variable"
        -:   43:#    pragma GCC diagnostic ignored "-Wparentheses"
        -:   44:
        -:   45:#    pragma GCC diagnostic push
        -:   46:#    pragma GCC diagnostic ignored "-Wpadded"
        -:   47:#endif
        -:   48:#if defined(CATCH_CONFIG_MAIN) || defined(CATCH_CONFIG_RUNNER)
        -:   49:#  define CATCH_IMPL
        -:   50:#endif
        -:   51:
        -:   52:#ifdef CATCH_IMPL
        -:   53:#  ifndef CLARA_CONFIG_MAIN
        -:   54:#    define CLARA_CONFIG_MAIN_NOT_DEFINED
        -:   55:#    define CLARA_CONFIG_MAIN
        -:   56:#  endif
        -:   57:#endif
        -:   58:
        -:   59:// #included from: internal/catch_notimplemented_exception.h
        -:   60:#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED
        -:   61:
        -:   62:// #included from: catch_common.h
        -:   63:#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED
        -:   64:
        -:   65:// #included from: catch_compiler_capabilities.h
        -:   66:#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED
        -:   67:
        -:   68:// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
        -:   69:// The following features are defined:
        -:   70://
        -:   71:// CATCH_CONFIG_CPP11_NULLPTR : is nullptr supported?
        -:   72:// CATCH_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
        -:   73:// CATCH_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
        -:   74:// CATCH_CONFIG_CPP11_IS_ENUM : std::is_enum is supported?
        -:   75:// CATCH_CONFIG_CPP11_TUPLE : std::tuple is supported
        -:   76:// CATCH_CONFIG_CPP11_LONG_LONG : is long long supported?
        -:   77:// CATCH_CONFIG_CPP11_OVERRIDE : is override supported?
        -:   78:// CATCH_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)
        -:   79:// CATCH_CONFIG_CPP11_SHUFFLE : is std::shuffle supported?
        -:   80:// CATCH_CONFIG_CPP11_TYPE_TRAITS : are type_traits and enable_if supported?
        -:   81:
        -:   82:// CATCH_CONFIG_CPP11_OR_GREATER : Is C++11 supported?
        -:   83:
        -:   84:// CATCH_CONFIG_VARIADIC_MACROS : are variadic macros supported?
        -:   85:// CATCH_CONFIG_COUNTER : is the __COUNTER__ macro supported?
        -:   86:// CATCH_CONFIG_WINDOWS_SEH : is Windows SEH supported?
        -:   87:// CATCH_CONFIG_POSIX_SIGNALS : are POSIX signals supported?
        -:   88:// ****************
        -:   89:// Note to maintainers: if new toggles are added please document them
        -:   90:// in configuration.md, too
        -:   91:// ****************
        -:   92:
        -:   93:// In general each macro has a _NO_<feature name> form
        -:   94:// (e.g. CATCH_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
        -:   95:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -:   96:// can be combined, en-mass, with the _NO_ forms later.
        -:   97:
        -:   98:// All the C++11 features can be disabled with CATCH_CONFIG_NO_CPP11
        -:   99:
        -:  100:#ifdef __cplusplus
        -:  101:
        -:  102:#  if __cplusplus >= 201103L
        -:  103:#    define CATCH_CPP11_OR_GREATER
        -:  104:#  endif
        -:  105:
        -:  106:#  if __cplusplus >= 201402L
        -:  107:#    define CATCH_CPP14_OR_GREATER
        -:  108:#  endif
        -:  109:
        -:  110:#endif
        -:  111:
        -:  112:#ifdef __clang__
        -:  113:
        -:  114:#  if __has_feature(cxx_nullptr)
        -:  115:#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  116:#  endif
        -:  117:
        -:  118:#  if __has_feature(cxx_noexcept)
        -:  119:#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  120:#  endif
        -:  121:
        -:  122:#   if defined(CATCH_CPP11_OR_GREATER)
        -:  123:#       define CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  124:            _Pragma( "clang diagnostic push" ) \
        -:  125:            _Pragma( "clang diagnostic ignored \"-Wexit-time-destructors\"" )
        -:  126:#       define CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \
        -:  127:            _Pragma( "clang diagnostic pop" )
        -:  128:
        -:  129:#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -:  130:            _Pragma( "clang diagnostic push" ) \
        -:  131:            _Pragma( "clang diagnostic ignored \"-Wparentheses\"" )
        -:  132:#       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
        -:  133:            _Pragma( "clang diagnostic pop" )
        -:  134:#   endif
        -:  135:
        -:  136:#endif // __clang__
        -:  137:
        -:  138:////////////////////////////////////////////////////////////////////////////////
        -:  139:// We know some environments not to support full POSIX signals
        -:  140:#if defined(__CYGWIN__) || defined(__QNX__)
        -:  141:
        -:  142:#   if !defined(CATCH_CONFIG_POSIX_SIGNALS)
        -:  143:#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  144:#   endif
        -:  145:
        -:  146:#endif
        -:  147:
        -:  148:#ifdef __OS400__
        -:  149:#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS
        -:  150:#       define CATCH_CONFIG_COLOUR_NONE
        -:  151:#endif
        -:  152:
        -:  153:////////////////////////////////////////////////////////////////////////////////
        -:  154:// Cygwin
        -:  155:#ifdef __CYGWIN__
        -:  156:
        -:  157:// Required for some versions of Cygwin to declare gettimeofday
        -:  158:// see: http://stackoverflow.com/questions/36901803/gettimeofday-not-declared-in-this-scope-cygwin
        -:  159:#   define _BSD_SOURCE
        -:  160:
        -:  161:#endif // __CYGWIN__
        -:  162:
        -:  163:////////////////////////////////////////////////////////////////////////////////
        -:  164:// Borland
        -:  165:#ifdef __BORLANDC__
        -:  166:
        -:  167:#endif // __BORLANDC__
        -:  168:
        -:  169:////////////////////////////////////////////////////////////////////////////////
        -:  170:// EDG
        -:  171:#ifdef __EDG_VERSION__
        -:  172:
        -:  173:#endif // __EDG_VERSION__
        -:  174:
        -:  175:////////////////////////////////////////////////////////////////////////////////
        -:  176:// Digital Mars
        -:  177:#ifdef __DMC__
        -:  178:
        -:  179:#endif // __DMC__
        -:  180:
        -:  181:////////////////////////////////////////////////////////////////////////////////
        -:  182:// GCC
        -:  183:#ifdef __GNUC__
        -:  184:
        -:  185:#   if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
        -:  186:#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  187:#   endif
        -:  188:
        -:  189:// - otherwise more recent versions define __cplusplus >= 201103L
        -:  190:// and will get picked up below
        -:  191:
        -:  192:#endif // __GNUC__
        -:  193:
        -:  194:////////////////////////////////////////////////////////////////////////////////
        -:  195:// Visual C++
        -:  196:#ifdef _MSC_VER
        -:  197:
        -:  198:#define CATCH_INTERNAL_CONFIG_WINDOWS_SEH
        -:  199:
        -:  200:#if (_MSC_VER >= 1600)
        -:  201:#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  202:#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -:  203:#endif
        -:  204:
        -:  205:#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
        -:  206:#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  207:#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -:  208:#define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE
        -:  209:#define CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS
        -:  210:#endif
        -:  211:
        -:  212:#endif // _MSC_VER
        -:  213:
        -:  214:////////////////////////////////////////////////////////////////////////////////
        -:  215:
        -:  216:// Use variadic macros if the compiler supports them
        -:  217:#if ( defined _MSC_VER && _MSC_VER > 1400 && !defined __EDGE__) || \
        -:  218:    ( defined __WAVE__ && __WAVE_HAS_VARIADICS ) || \
        -:  219:    ( defined __GNUC__ && __GNUC__ >= 3 ) || \
        -:  220:    ( !defined __cplusplus && __STDC_VERSION__ >= 199901L || __cplusplus >= 201103L )
        -:  221:
        -:  222:#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
        -:  223:
        -:  224:#endif
        -:  225:
        -:  226:// Use __COUNTER__ if the compiler supports it
        -:  227:#if ( defined _MSC_VER && _MSC_VER >= 1300 ) || \
        -:  228:    ( defined __GNUC__  && ( __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3 )) ) || \
        -:  229:    ( defined __clang__ && __clang_major__ >= 3 )
        -:  230:
        -:  231:// Use of __COUNTER__ is suppressed during code analysis in CLion/AppCode 2017.2.x and former,
        -:  232:// because __COUNTER__ is not properly handled by it.
        -:  233:// This does not affect compilation
        -:  234:#if ( !defined __JETBRAINS_IDE__ || __JETBRAINS_IDE__ >= 20170300L )
        -:  235:    #define CATCH_INTERNAL_CONFIG_COUNTER
        -:  236:#endif
        -:  237:
        -:  238:#endif
        -:  239:
        -:  240:////////////////////////////////////////////////////////////////////////////////
        -:  241:// C++ language feature support
        -:  242:
        -:  243:// catch all support for C++11
        -:  244:#if defined(CATCH_CPP11_OR_GREATER)
        -:  245:
        -:  246:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR)
        -:  247:#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR
        -:  248:#  endif
        -:  249:
        -:  250:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  251:#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -:  252:#  endif
        -:  253:
        -:  254:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -:  255:#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -:  256:#  endif
        -:  257:
        -:  258:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
        -:  259:#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM
        -:  260:#  endif
        -:  261:
        -:  262:#  ifndef CATCH_INTERNAL_CONFIG_CPP11_TUPLE
        -:  263:#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE
        -:  264:#  endif
        -:  265:
        -:  266:#  ifndef CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
        -:  267:#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS
        -:  268:#  endif
        -:  269:
        -:  270:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG)
        -:  271:#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG
        -:  272:#  endif
        -:  273:
        -:  274:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE)
        -:  275:#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE
        -:  276:#  endif
        -:  277:#  if !defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
        -:  278:#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -:  279:#  endif
        -:  280:# if !defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE)
        -:  281:#   define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE
        -:  282:#  endif
        -:  283:# if !defined(CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS)
        -:  284:#  define CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS
        -:  285:# endif
        -:  286:
        -:  287:#endif // __cplusplus >= 201103L
        -:  288:
        -:  289:// Now set the actual defines based on the above + anything the user has configured
        -:  290:#if defined(CATCH_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NO_NULLPTR) && !defined(CATCH_CONFIG_CPP11_NULLPTR) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  291:#   define CATCH_CONFIG_CPP11_NULLPTR
        -:  292:#endif
        -:  293:#if defined(CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  294:#   define CATCH_CONFIG_CPP11_NOEXCEPT
        -:  295:#endif
        -:  296:#if defined(CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CATCH_CONFIG_CPP11_GENERATED_METHODS) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  297:#   define CATCH_CONFIG_CPP11_GENERATED_METHODS
        -:  298:#endif
        -:  299:#if defined(CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_NO_IS_ENUM) && !defined(CATCH_CONFIG_CPP11_IS_ENUM) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  300:#   define CATCH_CONFIG_CPP11_IS_ENUM
        -:  301:#endif
        -:  302:#if defined(CATCH_INTERNAL_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_CPP11_NO_TUPLE) && !defined(CATCH_CONFIG_CPP11_TUPLE) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  303:#   define CATCH_CONFIG_CPP11_TUPLE
        -:  304:#endif
        -:  305:#if defined(CATCH_INTERNAL_CONFIG_VARIADIC_MACROS) && !defined(CATCH_CONFIG_NO_VARIADIC_MACROS) && !defined(CATCH_CONFIG_VARIADIC_MACROS)
        -:  306:#   define CATCH_CONFIG_VARIADIC_MACROS
        -:  307:#endif
        -:  308:#if defined(CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_NO_LONG_LONG) && !defined(CATCH_CONFIG_CPP11_LONG_LONG) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  309:#   define CATCH_CONFIG_CPP11_LONG_LONG
        -:  310:#endif
        -:  311:#if defined(CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_NO_OVERRIDE) && !defined(CATCH_CONFIG_CPP11_OVERRIDE) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  312:#   define CATCH_CONFIG_CPP11_OVERRIDE
        -:  313:#endif
        -:  314:#if defined(CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_NO_UNIQUE_PTR) && !defined(CATCH_CONFIG_CPP11_UNIQUE_PTR) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  315:#   define CATCH_CONFIG_CPP11_UNIQUE_PTR
        -:  316:#endif
        -:  317:#if defined(CATCH_INTERNAL_CONFIG_COUNTER) && !defined(CATCH_CONFIG_NO_COUNTER) && !defined(CATCH_CONFIG_COUNTER)
        -:  318:#   define CATCH_CONFIG_COUNTER
        -:  319:#endif
        -:  320:#if defined(CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_NO_SHUFFLE) && !defined(CATCH_CONFIG_CPP11_SHUFFLE) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  321:#   define CATCH_CONFIG_CPP11_SHUFFLE
        -:  322:#endif
        -:  323:# if defined(CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS) && !defined(CATCH_CONFIG_CPP11_NO_TYPE_TRAITS) && !defined(CATCH_CONFIG_CPP11_TYPE_TRAITS) && !defined(CATCH_CONFIG_NO_CPP11)
        -:  324:#  define CATCH_CONFIG_CPP11_TYPE_TRAITS
        -:  325:# endif
        -:  326:#if defined(CATCH_INTERNAL_CONFIG_WINDOWS_SEH) && !defined(CATCH_CONFIG_NO_WINDOWS_SEH) && !defined(CATCH_CONFIG_WINDOWS_SEH)
        -:  327:#   define CATCH_CONFIG_WINDOWS_SEH
        -:  328:#endif
        -:  329:// This is set by default, because we assume that unix compilers are posix-signal-compatible by default.
        -:  330:#if !defined(CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_NO_POSIX_SIGNALS) && !defined(CATCH_CONFIG_POSIX_SIGNALS)
        -:  331:#   define CATCH_CONFIG_POSIX_SIGNALS
        -:  332:#endif
        -:  333:
        -:  334:#if !defined(CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS)
        -:  335:#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS
        -:  336:#   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS
        -:  337:#endif
        -:  338:#if !defined(CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS)
        -:  339:#   define CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS
        -:  340:#   define CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS
        -:  341:#endif
        -:  342:
        -:  343:// noexcept support:
        -:  344:#if defined(CATCH_CONFIG_CPP11_NOEXCEPT) && !defined(CATCH_NOEXCEPT)
        -:  345:#  define CATCH_NOEXCEPT noexcept
        -:  346:#  define CATCH_NOEXCEPT_IS(x) noexcept(x)
        -:  347:#else
        -:  348:#  define CATCH_NOEXCEPT throw()
        -:  349:#  define CATCH_NOEXCEPT_IS(x)
        -:  350:#endif
        -:  351:
        -:  352:// nullptr support
        -:  353:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -:  354:#   define CATCH_NULL nullptr
        -:  355:#else
        -:  356:#   define CATCH_NULL NULL
        -:  357:#endif
        -:  358:
        -:  359:// override support
        -:  360:#ifdef CATCH_CONFIG_CPP11_OVERRIDE
        -:  361:#   define CATCH_OVERRIDE override
        -:  362:#else
        -:  363:#   define CATCH_OVERRIDE
        -:  364:#endif
        -:  365:
        -:  366:// unique_ptr support
        -:  367:#ifdef CATCH_CONFIG_CPP11_UNIQUE_PTR
        -:  368:#   define CATCH_AUTO_PTR( T ) std::unique_ptr<T>
        -:  369:#else
        -:  370:#   define CATCH_AUTO_PTR( T ) std::auto_ptr<T>
        -:  371:#endif
        -:  372:
        -:  373:#define INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line ) name##line
        -:  374:#define INTERNAL_CATCH_UNIQUE_NAME_LINE( name, line ) INTERNAL_CATCH_UNIQUE_NAME_LINE2( name, line )
        -:  375:#ifdef CATCH_CONFIG_COUNTER
        -:  376:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __COUNTER__ )
        -:  377:#else
        -:  378:#  define INTERNAL_CATCH_UNIQUE_NAME( name ) INTERNAL_CATCH_UNIQUE_NAME_LINE( name, __LINE__ )
        -:  379:#endif
        -:  380:
        -:  381:#define INTERNAL_CATCH_STRINGIFY2( expr ) #expr
        -:  382:#define INTERNAL_CATCH_STRINGIFY( expr ) INTERNAL_CATCH_STRINGIFY2( expr )
        -:  383:
        -:  384:#include <sstream>
        -:  385:#include <algorithm>
        -:  386:
        -:  387:namespace Catch {
        -:  388:
        -:  389:    struct IConfig;
        -:  390:
        -:  391:    struct CaseSensitive { enum Choice {
        -:  392:        Yes,
        -:  393:        No
        -:  394:    }; };
        -:  395:
        -:  396:    class NonCopyable {
        -:  397:#ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -:  398:        NonCopyable( NonCopyable const& )              = delete;
        -:  399:        NonCopyable( NonCopyable && )                  = delete;
        -:  400:        NonCopyable& operator = ( NonCopyable const& ) = delete;
        -:  401:        NonCopyable& operator = ( NonCopyable && )     = delete;
        -:  402:#else
        -:  403:        NonCopyable( NonCopyable const& info );
        -:  404:        NonCopyable& operator = ( NonCopyable const& );
        -:  405:#endif
        -:  406:
        -:  407:    protected:
       54:  408:        NonCopyable() {}
        -:  409:        virtual ~NonCopyable();
        -:  410:    };
        -:  411:
        -:  412:    class SafeBool {
        -:  413:    public:
        -:  414:        typedef void (SafeBool::*type)() const;
        -:  415:
        3:  416:        static type makeSafe( bool value ) {
        3:  417:            return value ? &SafeBool::trueValue : 0;
        -:  418:        }
        -:  419:    private:
    #####:  420:        void trueValue() const {}
        -:  421:    };
        -:  422:
        -:  423:    template<typename ContainerT>
       1*:  424:    void deleteAll( ContainerT& container ) {
       1*:  425:        typename ContainerT::const_iterator it = container.begin();
       1*:  426:        typename ContainerT::const_iterator itEnd = container.end();
       1*:  427:        for(; it != itEnd; ++it )
    #####:  428:            delete *it;
       1*:  429:    }
------------------
_ZN5Catch9deleteAllISt6vectorIPNS_14IGeneratorInfoESaIS3_EEEEvRT_:
    #####:  424:    void deleteAll( ContainerT& container ) {
    #####:  425:        typename ContainerT::const_iterator it = container.begin();
    #####:  426:        typename ContainerT::const_iterator itEnd = container.end();
    #####:  427:        for(; it != itEnd; ++it )
    #####:  428:            delete *it;
    #####:  429:    }
------------------
_ZN5Catch9deleteAllISt6vectorIPKNS_20IExceptionTranslatorESaIS4_EEEEvRT_:
        1:  424:    void deleteAll( ContainerT& container ) {
        1:  425:        typename ContainerT::const_iterator it = container.begin();
        1:  426:        typename ContainerT::const_iterator itEnd = container.end();
       1*:  427:        for(; it != itEnd; ++it )
    #####:  428:            delete *it;
        1:  429:    }
------------------
        -:  430:    template<typename AssociativeContainerT>
        1:  431:    void deleteAllValues( AssociativeContainerT& container ) {
        1:  432:        typename AssociativeContainerT::const_iterator it = container.begin();
        1:  433:        typename AssociativeContainerT::const_iterator itEnd = container.end();
       1*:  434:        for(; it != itEnd; ++it )
    #####:  435:            delete it->second;
        1:  436:    }
        -:  437:
        -:  438:    bool startsWith( std::string const& s, std::string const& prefix );
        -:  439:    bool startsWith( std::string const& s, char prefix );
        -:  440:    bool endsWith( std::string const& s, std::string const& suffix );
        -:  441:    bool endsWith( std::string const& s, char suffix );
        -:  442:    bool contains( std::string const& s, std::string const& infix );
        -:  443:    void toLowerInPlace( std::string& s );
        -:  444:    std::string toLower( std::string const& s );
        -:  445:    std::string trim( std::string const& str );
        -:  446:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis );
        -:  447:
        -:  448:    struct pluralise {
        -:  449:        pluralise( std::size_t count, std::string const& label );
        -:  450:
        -:  451:        friend std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser );
        -:  452:
        -:  453:        std::size_t m_count;
        -:  454:        std::string m_label;
        -:  455:    };
        -:  456:
        -:  457:    struct SourceLineInfo {
        -:  458:
        -:  459:        SourceLineInfo();
        -:  460:        SourceLineInfo( char const* _file, std::size_t _line );
        -:  461:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -:  462:        SourceLineInfo(SourceLineInfo const& other)          = default;
        -:  463:        SourceLineInfo( SourceLineInfo && )                  = default;
        -:  464:        SourceLineInfo& operator = ( SourceLineInfo const& ) = default;
        -:  465:        SourceLineInfo& operator = ( SourceLineInfo && )     = default;
        -:  466:#  endif
        -:  467:        bool empty() const;
        -:  468:        bool operator == ( SourceLineInfo const& other ) const;
        -:  469:        bool operator < ( SourceLineInfo const& other ) const;
        -:  470:
        -:  471:        char const* file;
        -:  472:        std::size_t line;
        -:  473:    };
        -:  474:
        -:  475:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info );
        -:  476:
        -:  477:    // This is just here to avoid compiler warnings with macro constants and boolean literals
        6:  478:    inline bool isTrue( bool value ){ return value; }
    #####:  479:    inline bool alwaysTrue() { return true; }
        -:  480:    inline bool alwaysFalse() { return false; }
        -:  481:
        -:  482:    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo );
        -:  483:
        -:  484:    void seedRng( IConfig const& config );
        -:  485:    unsigned int rngSeed();
        -:  486:
        -:  487:    // Use this in variadic streaming macros to allow
        -:  488:    //    >> +StreamEndStop
        -:  489:    // as well as
        -:  490:    //    >> stuff +StreamEndStop
        -:  491:    struct StreamEndStop {
        -:  492:        std::string operator+() {
        -:  493:            return std::string();
        -:  494:        }
        -:  495:    };
        -:  496:    template<typename T>
        -:  497:    T const& operator + ( T const& value, StreamEndStop ) {
        -:  498:        return value;
        -:  499:    }
        -:  500:}
        -:  501:
        -:  502:#define CATCH_INTERNAL_LINEINFO ::Catch::SourceLineInfo( __FILE__, static_cast<std::size_t>( __LINE__ ) )
        -:  503:#define CATCH_INTERNAL_ERROR( msg ) ::Catch::throwLogicError( msg, CATCH_INTERNAL_LINEINFO );
        -:  504:
        -:  505:namespace Catch {
        -:  506:
        -:  507:    class NotImplementedException : public std::exception
        -:  508:    {
        -:  509:    public:
        -:  510:        NotImplementedException( SourceLineInfo const& lineInfo );
        -:  511:
    #####:  512:        virtual ~NotImplementedException() CATCH_NOEXCEPT {}
------------------
_ZN5Catch23NotImplementedExceptionD0Ev:
    #####:  512:        virtual ~NotImplementedException() CATCH_NOEXCEPT {}
------------------
_ZN5Catch23NotImplementedExceptionD2Ev:
    #####:  512:        virtual ~NotImplementedException() CATCH_NOEXCEPT {}
------------------
        -:  513:
        -:  514:        virtual const char* what() const CATCH_NOEXCEPT;
        -:  515:
        -:  516:    private:
        -:  517:        std::string m_what;
        -:  518:        SourceLineInfo m_lineInfo;
        -:  519:    };
        -:  520:
        -:  521:} // end namespace Catch
        -:  522:
        -:  523:///////////////////////////////////////////////////////////////////////////////
        -:  524:#define CATCH_NOT_IMPLEMENTED throw Catch::NotImplementedException( CATCH_INTERNAL_LINEINFO )
        -:  525:
        -:  526:// #included from: internal/catch_context.h
        -:  527:#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED
        -:  528:
        -:  529:// #included from: catch_interfaces_generators.h
        -:  530:#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED
        -:  531:
        -:  532:#include <string>
        -:  533:
        -:  534:namespace Catch {
        -:  535:
        -:  536:    struct IGeneratorInfo {
        -:  537:        virtual ~IGeneratorInfo();
        -:  538:        virtual bool moveNext() = 0;
        -:  539:        virtual std::size_t getCurrentIndex() const = 0;
        -:  540:    };
        -:  541:
        -:  542:    struct IGeneratorsForTest {
        -:  543:        virtual ~IGeneratorsForTest();
        -:  544:
        -:  545:        virtual IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) = 0;
        -:  546:        virtual bool moveNext() = 0;
        -:  547:    };
        -:  548:
        -:  549:    IGeneratorsForTest* createGeneratorsForTest();
        -:  550:
        -:  551:} // end namespace Catch
        -:  552:
        -:  553:// #included from: catch_ptr.hpp
        -:  554:#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED
        -:  555:
        -:  556:#ifdef __clang__
        -:  557:#pragma clang diagnostic push
        -:  558:#pragma clang diagnostic ignored "-Wpadded"
        -:  559:#endif
        -:  560:
        -:  561:namespace Catch {
        -:  562:
        -:  563:    // An intrusive reference counting smart pointer.
        -:  564:    // T must implement addRef() and release() methods
        -:  565:    // typically implementing the IShared interface
        -:  566:    template<typename T>
        -:  567:    class Ptr {
        -:  568:    public:
       4*:  569:        Ptr() : m_p( CATCH_NULL ){}
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEC2Ev:
    #####:  569:        Ptr() : m_p( CATCH_NULL ){}
------------------
_ZN5Catch3PtrINS_6ConfigEEC2Ev:
        1:  569:        Ptr() : m_p( CATCH_NULL ){}
------------------
_ZN5Catch3PtrINS_18IStreamingReporterEEC2Ev:
        2:  569:        Ptr() : m_p( CATCH_NULL ){}
------------------
_ZN5Catch3PtrINS_16TestCaseTracking8ITrackerEEC2Ev:
        1:  569:        Ptr() : m_p( CATCH_NULL ){}
------------------
      20*:  570:        Ptr( T* p ) : m_p( p ){
      20*:  571:            if( m_p )
      19*:  572:                m_p->addRef();
      20*:  573:        }
------------------
_ZN5Catch3PtrINS_16IReporterFactoryEEC2EPS1_:
        4:  570:        Ptr( T* p ) : m_p( p ){
        4:  571:            if( m_p )
        4:  572:                m_p->addRef();
        4:  573:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEC2EPS2_:
    #####:  570:        Ptr( T* p ) : m_p( p ){
    #####:  571:            if( m_p )
    #####:  572:                m_p->addRef();
    #####:  573:        }
------------------
_ZN5Catch3PtrINS_6ConfigEEC2EPS1_:
        1:  570:        Ptr( T* p ) : m_p( p ){
        1:  571:            if( m_p )
        1:  572:                m_p->addRef();
        1:  573:        }
------------------
_ZN5Catch3PtrINS_8TestSpec7PatternEEC2EPS2_:
        2:  570:        Ptr( T* p ) : m_p( p ){
        2:  571:            if( m_p )
        2:  572:                m_p->addRef();
        2:  573:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_12TestRunStatsENS2_INS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEEEC2EPS9_:
    #####:  570:        Ptr( T* p ) : m_p( p ){
    #####:  571:            if( m_p )
    #####:  572:                m_p->addRef();
    #####:  573:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEC2EPS7_:
    #####:  570:        Ptr( T* p ) : m_p( p ){
    #####:  571:            if( m_p )
    #####:  572:                m_p->addRef();
    #####:  573:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_13TestCaseStatsENS1_11SectionNodeEEEEC2EPS5_:
    #####:  570:        Ptr( T* p ) : m_p( p ){
    #####:  571:            if( m_p )
    #####:  572:                m_p->addRef();
    #####:  573:        }
------------------
_ZN5Catch3PtrINS_9ITestCaseEEC2EPS1_:
        1:  570:        Ptr( T* p ) : m_p( p ){
        1:  571:            if( m_p )
        1:  572:                m_p->addRef();
        1:  573:        }
------------------
_ZN5Catch3PtrINS_18IStreamingReporterEEC2EPS1_:
        1:  570:        Ptr( T* p ) : m_p( p ){
        1:  571:            if( m_p )
        1:  572:                m_p->addRef();
        1:  573:        }
------------------
_ZN5Catch3PtrIKNS_7IConfigEEC2EPS2_:
        3:  570:        Ptr( T* p ) : m_p( p ){
        3:  571:            if( m_p )
        2:  572:                m_p->addRef();
        3:  573:        }
------------------
_ZN5Catch3PtrINS_16TestCaseTracking8ITrackerEEC2EPS2_:
        8:  570:        Ptr( T* p ) : m_p( p ){
        8:  571:            if( m_p )
        8:  572:                m_p->addRef();
        8:  573:        }
------------------
      46*:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
      46*:  575:            if( m_p )
      46*:  576:                m_p->addRef();
      46*:  577:        }
------------------
_ZN5Catch3PtrINS_16TestCaseTracking8ITrackerEEC2ERKS3_:
       14:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
       14:  575:            if( m_p )
       14:  576:                m_p->addRef();
       14:  577:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEC2ERKS3_:
    #####:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
    #####:  575:            if( m_p )
    #####:  576:                m_p->addRef();
    #####:  577:        }
------------------
_ZN5Catch3PtrINS_16IReporterFactoryEEC2ERKS2_:
        8:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
        8:  575:            if( m_p )
        8:  576:                m_p->addRef();
        8:  577:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_12TestRunStatsENS2_INS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEEEC2ERKSA_:
    #####:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
    #####:  575:            if( m_p )
    #####:  576:                m_p->addRef();
    #####:  577:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEC2ERKS8_:
    #####:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
    #####:  575:            if( m_p )
    #####:  576:                m_p->addRef();
    #####:  577:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_13TestCaseStatsENS1_11SectionNodeEEEEC2ERKS6_:
    #####:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
    #####:  575:            if( m_p )
    #####:  576:                m_p->addRef();
    #####:  577:        }
------------------
_ZN5Catch3PtrINS_9IReporterEEC2ERKS2_:
    #####:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
    #####:  575:            if( m_p )
    #####:  576:                m_p->addRef();
    #####:  577:        }
------------------
_ZN5Catch3PtrINS_9ITestCaseEEC2ERKS2_:
        3:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
        3:  575:            if( m_p )
        3:  576:                m_p->addRef();
        3:  577:        }
------------------
_ZN5Catch3PtrINS_18IStreamingReporterEEC2ERKS2_:
        6:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
        6:  575:            if( m_p )
        6:  576:                m_p->addRef();
        6:  577:        }
------------------
_ZN5Catch3PtrIKNS_7IConfigEEC2ERKS3_:
       11:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
       11:  575:            if( m_p )
       11:  576:                m_p->addRef();
       11:  577:        }
------------------
_ZN5Catch3PtrINS_8TestSpec7PatternEEC2ERKS3_:
        4:  574:        Ptr( Ptr const& other ) : m_p( other.m_p ){
        4:  575:            if( m_p )
        4:  576:                m_p->addRef();
        4:  577:        }
------------------
      70*:  578:        ~Ptr(){
      70*:  579:            if( m_p )
      65*:  580:                m_p->release();
      70*:  581:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_12TestRunStatsENS2_INS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEEED2Ev:
    #####:  578:        ~Ptr(){
    #####:  579:            if( m_p )
    #####:  580:                m_p->release();
    #####:  581:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEED2Ev:
    #####:  578:        ~Ptr(){
    #####:  579:            if( m_p )
    #####:  580:                m_p->release();
    #####:  581:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase4NodeINS_13TestCaseStatsENS1_11SectionNodeEEEED2Ev:
    #####:  578:        ~Ptr(){
    #####:  579:            if( m_p )
    #####:  580:                m_p->release();
    #####:  581:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEED2Ev:
    #####:  578:        ~Ptr(){
    #####:  579:            if( m_p )
    #####:  580:                m_p->release();
    #####:  581:        }
------------------
_ZN5Catch3PtrINS_9IReporterEED2Ev:
    #####:  578:        ~Ptr(){
    #####:  579:            if( m_p )
    #####:  580:                m_p->release();
    #####:  581:        }
------------------
_ZN5Catch3PtrINS_16IReporterFactoryEED2Ev:
       12:  578:        ~Ptr(){
       12:  579:            if( m_p )
       12:  580:                m_p->release();
       12:  581:        }
------------------
_ZN5Catch3PtrINS_9ITestCaseEED2Ev:
        4:  578:        ~Ptr(){
        4:  579:            if( m_p )
        4:  580:                m_p->release();
        4:  581:        }
------------------
_ZN5Catch3PtrINS_6ConfigEED2Ev:
        2:  578:        ~Ptr(){
        2:  579:            if( m_p )
        1:  580:                m_p->release();
        2:  581:        }
------------------
_ZN5Catch3PtrINS_18IStreamingReporterEED2Ev:
        9:  578:        ~Ptr(){
        9:  579:            if( m_p )
        7:  580:                m_p->release();
        9:  581:        }
------------------
_ZN5Catch3PtrINS_16TestCaseTracking8ITrackerEED2Ev:
       23:  578:        ~Ptr(){
       23:  579:            if( m_p )
       22:  580:                m_p->release();
       23:  581:        }
------------------
_ZN5Catch3PtrIKNS_7IConfigEED2Ev:
       14:  578:        ~Ptr(){
       14:  579:            if( m_p )
       13:  580:                m_p->release();
       14:  581:        }
------------------
_ZN5Catch3PtrINS_8TestSpec7PatternEED2Ev:
        6:  578:        ~Ptr(){
        6:  579:            if( m_p )
        6:  580:                m_p->release();
        6:  581:        }
------------------
       1*:  582:        void reset() {
       1*:  583:            if( m_p )
    #####:  584:                m_p->release();
       1*:  585:            m_p = CATCH_NULL;
       1*:  586:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEE5resetEv:
    #####:  582:        void reset() {
    #####:  583:            if( m_p )
    #####:  584:                m_p->release();
    #####:  585:            m_p = CATCH_NULL;
    #####:  586:        }
------------------
_ZN5Catch3PtrINS_6ConfigEE5resetEv:
        1:  582:        void reset() {
        1:  583:            if( m_p )
    #####:  584:                m_p->release();
        1:  585:            m_p = CATCH_NULL;
        1:  586:        }
------------------
       3*:  587:        Ptr& operator = ( T* p ){
       3*:  588:            Ptr temp( p );
       3*:  589:            swap( temp );
       6*:  590:            return *this;
        -:  591:        }
------------------
_ZN5Catch3PtrINS_8TestSpec7PatternEEaSEPS2_:
        1:  587:        Ptr& operator = ( T* p ){
        1:  588:            Ptr temp( p );
        1:  589:            swap( temp );
        2:  590:            return *this;
        -:  591:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEaSEPS2_:
    #####:  587:        Ptr& operator = ( T* p ){
    #####:  588:            Ptr temp( p );
    #####:  589:            swap( temp );
    #####:  590:            return *this;
        -:  591:        }
------------------
_ZN5Catch3PtrINS_6ConfigEEaSEPS1_:
        1:  587:        Ptr& operator = ( T* p ){
        1:  588:            Ptr temp( p );
        1:  589:            swap( temp );
        2:  590:            return *this;
        -:  591:        }
------------------
_ZN5Catch3PtrINS_16TestCaseTracking8ITrackerEEaSEPS2_:
        1:  587:        Ptr& operator = ( T* p ){
        1:  588:            Ptr temp( p );
        1:  589:            swap( temp );
        2:  590:            return *this;
        -:  591:        }
------------------
       4*:  592:        Ptr& operator = ( Ptr const& other ){
       4*:  593:            Ptr temp( other );
       4*:  594:            swap( temp );
       8*:  595:            return *this;
        -:  596:        }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEaSERKS3_:
    #####:  592:        Ptr& operator = ( Ptr const& other ){
    #####:  593:            Ptr temp( other );
    #####:  594:            swap( temp );
    #####:  595:            return *this;
        -:  596:        }
------------------
_ZN5Catch3PtrIKNS_7IConfigEEaSERKS3_:
        1:  592:        Ptr& operator = ( Ptr const& other ){
        1:  593:            Ptr temp( other );
        1:  594:            swap( temp );
        2:  595:            return *this;
        -:  596:        }
------------------
_ZN5Catch3PtrINS_18IStreamingReporterEEaSERKS2_:
        3:  592:        Ptr& operator = ( Ptr const& other ){
        3:  593:            Ptr temp( other );
        3:  594:            swap( temp );
        6:  595:            return *this;
        -:  596:        }
------------------
       7*:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrINS_8TestSpec7PatternEE4swapERS3_:
        1:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEE4swapERS3_:
    #####:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrIKNS_7IConfigEE4swapERS3_:
        1:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrINS_6ConfigEE4swapERS2_:
        1:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrINS_18IStreamingReporterEE4swapERS2_:
        3:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrINS_16TestCaseTracking8ITrackerEE4swapERS3_:
        1:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
_ZN5Catch3PtrINS_9ITestCaseEE4swapERS2_:
    #####:  597:        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }
------------------
      43*:  598:        T* get() const{ return m_p; }
------------------
_ZNK5Catch3PtrINS_9ITestCaseEE3getEv:
    #####:  598:        T* get() const{ return m_p; }
------------------
_ZNK5Catch3PtrINS_6ConfigEE3getEv:
        2:  598:        T* get() const{ return m_p; }
------------------
_ZNK5Catch3PtrINS_16TestCaseTracking8ITrackerEE3getEv:
       41:  598:        T* get() const{ return m_p; }
------------------
      12*:  599:        T& operator*() const { return *m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase4NodeINS_13TestCaseStatsENS1_11SectionNodeEEEEdeEv:
    #####:  599:        T& operator*() const { return *m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase4NodeINS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEdeEv:
    #####:  599:        T& operator*() const { return *m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEdeEv:
    #####:  599:        T& operator*() const { return *m_p; }
------------------
_ZNK5Catch3PtrINS_6ConfigEEdeEv:
        3:  599:        T& operator*() const { return *m_p; }
------------------
_ZNK5Catch3PtrIKNS_7IConfigEEdeEv:
        8:  599:        T& operator*() const { return *m_p; }
------------------
_ZNK5Catch3PtrINS_16TestCaseTracking8ITrackerEEdeEv:
        1:  599:        T& operator*() const { return *m_p; }
------------------
     246*:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase4NodeINS_12TestRunStatsENS2_INS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEEEptEv:
    #####:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase4NodeINS_14TestGroupStatsENS2_INS_13TestCaseStatsENS1_11SectionNodeEEEEEEptEv:
    #####:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase4NodeINS_13TestCaseStatsENS1_11SectionNodeEEEEptEv:
    #####:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEptEv:
    #####:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_9IReporterEEptEv:
    #####:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_9ITestCaseEEptEv:
        6:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_6ConfigEEptEv:
        3:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_18IStreamingReporterEEptEv:
       36:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_16TestCaseTracking8ITrackerEEptEv:
      166:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_16IReporterFactoryEEptEv:
        1:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrIKNS_7IConfigEEptEv:
       32:  600:        T* operator->() const { return m_p; }
------------------
_ZNK5Catch3PtrINS_8TestSpec7PatternEEptEv:
        2:  600:        T* operator->() const { return m_p; }
------------------
       3*:  601:        bool operator !() const { return m_p == CATCH_NULL; }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEntEv:
    #####:  601:        bool operator !() const { return m_p == CATCH_NULL; }
------------------
_ZNK5Catch3PtrINS_6ConfigEEntEv:
        2:  601:        bool operator !() const { return m_p == CATCH_NULL; }
------------------
_ZNK5Catch3PtrINS_18IStreamingReporterEEntEv:
        1:  601:        bool operator !() const { return m_p == CATCH_NULL; }
------------------
       2*:  602:        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }
------------------
_ZNK5Catch3PtrINS_22CumulativeReporterBase11SectionNodeEEcvMNS_8SafeBoolEKFvvEEv:
    #####:  602:        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }
------------------
_ZNK5Catch3PtrINS_18IStreamingReporterEEcvMNS_8SafeBoolEKFvvEEv:
        1:  602:        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }
------------------
_ZNK5Catch3PtrIKNS_7IConfigEEcvMNS_8SafeBoolEKFvvEEv:
        1:  602:        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }
------------------
        -:  603:
        -:  604:    private:
        -:  605:        T* m_p;
        -:  606:    };
        -:  607:
        -:  608:    struct IShared : NonCopyable {
        -:  609:        virtual ~IShared();
        -:  610:        virtual void addRef() const = 0;
        -:  611:        virtual void release() const = 0;
        -:  612:    };
        -:  613:
        -:  614:    template<typename T = IShared>
        -:  615:    struct SharedImpl : T {
        -:  616:
       17:  617:        SharedImpl() : m_rc( 0 ){}
------------------
_ZN5Catch10SharedImplINS_16IReporterFactoryEEC2Ev:
        4:  617:        SharedImpl() : m_rc( 0 ){}
------------------
_ZN5Catch10SharedImplINS_18IStreamingReporterEEC2Ev:
        1:  617:        SharedImpl() : m_rc( 0 ){}
------------------
_ZN5Catch10SharedImplINS_9ITestCaseEEC2Ev:
        1:  617:        SharedImpl() : m_rc( 0 ){}
------------------
_ZN5Catch10SharedImplINS_7IConfigEEC2Ev:
        1:  617:        SharedImpl() : m_rc( 0 ){}
------------------
_ZN5Catch10SharedImplINS_7ISharedEEC2Ev:
       10:  617:        SharedImpl() : m_rc( 0 ){}
------------------
        -:  618:
       65:  619:        virtual void addRef() const {
       65:  620:            ++m_rc;
       65:  621:        }
------------------
_ZNK5Catch10SharedImplINS_18IStreamingReporterEE6addRefEv:
        7:  619:        virtual void addRef() const {
        7:  620:            ++m_rc;
        7:  621:        }
------------------
_ZNK5Catch10SharedImplINS_9ITestCaseEE6addRefEv:
        4:  619:        virtual void addRef() const {
        4:  620:            ++m_rc;
        4:  621:        }
------------------
_ZNK5Catch10SharedImplINS_16IReporterFactoryEE6addRefEv:
       12:  619:        virtual void addRef() const {
       12:  620:            ++m_rc;
       12:  621:        }
------------------
_ZNK5Catch10SharedImplINS_7IConfigEE6addRefEv:
       14:  619:        virtual void addRef() const {
       14:  620:            ++m_rc;
       14:  621:        }
------------------
_ZNK5Catch10SharedImplINS_7ISharedEE6addRefEv:
       28:  619:        virtual void addRef() const {
       28:  620:            ++m_rc;
       28:  621:        }
------------------
       65:  622:        virtual void release() const {
       65:  623:            if( --m_rc == 0 )
       17:  624:                delete this;
       65:  625:        }
------------------
_ZNK5Catch10SharedImplINS_18IStreamingReporterEE7releaseEv:
        7:  622:        virtual void release() const {
        7:  623:            if( --m_rc == 0 )
        1:  624:                delete this;
        7:  625:        }
------------------
_ZNK5Catch10SharedImplINS_9ITestCaseEE7releaseEv:
        4:  622:        virtual void release() const {
        4:  623:            if( --m_rc == 0 )
        1:  624:                delete this;
        4:  625:        }
------------------
_ZNK5Catch10SharedImplINS_16IReporterFactoryEE7releaseEv:
       12:  622:        virtual void release() const {
       12:  623:            if( --m_rc == 0 )
        4:  624:                delete this;
       12:  625:        }
------------------
_ZNK5Catch10SharedImplINS_7IConfigEE7releaseEv:
       14:  622:        virtual void release() const {
       14:  623:            if( --m_rc == 0 )
        1:  624:                delete this;
       14:  625:        }
------------------
_ZNK5Catch10SharedImplINS_7ISharedEE7releaseEv:
       28:  622:        virtual void release() const {
       28:  623:            if( --m_rc == 0 )
       10:  624:                delete this;
       28:  625:        }
------------------
        -:  626:
        -:  627:        mutable unsigned int m_rc;
        -:  628:    };
        -:  629:
        -:  630:} // end namespace Catch
        -:  631:
        -:  632:#ifdef __clang__
        -:  633:#pragma clang diagnostic pop
        -:  634:#endif
        -:  635:
        -:  636:namespace Catch {
        -:  637:
        -:  638:    class TestCase;
        -:  639:    class Stream;
        -:  640:    struct IResultCapture;
        -:  641:    struct IRunner;
        -:  642:    struct IGeneratorsForTest;
        -:  643:    struct IConfig;
        -:  644:
        -:  645:    struct IContext
        -:  646:    {
        -:  647:        virtual ~IContext();
        -:  648:
        -:  649:        virtual IResultCapture* getResultCapture() = 0;
        -:  650:        virtual IRunner* getRunner() = 0;
        -:  651:        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) = 0;
        -:  652:        virtual bool advanceGeneratorsForCurrentTest() = 0;
        -:  653:        virtual Ptr<IConfig const> getConfig() const = 0;
        -:  654:    };
        -:  655:
        -:  656:    struct IMutableContext : IContext
        -:  657:    {
        -:  658:        virtual ~IMutableContext();
        -:  659:        virtual void setResultCapture( IResultCapture* resultCapture ) = 0;
        -:  660:        virtual void setRunner( IRunner* runner ) = 0;
        -:  661:        virtual void setConfig( Ptr<IConfig const> const& config ) = 0;
        -:  662:    };
        -:  663:
        -:  664:    IContext& getCurrentContext();
        -:  665:    IMutableContext& getCurrentMutableContext();
        -:  666:    void cleanUpContext();
        -:  667:    Stream createStream( std::string const& streamName );
        -:  668:
        -:  669:}
        -:  670:
        -:  671:// #included from: internal/catch_test_registry.hpp
        -:  672:#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED
        -:  673:
        -:  674:// #included from: catch_interfaces_testcase.h
        -:  675:#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED
        -:  676:
        -:  677:#include <vector>
        -:  678:
        -:  679:namespace Catch {
        -:  680:
        -:  681:    class TestSpec;
        -:  682:
        -:  683:    struct ITestCase : IShared {
        -:  684:        virtual void invoke () const = 0;
        -:  685:    protected:
        -:  686:        virtual ~ITestCase();
        -:  687:    };
        -:  688:
        -:  689:    class TestCase;
        -:  690:    struct IConfig;
        -:  691:
        -:  692:    struct ITestCaseRegistry {
        -:  693:        virtual ~ITestCaseRegistry();
        -:  694:        virtual std::vector<TestCase> const& getAllTests() const = 0;
        -:  695:        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const = 0;
        -:  696:    };
        -:  697:
        -:  698:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config );
        -:  699:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config );
        -:  700:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config );
        -:  701:
        -:  702:}
        -:  703:
        -:  704:namespace Catch {
        -:  705:
        -:  706:template<typename C>
        -:  707:class MethodTestCase : public SharedImpl<ITestCase> {
        -:  708:
        -:  709:public:
        -:  710:    MethodTestCase( void (C::*method)() ) : m_method( method ) {}
        -:  711:
        -:  712:    virtual void invoke() const {
        -:  713:        C obj;
        -:  714:        (obj.*m_method)();
        -:  715:    }
        -:  716:
        -:  717:private:
        -:  718:    virtual ~MethodTestCase() {}
        -:  719:
        -:  720:    void (C::*m_method)();
        -:  721:};
        -:  722:
        -:  723:typedef void(*TestFunction)();
        -:  724:
        -:  725:struct NameAndDesc {
        1:  726:    NameAndDesc( const char* _name = "", const char* _description= "" )
        1:  727:    : name( _name ), description( _description )
        1:  728:    {}
        -:  729:
        -:  730:    const char* name;
        -:  731:    const char* description;
        -:  732:};
        -:  733:
        -:  734:void registerTestCase
        -:  735:    (   ITestCase* testCase,
        -:  736:        char const* className,
        -:  737:        NameAndDesc const& nameAndDesc,
        -:  738:        SourceLineInfo const& lineInfo );
        -:  739:
        -:  740:struct AutoReg {
        -:  741:
        -:  742:    AutoReg
        -:  743:        (   TestFunction function,
        -:  744:            SourceLineInfo const& lineInfo,
        -:  745:            NameAndDesc const& nameAndDesc );
        -:  746:
        -:  747:    template<typename C>
        -:  748:    AutoReg
        -:  749:        (   void (C::*method)(),
        -:  750:            char const* className,
        -:  751:            NameAndDesc const& nameAndDesc,
        -:  752:            SourceLineInfo const& lineInfo ) {
        -:  753:
        -:  754:        registerTestCase
        -:  755:            (   new MethodTestCase<C>( method ),
        -:  756:                className,
        -:  757:                nameAndDesc,
        -:  758:                lineInfo );
        -:  759:    }
        -:  760:
        -:  761:    ~AutoReg();
        -:  762:
        -:  763:private:
        -:  764:    AutoReg( AutoReg const& );
        -:  765:    void operator= ( AutoReg const& );
        -:  766:};
        -:  767:
        -:  768:void registerTestCaseFunction
        -:  769:    (   TestFunction function,
        -:  770:        SourceLineInfo const& lineInfo,
        -:  771:        NameAndDesc const& nameAndDesc );
        -:  772:
        -:  773:} // end namespace Catch
        -:  774:
        -:  775:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:  776:    ///////////////////////////////////////////////////////////////////////////////
        -:  777:    #define INTERNAL_CATCH_TESTCASE2( TestName, ... ) \
        -:  778:        static void TestName(); \
        -:  779:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  780:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); } /* NOLINT */ \
        -:  781:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \
        -:  782:        static void TestName()
        -:  783:    #define INTERNAL_CATCH_TESTCASE( ... ) \
        -:  784:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), __VA_ARGS__ )
        -:  785:
        -:  786:    ///////////////////////////////////////////////////////////////////////////////
        -:  787:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, ... ) \
        -:  788:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  789:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); } /* NOLINT */ \
        -:  790:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS
        -:  791:
        -:  792:    ///////////////////////////////////////////////////////////////////////////////
        -:  793:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestName, ClassName, ... )\
        -:  794:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  795:        namespace{ \
        -:  796:            struct TestName : ClassName{ \
        -:  797:                void test(); \
        -:  798:            }; \
        -:  799:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestName::test, #ClassName, Catch::NameAndDesc( __VA_ARGS__ ), CATCH_INTERNAL_LINEINFO ); /* NOLINT */ \
        -:  800:        } \
        -:  801:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \
        -:  802:        void TestName::test()
        -:  803:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, ... ) \
        -:  804:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, __VA_ARGS__ )
        -:  805:
        -:  806:    ///////////////////////////////////////////////////////////////////////////////
        -:  807:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, ... ) \
        -:  808:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  809:        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( __VA_ARGS__ ) ); /* NOLINT */ \
        -:  810:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS
        -:  811:
        -:  812:#else
        -:  813:    ///////////////////////////////////////////////////////////////////////////////
        -:  814:    #define INTERNAL_CATCH_TESTCASE2( TestName, Name, Desc ) \
        -:  815:        static void TestName(); \
        -:  816:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  817:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &TestName, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); } /* NOLINT */ \
        -:  818:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \
        -:  819:        static void TestName()
        -:  820:    #define INTERNAL_CATCH_TESTCASE( Name, Desc ) \
        -:  821:        INTERNAL_CATCH_TESTCASE2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), Name, Desc )
        -:  822:
        -:  823:    ///////////////////////////////////////////////////////////////////////////////
        -:  824:    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE( QualifiedMethod, Name, Desc ) \
        -:  825:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  826:        namespace{ Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar )( &QualifiedMethod, "&" #QualifiedMethod, Catch::NameAndDesc( Name, Desc ), CATCH_INTERNAL_LINEINFO ); } /* NOLINT */ \
        -:  827:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS
        -:  828:
        -:  829:    ///////////////////////////////////////////////////////////////////////////////
        -:  830:    #define INTERNAL_CATCH_TEST_CASE_METHOD2( TestCaseName, ClassName, TestName, Desc )\
        -:  831:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  832:        namespace{ \
        -:  833:            struct TestCaseName : ClassName{ \
        -:  834:                void test(); \
        -:  835:            }; \
        -:  836:            Catch::AutoReg INTERNAL_CATCH_UNIQUE_NAME( autoRegistrar ) ( &TestCaseName::test, #ClassName, Catch::NameAndDesc( TestName, Desc ), CATCH_INTERNAL_LINEINFO ); /* NOLINT */ \
        -:  837:        } \
        -:  838:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS \
        -:  839:        void TestCaseName::test()
        -:  840:    #define INTERNAL_CATCH_TEST_CASE_METHOD( ClassName, TestName, Desc )\
        -:  841:        INTERNAL_CATCH_TEST_CASE_METHOD2( INTERNAL_CATCH_UNIQUE_NAME( ____C_A_T_C_H____T_E_S_T____ ), ClassName, TestName, Desc )
        -:  842:
        -:  843:    ///////////////////////////////////////////////////////////////////////////////
        -:  844:    #define INTERNAL_CATCH_REGISTER_TESTCASE( Function, Name, Desc ) \
        -:  845:        CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS \
        -:  846:        Catch::AutoReg( Function, CATCH_INTERNAL_LINEINFO, Catch::NameAndDesc( Name, Desc ) ); /* NOLINT */ \
        -:  847:        CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS
        -:  848:
        -:  849:#endif
        -:  850:
        -:  851:// #included from: internal/catch_capture.hpp
        -:  852:#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED
        -:  853:
        -:  854:// #included from: catch_result_builder.h
        -:  855:#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED
        -:  856:
        -:  857:// #included from: catch_result_type.h
        -:  858:#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED
        -:  859:
        -:  860:namespace Catch {
        -:  861:
        -:  862:    // ResultWas::OfType enum
        -:  863:    struct ResultWas { enum OfType {
        -:  864:        Unknown = -1,
        -:  865:        Ok = 0,
        -:  866:        Info = 1,
        -:  867:        Warning = 2,
        -:  868:
        -:  869:        FailureBit = 0x10,
        -:  870:
        -:  871:        ExpressionFailed = FailureBit | 1,
        -:  872:        ExplicitFailure = FailureBit | 2,
        -:  873:
        -:  874:        Exception = 0x100 | FailureBit,
        -:  875:
        -:  876:        ThrewException = Exception | 1,
        -:  877:        DidntThrowException = Exception | 2,
        -:  878:
        -:  879:        FatalErrorCondition = 0x200 | FailureBit
        -:  880:
        -:  881:    }; };
        -:  882:
    #####:  883:    inline bool isOk( ResultWas::OfType resultType ) {
    #####:  884:        return ( resultType & ResultWas::FailureBit ) == 0;
        -:  885:    }
        -:  886:    inline bool isJustInfo( int flags ) {
        -:  887:        return flags == ResultWas::Info;
        -:  888:    }
        -:  889:
        -:  890:    // ResultDisposition::Flags enum
        -:  891:    struct ResultDisposition { enum Flags {
        -:  892:        Normal = 0x01,
        -:  893:
        -:  894:        ContinueOnFailure = 0x02,   // Failures fail test, but execution continues
        -:  895:        FalseTest = 0x04,           // Prefix expression with !
        -:  896:        SuppressFail = 0x08         // Failures are reported but do not fail the test
        -:  897:    }; };
        -:  898:
        -:  899:    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {
        -:  900:        return static_cast<ResultDisposition::Flags>( static_cast<int>( lhs ) | static_cast<int>( rhs ) );
        -:  901:    }
        -:  902:
        -:  903:    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }
        6:  904:    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }
    #####:  905:    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }
        -:  906:
        -:  907:} // end namespace Catch
        -:  908:
        -:  909:// #included from: catch_assertionresult.h
        -:  910:#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED
        -:  911:
        -:  912:#include <string>
        -:  913:
        -:  914:namespace Catch {
        -:  915:
        -:  916:    struct STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison;
        -:  917:
        -:  918:    struct DecomposedExpression
        -:  919:    {
      18*:  920:        virtual ~DecomposedExpression() {}
------------------
_ZN5Catch20DecomposedExpressionD0Ev:
    #####:  920:        virtual ~DecomposedExpression() {}
------------------
_ZN5Catch20DecomposedExpressionD2Ev:
       18:  920:        virtual ~DecomposedExpression() {}
------------------
    #####:  921:        virtual bool isBinaryExpression() const {
    #####:  922:            return false;
        -:  923:        }
        -:  924:        virtual void reconstructExpression( std::string& dest ) const = 0;
        -:  925:
        -:  926:        // Only simple binary comparisons can be decomposed.
        -:  927:        // If more complex check is required then wrap sub-expressions in parentheses.
        -:  928:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator + ( T const& );
        -:  929:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator - ( T const& );
        -:  930:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator * ( T const& );
        -:  931:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator / ( T const& );
        -:  932:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator % ( T const& );
        -:  933:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator && ( T const& );
        -:  934:        template<typename T> STATIC_ASSERT_Expression_Too_Complex_Please_Rewrite_As_Binary_Comparison& operator || ( T const& );
        -:  935:
        -:  936:    private:
        -:  937:        DecomposedExpression& operator = (DecomposedExpression const&);
        -:  938:    };
        -:  939:
        -:  940:    struct AssertionInfo
        -:  941:    {
        -:  942:        AssertionInfo();
        -:  943:        AssertionInfo(  char const * _macroName,
        -:  944:                        SourceLineInfo const& _lineInfo,
        -:  945:                        char const * _capturedExpression,
        -:  946:                        ResultDisposition::Flags _resultDisposition,
        -:  947:                        char const * _secondArg = "");
        -:  948:
        -:  949:        char const * macroName;
        -:  950:        SourceLineInfo lineInfo;
        -:  951:        char const * capturedExpression;
        -:  952:        ResultDisposition::Flags resultDisposition;
        -:  953:        char const * secondArg;
        -:  954:    };
        -:  955:
        -:  956:    struct AssertionResultData
        -:  957:    {
        7:  958:        AssertionResultData() : decomposedExpression( CATCH_NULL )
        -:  959:                              , resultType( ResultWas::Unknown )
        -:  960:                              , negated( false )
        7:  961:                              , parenthesized( false ) {}
        -:  962:
    #####:  963:        void negate( bool parenthesize ) {
    #####:  964:            negated = !negated;
    #####:  965:            parenthesized = parenthesize;
    #####:  966:            if( resultType == ResultWas::Ok )
    #####:  967:                resultType = ResultWas::ExpressionFailed;
    #####:  968:            else if( resultType == ResultWas::ExpressionFailed )
    #####:  969:                resultType = ResultWas::Ok;
    #####:  970:        }
        -:  971:
    #####:  972:        std::string const& reconstructExpression() const {
    #####:  973:            if( decomposedExpression != CATCH_NULL ) {
    #####:  974:                decomposedExpression->reconstructExpression( reconstructedExpression );
    #####:  975:                if( parenthesized ) {
    #####:  976:                    reconstructedExpression.insert( 0, 1, '(' );
    #####:  977:                    reconstructedExpression.append( 1, ')' );
        -:  978:                }
    #####:  979:                if( negated ) {
    #####:  980:                    reconstructedExpression.insert( 0, 1, '!' );
        -:  981:                }
    #####:  982:                decomposedExpression = CATCH_NULL;
        -:  983:            }
    #####:  984:            return reconstructedExpression;
        -:  985:        }
        -:  986:
        -:  987:        mutable DecomposedExpression const* decomposedExpression;
        -:  988:        mutable std::string reconstructedExpression;
        -:  989:        std::string message;
        -:  990:        ResultWas::OfType resultType;
        -:  991:        bool negated;
        -:  992:        bool parenthesized;
        -:  993:    };
        -:  994:
    #####:  995:    class AssertionResult {
        -:  996:    public:
        -:  997:        AssertionResult();
        -:  998:        AssertionResult( AssertionInfo const& info, AssertionResultData const& data );
        -:  999:        ~AssertionResult();
        -: 1000:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 1001:         AssertionResult( AssertionResult const& )              = default;
    #####: 1002:         AssertionResult( AssertionResult && )                  = default;
        -: 1003:         AssertionResult& operator = ( AssertionResult const& ) = default;
        -: 1004:         AssertionResult& operator = ( AssertionResult && )     = default;
        -: 1005:#  endif
        -: 1006:
        -: 1007:        bool isOk() const;
        -: 1008:        bool succeeded() const;
        -: 1009:        ResultWas::OfType getResultType() const;
        -: 1010:        bool hasExpression() const;
        -: 1011:        bool hasMessage() const;
        -: 1012:        std::string getExpression() const;
        -: 1013:        std::string getExpressionInMacro() const;
        -: 1014:        bool hasExpandedExpression() const;
        -: 1015:        std::string getExpandedExpression() const;
        -: 1016:        std::string getMessage() const;
        -: 1017:        SourceLineInfo getSourceInfo() const;
        -: 1018:        std::string getTestMacroName() const;
        -: 1019:        void discardDecomposedExpression() const;
        -: 1020:        void expandDecomposedExpression() const;
        -: 1021:
        -: 1022:    protected:
        -: 1023:        AssertionInfo m_info;
        -: 1024:        AssertionResultData m_resultData;
        -: 1025:    };
        -: 1026:
        -: 1027:} // end namespace Catch
        -: 1028:
        -: 1029:// #included from: catch_matchers.hpp
        -: 1030:#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED
        -: 1031:
        -: 1032:namespace Catch {
        -: 1033:namespace Matchers {
        -: 1034:    namespace Impl {
        -: 1035:
        -: 1036:        template<typename ArgT> struct MatchAllOf;
        -: 1037:        template<typename ArgT> struct MatchAnyOf;
        -: 1038:        template<typename ArgT> struct MatchNotOf;
        -: 1039:
        -: 1040:        class MatcherUntypedBase {
        -: 1041:        public:
    #####: 1042:            std::string toString() const {
    #####: 1043:                if( m_cachedToString.empty() )
    #####: 1044:                    m_cachedToString = describe();
    #####: 1045:                return m_cachedToString;
        -: 1046:            }
        -: 1047:
        -: 1048:        protected:
        -: 1049:            virtual ~MatcherUntypedBase();
        -: 1050:            virtual std::string describe() const = 0;
        -: 1051:            mutable std::string m_cachedToString;
        -: 1052:        private:
        -: 1053:            MatcherUntypedBase& operator = ( MatcherUntypedBase const& );
        -: 1054:        };
        -: 1055:
        -: 1056:        template<typename ObjectT>
        -: 1057:        struct MatcherMethod {
        -: 1058:            virtual bool match( ObjectT const& arg ) const = 0;
        -: 1059:        };
        -: 1060:        template<typename PtrT>
        -: 1061:        struct MatcherMethod<PtrT*> {
        -: 1062:            virtual bool match( PtrT* arg ) const = 0;
        -: 1063:        };
        -: 1064:
        -: 1065:        template<typename ObjectT, typename ComparatorT = ObjectT>
        -: 1066:        struct MatcherBase : MatcherUntypedBase, MatcherMethod<ObjectT> {
        -: 1067:
        -: 1068:            MatchAllOf<ComparatorT> operator && ( MatcherBase const& other ) const;
        -: 1069:            MatchAnyOf<ComparatorT> operator || ( MatcherBase const& other ) const;
        -: 1070:            MatchNotOf<ComparatorT> operator ! () const;
        -: 1071:        };
        -: 1072:
        -: 1073:        template<typename ArgT>
        -: 1074:        struct MatchAllOf : MatcherBase<ArgT> {
    #####: 1075:            virtual bool match( ArgT const& arg ) const CATCH_OVERRIDE {
    #####: 1076:                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
    #####: 1077:                    if (!m_matchers[i]->match(arg))
    #####: 1078:                        return false;
        -: 1079:                }
    #####: 1080:                return true;
        -: 1081:            }
    #####: 1082:            virtual std::string describe() const CATCH_OVERRIDE {
    #####: 1083:                std::string description;
    #####: 1084:                description.reserve( 4 + m_matchers.size()*32 );
    #####: 1085:                description += "( ";
    #####: 1086:                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
    #####: 1087:                    if( i != 0 )
    #####: 1088:                        description += " and ";
    #####: 1089:                    description += m_matchers[i]->toString();
        -: 1090:                }
    #####: 1091:                description += " )";
    #####: 1092:                return description;
        -: 1093:            }
        -: 1094:
        -: 1095:            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {
        -: 1096:                m_matchers.push_back( &other );
        -: 1097:                return *this;
        -: 1098:            }
        -: 1099:
        -: 1100:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -: 1101:        };
        -: 1102:        template<typename ArgT>
        -: 1103:        struct MatchAnyOf : MatcherBase<ArgT> {
        -: 1104:
        -: 1105:            virtual bool match( ArgT const& arg ) const CATCH_OVERRIDE {
        -: 1106:                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
        -: 1107:                    if (m_matchers[i]->match(arg))
        -: 1108:                        return true;
        -: 1109:                }
        -: 1110:                return false;
        -: 1111:            }
        -: 1112:            virtual std::string describe() const CATCH_OVERRIDE {
        -: 1113:                std::string description;
        -: 1114:                description.reserve( 4 + m_matchers.size()*32 );
        -: 1115:                description += "( ";
        -: 1116:                for( std::size_t i = 0; i < m_matchers.size(); ++i ) {
        -: 1117:                    if( i != 0 )
        -: 1118:                        description += " or ";
        -: 1119:                    description += m_matchers[i]->toString();
        -: 1120:                }
        -: 1121:                description += " )";
        -: 1122:                return description;
        -: 1123:            }
        -: 1124:
        -: 1125:            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {
        -: 1126:                m_matchers.push_back( &other );
        -: 1127:                return *this;
        -: 1128:            }
        -: 1129:
        -: 1130:            std::vector<MatcherBase<ArgT> const*> m_matchers;
        -: 1131:        };
        -: 1132:
        -: 1133:        template<typename ArgT>
        -: 1134:        struct MatchNotOf : MatcherBase<ArgT> {
        -: 1135:
        -: 1136:            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}
        -: 1137:
        -: 1138:            virtual bool match( ArgT const& arg ) const CATCH_OVERRIDE {
        -: 1139:                return !m_underlyingMatcher.match( arg );
        -: 1140:            }
        -: 1141:
        -: 1142:            virtual std::string describe() const CATCH_OVERRIDE {
        -: 1143:                return "not " + m_underlyingMatcher.toString();
        -: 1144:            }
        -: 1145:            MatcherBase<ArgT> const& m_underlyingMatcher;
        -: 1146:        };
        -: 1147:
        -: 1148:        template<typename ObjectT, typename ComparatorT>
        -: 1149:        MatchAllOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator && ( MatcherBase const& other ) const {
        -: 1150:            return MatchAllOf<ComparatorT>() && *this && other;
        -: 1151:        }
        -: 1152:        template<typename ObjectT, typename ComparatorT>
        -: 1153:        MatchAnyOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator || ( MatcherBase const& other ) const {
        -: 1154:            return MatchAnyOf<ComparatorT>() || *this || other;
        -: 1155:        }
        -: 1156:        template<typename ObjectT, typename ComparatorT>
        -: 1157:        MatchNotOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator ! () const {
        -: 1158:            return MatchNotOf<ComparatorT>( *this );
        -: 1159:        }
        -: 1160:
        -: 1161:    } // namespace Impl
        -: 1162:
        -: 1163:    // The following functions create the actual matcher objects.
        -: 1164:    // This allows the types to be inferred
        -: 1165:    // - deprecated: prefer ||, && and !
        -: 1166:    template<typename T>
        -: 1167:    Impl::MatchNotOf<T> Not( Impl::MatcherBase<T> const& underlyingMatcher ) {
        -: 1168:        return Impl::MatchNotOf<T>( underlyingMatcher );
        -: 1169:    }
        -: 1170:    template<typename T>
        -: 1171:    Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2 ) {
        -: 1172:        return Impl::MatchAllOf<T>() && m1 && m2;
        -: 1173:    }
        -: 1174:    template<typename T>
        -: 1175:    Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3 ) {
        -: 1176:        return Impl::MatchAllOf<T>() && m1 && m2 && m3;
        -: 1177:    }
        -: 1178:    template<typename T>
        -: 1179:    Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2 ) {
        -: 1180:        return Impl::MatchAnyOf<T>() || m1 || m2;
        -: 1181:    }
        -: 1182:    template<typename T>
        -: 1183:    Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3 ) {
        -: 1184:        return Impl::MatchAnyOf<T>() || m1 || m2 || m3;
        -: 1185:    }
        -: 1186:
        -: 1187:} // namespace Matchers
        -: 1188:
        -: 1189:using namespace Matchers;
        -: 1190:using Matchers::Impl::MatcherBase;
        -: 1191:
        -: 1192:} // namespace Catch
        -: 1193:
        -: 1194:namespace Catch {
        -: 1195:
        -: 1196:    struct TestFailureException{};
        -: 1197:
        -: 1198:    template<typename T> class ExpressionLhs;
        -: 1199:
        -: 1200:    struct CopyableStream {
    #####: 1201:        CopyableStream() {}
        -: 1202:        CopyableStream( CopyableStream const& other ) {
        -: 1203:            oss << other.oss.str();
        -: 1204:        }
        -: 1205:        CopyableStream& operator=( CopyableStream const& other ) {
        -: 1206:            oss.str(std::string());
        -: 1207:            oss << other.oss.str();
        -: 1208:            return *this;
        -: 1209:        }
        -: 1210:        std::ostringstream oss;
        -: 1211:    };
        -: 1212:
        -: 1213:    class ResultBuilder : public DecomposedExpression {
        -: 1214:    public:
        -: 1215:        ResultBuilder(  char const* macroName,
        -: 1216:                        SourceLineInfo const& lineInfo,
        -: 1217:                        char const* capturedExpression,
        -: 1218:                        ResultDisposition::Flags resultDisposition,
        -: 1219:                        char const* secondArg = "" );
        -: 1220:        ~ResultBuilder();
        -: 1221:
        -: 1222:        template<typename T>
        -: 1223:        ExpressionLhs<T const&> operator <= ( T const& operand );
        -: 1224:        ExpressionLhs<bool> operator <= ( bool value );
        -: 1225:
        -: 1226:        template<typename T>
    #####: 1227:        ResultBuilder& operator << ( T const& value ) {
    #####: 1228:            stream().oss << value;
    #####: 1229:            return *this;
        -: 1230:        }
        -: 1231:
        -: 1232:        ResultBuilder& setResultType( ResultWas::OfType result );
        -: 1233:        ResultBuilder& setResultType( bool result );
        -: 1234:
        -: 1235:        void endExpression( DecomposedExpression const& expr );
        -: 1236:
        -: 1237:        virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE;
        -: 1238:
        -: 1239:        AssertionResult build() const;
        -: 1240:        AssertionResult build( DecomposedExpression const& expr ) const;
        -: 1241:
        -: 1242:        void useActiveException( ResultDisposition::Flags resultDisposition = ResultDisposition::Normal );
        -: 1243:        void captureResult( ResultWas::OfType resultType );
        -: 1244:        void captureExpression();
        -: 1245:        void captureExpectedException( std::string const& expectedMessage );
        -: 1246:        void captureExpectedException( Matchers::Impl::MatcherBase<std::string> const& matcher );
        -: 1247:        void handleResult( AssertionResult const& result );
        -: 1248:        void react();
        -: 1249:        bool shouldDebugBreak() const;
        -: 1250:        bool allowThrows() const;
        -: 1251:
        -: 1252:        template<typename ArgT, typename MatcherT>
        -: 1253:        void captureMatch( ArgT const& arg, MatcherT const& matcher, char const* matcherString );
        -: 1254:
        -: 1255:        void setExceptionGuard();
        -: 1256:        void unsetExceptionGuard();
        -: 1257:
        -: 1258:    private:
        -: 1259:        AssertionInfo m_assertionInfo;
        -: 1260:        AssertionResultData m_data;
        -: 1261:
    #####: 1262:        CopyableStream &stream()
        -: 1263:        {
    #####: 1264:            if(!m_usedStream)
        -: 1265:            {
    #####: 1266:                m_usedStream = true;
    #####: 1267:                m_stream().oss.str("");
        -: 1268:            }
    #####: 1269:            return m_stream();
        -: 1270:        }
        -: 1271:
    #####: 1272:        static CopyableStream &m_stream()
        -: 1273:        {
    #####: 1274:            static CopyableStream s;
    #####: 1275:            return s;
        -: 1276:        }
        -: 1277:
        -: 1278:        bool m_shouldDebugBreak;
        -: 1279:        bool m_shouldThrow;
        -: 1280:        bool m_guardException;
        -: 1281:        bool m_usedStream;
        -: 1282:    };
        -: 1283:
        -: 1284:} // namespace Catch
        -: 1285:
        -: 1286:// Include after due to circular dependency:
        -: 1287:// #included from: catch_expression_lhs.hpp
        -: 1288:#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED
        -: 1289:
        -: 1290:// #included from: catch_evaluate.hpp
        -: 1291:#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED
        -: 1292:
        -: 1293:#ifdef _MSC_VER
        -: 1294:#pragma warning(push)
        -: 1295:#pragma warning(disable:4389) // '==' : signed/unsigned mismatch
        -: 1296:#pragma warning(disable:4018) // more "signed/unsigned mismatch"
        -: 1297:#pragma warning(disable:4312) // Converting int to T* using reinterpret_cast (issue on x64 platform)
        -: 1298:#endif
        -: 1299:
        -: 1300:#include <cstddef>
        -: 1301:
        -: 1302:namespace Catch {
        -: 1303:namespace Internal {
        -: 1304:
        -: 1305:    enum Operator {
        -: 1306:        IsEqualTo,
        -: 1307:        IsNotEqualTo,
        -: 1308:        IsLessThan,
        -: 1309:        IsGreaterThan,
        -: 1310:        IsLessThanOrEqualTo,
        -: 1311:        IsGreaterThanOrEqualTo
        -: 1312:    };
        -: 1313:
        -: 1314:    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };
    #####: 1315:    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };
        -: 1316:    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };
        -: 1317:    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };
        -: 1318:    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };
        -: 1319:    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };
        -: 1320:    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };
        -: 1321:
        -: 1322:    template<typename T>
       12: 1323:    T& opCast(T const& t) { return const_cast<T&>(t); }
        -: 1324:
        -: 1325:// nullptr_t support based on pull request #154 from Konstantin Baumann
        -: 1326:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -: 1327:    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }
        -: 1328:#endif // CATCH_CONFIG_CPP11_NULLPTR
        -: 1329:
        -: 1330:    // So the compare overloads can be operator agnostic we convey the operator as a template
        -: 1331:    // enum, which is used to specialise an Evaluator for doing the comparison.
        -: 1332:    template<typename T1, typename T2, Operator Op>
        -: 1333:    struct Evaluator{};
        -: 1334:
        -: 1335:    template<typename T1, typename T2>
        -: 1336:    struct Evaluator<T1, T2, IsEqualTo> {
        6: 1337:        static bool evaluate( T1 const& lhs, T2 const& rhs) {
        6: 1338:            return bool( opCast( lhs ) ==  opCast( rhs ) );
        -: 1339:        }
        -: 1340:    };
        -: 1341:    template<typename T1, typename T2>
        -: 1342:    struct Evaluator<T1, T2, IsNotEqualTo> {
        -: 1343:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1344:            return bool( opCast( lhs ) != opCast( rhs ) );
        -: 1345:        }
        -: 1346:    };
        -: 1347:    template<typename T1, typename T2>
        -: 1348:    struct Evaluator<T1, T2, IsLessThan> {
        -: 1349:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1350:            return bool( opCast( lhs ) < opCast( rhs ) );
        -: 1351:        }
        -: 1352:    };
        -: 1353:    template<typename T1, typename T2>
        -: 1354:    struct Evaluator<T1, T2, IsGreaterThan> {
        -: 1355:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1356:            return bool( opCast( lhs ) > opCast( rhs ) );
        -: 1357:        }
        -: 1358:    };
        -: 1359:    template<typename T1, typename T2>
        -: 1360:    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {
        -: 1361:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1362:            return bool( opCast( lhs ) >= opCast( rhs ) );
        -: 1363:        }
        -: 1364:    };
        -: 1365:    template<typename T1, typename T2>
        -: 1366:    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {
        -: 1367:        static bool evaluate( T1 const& lhs, T2 const& rhs ) {
        -: 1368:            return bool( opCast( lhs ) <= opCast( rhs ) );
        -: 1369:        }
        -: 1370:    };
        -: 1371:
        -: 1372:    template<Operator Op, typename T1, typename T2>
        -: 1373:    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {
        -: 1374:        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
        -: 1375:    }
        -: 1376:
        -: 1377:    // This level of indirection allows us to specialise for integer types
        -: 1378:    // to avoid signed/ unsigned warnings
        -: 1379:
        -: 1380:    // "base" overload
        -: 1381:    template<Operator Op, typename T1, typename T2>
        6: 1382:    bool compare( T1 const& lhs, T2 const& rhs ) {
        6: 1383:        return Evaluator<T1, T2, Op>::evaluate( lhs, rhs );
        -: 1384:    }
        -: 1385:
        -: 1386:    // unsigned X to int
        -: 1387:    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {
        -: 1388:        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
        -: 1389:    }
        -: 1390:    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {
        -: 1391:        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
        -: 1392:    }
        -: 1393:    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {
        -: 1394:        return applyEvaluator<Op>( lhs, static_cast<unsigned int>( rhs ) );
        -: 1395:    }
        -: 1396:
        -: 1397:    // unsigned X to long
        -: 1398:    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {
        -: 1399:        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
        -: 1400:    }
        -: 1401:    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {
        -: 1402:        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
        -: 1403:    }
        -: 1404:    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {
        -: 1405:        return applyEvaluator<Op>( lhs, static_cast<unsigned long>( rhs ) );
        -: 1406:    }
        -: 1407:
        -: 1408:    // int to unsigned X
        -: 1409:    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {
        -: 1410:        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
        -: 1411:    }
        -: 1412:    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {
        -: 1413:        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
        -: 1414:    }
        -: 1415:    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {
        -: 1416:        return applyEvaluator<Op>( static_cast<unsigned int>( lhs ), rhs );
        -: 1417:    }
        -: 1418:
        -: 1419:    // long to unsigned X
        -: 1420:    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {
        -: 1421:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1422:    }
        -: 1423:    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {
        -: 1424:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1425:    }
        -: 1426:    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {
        -: 1427:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1428:    }
        -: 1429:
        -: 1430:    // pointer to long (when comparing against NULL)
        -: 1431:    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {
        -: 1432:        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
        -: 1433:    }
        -: 1434:    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {
        -: 1435:        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
        -: 1436:    }
        -: 1437:
        -: 1438:    // pointer to int (when comparing against NULL)
        -: 1439:    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {
        -: 1440:        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
        -: 1441:    }
        -: 1442:    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {
        -: 1443:        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
        -: 1444:    }
        -: 1445:
        -: 1446:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
        -: 1447:    // long long to unsigned X
        -: 1448:    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {
        -: 1449:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1450:    }
        -: 1451:    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {
        -: 1452:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1453:    }
        -: 1454:    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {
        -: 1455:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1456:    }
        -: 1457:    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {
        -: 1458:        return applyEvaluator<Op>( static_cast<unsigned long>( lhs ), rhs );
        -: 1459:    }
        -: 1460:
        -: 1461:    // unsigned long long to X
        -: 1462:    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {
        -: 1463:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1464:    }
        -: 1465:    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {
        -: 1466:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1467:    }
        -: 1468:    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {
        -: 1469:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1470:    }
        -: 1471:    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {
        -: 1472:        return applyEvaluator<Op>( static_cast<long>( lhs ), rhs );
        -: 1473:    }
        -: 1474:
        -: 1475:    // pointer to long long (when comparing against NULL)
        -: 1476:    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {
        -: 1477:        return Evaluator<T*, T*, Op>::evaluate( reinterpret_cast<T*>( lhs ), rhs );
        -: 1478:    }
        -: 1479:    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {
        -: 1480:        return Evaluator<T*, T*, Op>::evaluate( lhs, reinterpret_cast<T*>( rhs ) );
        -: 1481:    }
        -: 1482:#endif // CATCH_CONFIG_CPP11_LONG_LONG
        -: 1483:
        -: 1484:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -: 1485:    // pointer to nullptr_t (when comparing against nullptr)
        -: 1486:    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {
        -: 1487:        return Evaluator<T*, T*, Op>::evaluate( nullptr, rhs );
        -: 1488:    }
        -: 1489:    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {
        -: 1490:        return Evaluator<T*, T*, Op>::evaluate( lhs, nullptr );
        -: 1491:    }
        -: 1492:#endif // CATCH_CONFIG_CPP11_NULLPTR
        -: 1493:
        -: 1494:} // end of namespace Internal
        -: 1495:} // end of namespace Catch
        -: 1496:
        -: 1497:#ifdef _MSC_VER
        -: 1498:#pragma warning(pop)
        -: 1499:#endif
        -: 1500:
        -: 1501:// #included from: catch_tostring.h
        -: 1502:#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED
        -: 1503:
        -: 1504:#include <sstream>
        -: 1505:#include <iomanip>
        -: 1506:#include <limits>
        -: 1507:#include <vector>
        -: 1508:#include <cstddef>
        -: 1509:
        -: 1510:#ifdef __OBJC__
        -: 1511:// #included from: catch_objc_arc.hpp
        -: 1512:#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED
        -: 1513:
        -: 1514:#import <Foundation/Foundation.h>
        -: 1515:
        -: 1516:#ifdef __has_feature
        -: 1517:#define CATCH_ARC_ENABLED __has_feature(objc_arc)
        -: 1518:#else
        -: 1519:#define CATCH_ARC_ENABLED 0
        -: 1520:#endif
        -: 1521:
        -: 1522:void arcSafeRelease( NSObject* obj );
        -: 1523:id performOptionalSelector( id obj, SEL sel );
        -: 1524:
        -: 1525:#if !CATCH_ARC_ENABLED
        -: 1526:inline void arcSafeRelease( NSObject* obj ) {
        -: 1527:    [obj release];
        -: 1528:}
        -: 1529:inline id performOptionalSelector( id obj, SEL sel ) {
        -: 1530:    if( [obj respondsToSelector: sel] )
        -: 1531:        return [obj performSelector: sel];
        -: 1532:    return nil;
        -: 1533:}
        -: 1534:#define CATCH_UNSAFE_UNRETAINED
        -: 1535:#define CATCH_ARC_STRONG
        -: 1536:#else
        -: 1537:inline void arcSafeRelease( NSObject* ){}
        -: 1538:inline id performOptionalSelector( id obj, SEL sel ) {
        -: 1539:#ifdef __clang__
        -: 1540:#pragma clang diagnostic push
        -: 1541:#pragma clang diagnostic ignored "-Warc-performSelector-leaks"
        -: 1542:#endif
        -: 1543:    if( [obj respondsToSelector: sel] )
        -: 1544:        return [obj performSelector: sel];
        -: 1545:#ifdef __clang__
        -: 1546:#pragma clang diagnostic pop
        -: 1547:#endif
        -: 1548:    return nil;
        -: 1549:}
        -: 1550:#define CATCH_UNSAFE_UNRETAINED __unsafe_unretained
        -: 1551:#define CATCH_ARC_STRONG __strong
        -: 1552:#endif
        -: 1553:
        -: 1554:#endif
        -: 1555:
        -: 1556:#ifdef CATCH_CONFIG_CPP11_TUPLE
        -: 1557:#include <tuple>
        -: 1558:#endif
        -: 1559:
        -: 1560:#ifdef CATCH_CONFIG_CPP11_IS_ENUM
        -: 1561:#include <type_traits>
        -: 1562:#endif
        -: 1563:
        -: 1564:namespace Catch {
        -: 1565:
        -: 1566:// Why we're here.
        -: 1567:template<typename T>
        -: 1568:std::string toString( T const& value );
        -: 1569:
        -: 1570:// Built in overloads
        -: 1571:
        -: 1572:std::string toString( std::string const& value );
        -: 1573:std::string toString( std::wstring const& value );
        -: 1574:std::string toString( const char* const value );
        -: 1575:std::string toString( char* const value );
        -: 1576:std::string toString( const wchar_t* const value );
        -: 1577:std::string toString( wchar_t* const value );
        -: 1578:std::string toString( int value );
        -: 1579:std::string toString( unsigned long value );
        -: 1580:std::string toString( unsigned int value );
        -: 1581:std::string toString( const double value );
        -: 1582:std::string toString( const float value );
        -: 1583:std::string toString( bool value );
        -: 1584:std::string toString( char value );
        -: 1585:std::string toString( signed char value );
        -: 1586:std::string toString( unsigned char value );
        -: 1587:
        -: 1588:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
        -: 1589:std::string toString( long long value );
        -: 1590:std::string toString( unsigned long long value );
        -: 1591:#endif
        -: 1592:
        -: 1593:#ifdef CATCH_CONFIG_CPP11_NULLPTR
        -: 1594:std::string toString( std::nullptr_t );
        -: 1595:#endif
        -: 1596:
        -: 1597:#ifdef __OBJC__
        -: 1598:    std::string toString( NSString const * const& nsstring );
        -: 1599:    std::string toString( NSString * CATCH_ARC_STRONG & nsstring );
        -: 1600:    std::string toString( NSObject* const& nsObject );
        -: 1601:#endif
        -: 1602:
        -: 1603:namespace Detail {
        -: 1604:
        -: 1605:    extern const std::string unprintableString;
        -: 1606:
        -: 1607: #if !defined(CATCH_CONFIG_CPP11_STREAM_INSERTABLE_CHECK)
        -: 1608:    struct BorgType {
        -: 1609:        template<typename T> BorgType( T const& );
        -: 1610:    };
        -: 1611:
        -: 1612:    struct TrueType { char sizer[1]; };
        -: 1613:    struct FalseType { char sizer[2]; };
        -: 1614:
        -: 1615:    TrueType& testStreamable( std::ostream& );
        -: 1616:    FalseType testStreamable( FalseType );
        -: 1617:
        -: 1618:    FalseType operator<<( std::ostream const&, BorgType const& );
        -: 1619:
        -: 1620:    template<typename T>
        -: 1621:    struct IsStreamInsertable {
        -: 1622:        static std::ostream &s;
        -: 1623:        static T  const&t;
        -: 1624:        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };
        -: 1625:    };
        -: 1626:#else
        -: 1627:    template<typename T>
        -: 1628:    class IsStreamInsertable {
        -: 1629:        template<typename SS, typename TT>
        -: 1630:        static auto test(int)
        -: 1631:        -> decltype( std::declval<SS&>() << std::declval<TT>(), std::true_type() );
        -: 1632:
        -: 1633:        template<typename, typename>
        -: 1634:        static auto test(...) -> std::false_type;
        -: 1635:
        -: 1636:    public:
        -: 1637:        static const bool value = decltype(test<std::ostream,const T&>(0))::value;
        -: 1638:    };
        -: 1639:#endif
        -: 1640:
        -: 1641:#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
        -: 1642:    template<typename T,
        -: 1643:             bool IsEnum = std::is_enum<T>::value
        -: 1644:             >
        -: 1645:    struct EnumStringMaker
        -: 1646:    {
        -: 1647:        static std::string convert( T const& ) { return unprintableString; }
        -: 1648:    };
        -: 1649:
        -: 1650:    template<typename T>
        -: 1651:    struct EnumStringMaker<T,true>
        -: 1652:    {
        -: 1653:        static std::string convert( T const& v )
        -: 1654:        {
        -: 1655:            return ::Catch::toString(
        -: 1656:                static_cast<typename std::underlying_type<T>::type>(v)
        -: 1657:                );
        -: 1658:        }
        -: 1659:    };
        -: 1660:#endif
        -: 1661:    template<bool C>
        -: 1662:    struct StringMakerBase {
        -: 1663:#if defined(CATCH_CONFIG_CPP11_IS_ENUM)
        -: 1664:        template<typename T>
        -: 1665:        static std::string convert( T const& v )
        -: 1666:        {
        -: 1667:            return EnumStringMaker<T>::convert( v );
        -: 1668:        }
        -: 1669:#else
        -: 1670:        template<typename T>
        -: 1671:        static std::string convert( T const& ) { return unprintableString; }
        -: 1672:#endif
        -: 1673:    };
        -: 1674:
        -: 1675:    template<>
        -: 1676:    struct StringMakerBase<true> {
        -: 1677:        template<typename T>
        -: 1678:        static std::string convert( T const& _value ) {
        -: 1679:            std::ostringstream oss;
        -: 1680:            oss << _value;
        -: 1681:            return oss.str();
        -: 1682:        }
        -: 1683:    };
        -: 1684:
        -: 1685:    std::string rawMemoryToString( const void *object, std::size_t size );
        -: 1686:
        -: 1687:    template<typename T>
        -: 1688:    std::string rawMemoryToString( const T& object ) {
        -: 1689:      return rawMemoryToString( &object, sizeof(object) );
        -: 1690:    }
        -: 1691:
        -: 1692:} // end namespace Detail
        -: 1693:
        -: 1694:template<typename T>
        -: 1695:struct StringMaker :
        -: 1696:    Detail::StringMakerBase<Detail::IsStreamInsertable<T>::value> {};
        -: 1697:
        -: 1698:template<typename T>
        -: 1699:struct StringMaker<T*> {
        -: 1700:    template<typename U>
        -: 1701:    static std::string convert( U* p ) {
        -: 1702:        if( !p )
        -: 1703:            return "NULL";
        -: 1704:        else
        -: 1705:            return Detail::rawMemoryToString( p );
        -: 1706:    }
        -: 1707:};
        -: 1708:
        -: 1709:template<typename R, typename C>
        -: 1710:struct StringMaker<R C::*> {
        -: 1711:    static std::string convert( R C::* p ) {
        -: 1712:        if( !p )
        -: 1713:            return "NULL";
        -: 1714:        else
        -: 1715:            return Detail::rawMemoryToString( p );
        -: 1716:    }
        -: 1717:};
        -: 1718:
        -: 1719:namespace Detail {
        -: 1720:    template<typename InputIterator>
        -: 1721:    std::string rangeToString( InputIterator first, InputIterator last );
        -: 1722:}
        -: 1723:
        -: 1724://template<typename T, typename Allocator>
        -: 1725://struct StringMaker<std::vector<T, Allocator> > {
        -: 1726://    static std::string convert( std::vector<T,Allocator> const& v ) {
        -: 1727://        return Detail::rangeToString( v.begin(), v.end() );
        -: 1728://    }
        -: 1729://};
        -: 1730:
        -: 1731:template<typename T, typename Allocator>
        -: 1732:std::string toString( std::vector<T,Allocator> const& v ) {
        -: 1733:    return Detail::rangeToString( v.begin(), v.end() );
        -: 1734:}
        -: 1735:
        -: 1736:#ifdef CATCH_CONFIG_CPP11_TUPLE
        -: 1737:
        -: 1738:// toString for tuples
        -: 1739:namespace TupleDetail {
        -: 1740:  template<
        -: 1741:      typename Tuple,
        -: 1742:      std::size_t N = 0,
        -: 1743:      bool = (N < std::tuple_size<Tuple>::value)
        -: 1744:      >
        -: 1745:  struct ElementPrinter {
        -: 1746:      static void print( const Tuple& tuple, std::ostream& os )
        -: 1747:      {
        -: 1748:          os << ( N ? ", " : " " )
        -: 1749:             << Catch::toString(std::get<N>(tuple));
        -: 1750:          ElementPrinter<Tuple,N+1>::print(tuple,os);
        -: 1751:      }
        -: 1752:  };
        -: 1753:
        -: 1754:  template<
        -: 1755:      typename Tuple,
        -: 1756:      std::size_t N
        -: 1757:      >
        -: 1758:  struct ElementPrinter<Tuple,N,false> {
        -: 1759:      static void print( const Tuple&, std::ostream& ) {}
        -: 1760:  };
        -: 1761:
        -: 1762:}
        -: 1763:
        -: 1764:template<typename ...Types>
        -: 1765:struct StringMaker<std::tuple<Types...>> {
        -: 1766:
        -: 1767:    static std::string convert( const std::tuple<Types...>& tuple )
        -: 1768:    {
        -: 1769:        std::ostringstream os;
        -: 1770:        os << '{';
        -: 1771:        TupleDetail::ElementPrinter<std::tuple<Types...>>::print( tuple, os );
        -: 1772:        os << " }";
        -: 1773:        return os.str();
        -: 1774:    }
        -: 1775:};
        -: 1776:#endif // CATCH_CONFIG_CPP11_TUPLE
        -: 1777:
        -: 1778:namespace Detail {
        -: 1779:    template<typename T>
        -: 1780:    std::string makeString( T const& value ) {
        -: 1781:        return StringMaker<T>::convert( value );
        -: 1782:    }
        -: 1783:} // end namespace Detail
        -: 1784:
        -: 1785:/// \brief converts any type to a string
        -: 1786:///
        -: 1787:/// The default template forwards on to ostringstream - except when an
        -: 1788:/// ostringstream overload does not exist - in which case it attempts to detect
        -: 1789:/// that and writes {?}.
        -: 1790:/// Overload (not specialise) this template for custom typs that you don't want
        -: 1791:/// to provide an ostream overload for.
        -: 1792:template<typename T>
        -: 1793:std::string toString( T const& value ) {
        -: 1794:    return StringMaker<T>::convert( value );
        -: 1795:}
        -: 1796:
        -: 1797:    namespace Detail {
        -: 1798:    template<typename InputIterator>
        -: 1799:    std::string rangeToString( InputIterator first, InputIterator last ) {
        -: 1800:        std::ostringstream oss;
        -: 1801:        oss << "{ ";
        -: 1802:        if( first != last ) {
        -: 1803:            oss << Catch::toString( *first );
        -: 1804:            for( ++first ; first != last ; ++first )
        -: 1805:                oss << ", " << Catch::toString( *first );
        -: 1806:        }
        -: 1807:        oss << " }";
        -: 1808:        return oss.str();
        -: 1809:    }
        -: 1810:}
        -: 1811:
        -: 1812:} // end namespace Catch
        -: 1813:
        -: 1814:namespace Catch {
        -: 1815:
        -: 1816:template<typename LhsT, Internal::Operator Op, typename RhsT>
        -: 1817:class BinaryExpression;
        -: 1818:
        -: 1819:template<typename ArgT, typename MatcherT>
        -: 1820:class MatchExpression;
        -: 1821:
        -: 1822:// Wraps the LHS of an expression and overloads comparison operators
        -: 1823:// for also capturing those and RHS (if any)
        -: 1824:template<typename T>
        -: 1825:class ExpressionLhs : public DecomposedExpression {
        -: 1826:public:
        6: 1827:    ExpressionLhs( ResultBuilder& rb, T lhs ) : m_rb( rb ), m_lhs( lhs ), m_truthy(false) {}
        -: 1828:
        -: 1829:    ExpressionLhs& operator = ( const ExpressionLhs& );
        -: 1830:
        -: 1831:    template<typename RhsT>
        -: 1832:    BinaryExpression<T, Internal::IsEqualTo, RhsT const&>
        6: 1833:    operator == ( RhsT const& rhs ) {
        6: 1834:        return captureExpression<Internal::IsEqualTo>( rhs );
        -: 1835:    }
        -: 1836:
        -: 1837:    template<typename RhsT>
        -: 1838:    BinaryExpression<T, Internal::IsNotEqualTo, RhsT const&>
        -: 1839:    operator != ( RhsT const& rhs ) {
        -: 1840:        return captureExpression<Internal::IsNotEqualTo>( rhs );
        -: 1841:    }
        -: 1842:
        -: 1843:    template<typename RhsT>
        -: 1844:    BinaryExpression<T, Internal::IsLessThan, RhsT const&>
        -: 1845:    operator < ( RhsT const& rhs ) {
        -: 1846:        return captureExpression<Internal::IsLessThan>( rhs );
        -: 1847:    }
        -: 1848:
        -: 1849:    template<typename RhsT>
        -: 1850:    BinaryExpression<T, Internal::IsGreaterThan, RhsT const&>
        -: 1851:    operator > ( RhsT const& rhs ) {
        -: 1852:        return captureExpression<Internal::IsGreaterThan>( rhs );
        -: 1853:    }
        -: 1854:
        -: 1855:    template<typename RhsT>
        -: 1856:    BinaryExpression<T, Internal::IsLessThanOrEqualTo, RhsT const&>
        -: 1857:    operator <= ( RhsT const& rhs ) {
        -: 1858:        return captureExpression<Internal::IsLessThanOrEqualTo>( rhs );
        -: 1859:    }
        -: 1860:
        -: 1861:    template<typename RhsT>
        -: 1862:    BinaryExpression<T, Internal::IsGreaterThanOrEqualTo, RhsT const&>
        -: 1863:    operator >= ( RhsT const& rhs ) {
        -: 1864:        return captureExpression<Internal::IsGreaterThanOrEqualTo>( rhs );
        -: 1865:    }
        -: 1866:
        -: 1867:    BinaryExpression<T, Internal::IsEqualTo, bool> operator == ( bool rhs ) {
        -: 1868:        return captureExpression<Internal::IsEqualTo>( rhs );
        -: 1869:    }
        -: 1870:
        -: 1871:    BinaryExpression<T, Internal::IsNotEqualTo, bool> operator != ( bool rhs ) {
        -: 1872:        return captureExpression<Internal::IsNotEqualTo>( rhs );
        -: 1873:    }
        -: 1874:
        -: 1875:    void endExpression() {
        -: 1876:        m_truthy = m_lhs ? true : false;
        -: 1877:        m_rb
        -: 1878:            .setResultType( m_truthy )
        -: 1879:            .endExpression( *this );
        -: 1880:    }
        -: 1881:
    #####: 1882:    virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE {
    #####: 1883:        dest = Catch::toString( m_lhs );
    #####: 1884:    }
        -: 1885:
        -: 1886:private:
        -: 1887:    template<Internal::Operator Op, typename RhsT>
        6: 1888:    BinaryExpression<T, Op, RhsT&> captureExpression( RhsT& rhs ) const {
        6: 1889:        return BinaryExpression<T, Op, RhsT&>( m_rb, m_lhs, rhs );
        -: 1890:    }
        -: 1891:
        -: 1892:    template<Internal::Operator Op>
        -: 1893:    BinaryExpression<T, Op, bool> captureExpression( bool rhs ) const {
        -: 1894:        return BinaryExpression<T, Op, bool>( m_rb, m_lhs, rhs );
        -: 1895:    }
        -: 1896:
        -: 1897:private:
        -: 1898:    ResultBuilder& m_rb;
        -: 1899:    T m_lhs;
        -: 1900:    bool m_truthy;
        -: 1901:};
        -: 1902:
        -: 1903:template<typename LhsT, Internal::Operator Op, typename RhsT>
        -: 1904:class BinaryExpression : public DecomposedExpression {
        -: 1905:public:
        6: 1906:    BinaryExpression( ResultBuilder& rb, LhsT lhs, RhsT rhs )
        6: 1907:        : m_rb( rb ), m_lhs( lhs ), m_rhs( rhs ) {}
        -: 1908:
        -: 1909:    BinaryExpression& operator = ( BinaryExpression& );
        -: 1910:
        6: 1911:    void endExpression() const {
        6: 1912:        m_rb
        6: 1913:            .setResultType( Internal::compare<Op>( m_lhs, m_rhs ) )
        6: 1914:            .endExpression( *this );
        6: 1915:    }
        -: 1916:
    #####: 1917:    virtual bool isBinaryExpression() const CATCH_OVERRIDE {
    #####: 1918:        return true;
        -: 1919:    }
        -: 1920:
    #####: 1921:    virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE {
    #####: 1922:        std::string lhs = Catch::toString( m_lhs );
    #####: 1923:        std::string rhs = Catch::toString( m_rhs );
    #####: 1924:        char delim = lhs.size() + rhs.size() < 40 &&
    #####: 1925:                     lhs.find('\n') == std::string::npos &&
    #####: 1926:                     rhs.find('\n') == std::string::npos ? ' ' : '\n';
    #####: 1927:        dest.reserve( 7 + lhs.size() + rhs.size() );
        -: 1928:                   // 2 for spaces around operator
        -: 1929:                   // 2 for operator
        -: 1930:                   // 2 for parentheses (conditionally added later)
        -: 1931:                   // 1 for negation (conditionally added later)
    #####: 1932:        dest = lhs;
    #####: 1933:        dest += delim;
    #####: 1934:        dest += Internal::OperatorTraits<Op>::getName();
    #####: 1935:        dest += delim;
    #####: 1936:        dest += rhs;
    #####: 1937:    }
        -: 1938:
        -: 1939:private:
        -: 1940:    ResultBuilder& m_rb;
        -: 1941:    LhsT m_lhs;
        -: 1942:    RhsT m_rhs;
        -: 1943:};
        -: 1944:
        -: 1945:template<typename ArgT, typename MatcherT>
        -: 1946:class MatchExpression : public DecomposedExpression {
        -: 1947:public:
        -: 1948:    MatchExpression( ArgT arg, MatcherT matcher, char const* matcherString )
        -: 1949:        : m_arg( arg ), m_matcher( matcher ), m_matcherString( matcherString ) {}
        -: 1950:
        -: 1951:    virtual bool isBinaryExpression() const CATCH_OVERRIDE {
        -: 1952:        return true;
        -: 1953:    }
        -: 1954:
        -: 1955:    virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE {
        -: 1956:        std::string matcherAsString = m_matcher.toString();
        -: 1957:        dest = Catch::toString( m_arg );
        -: 1958:        dest += ' ';
        -: 1959:        if( matcherAsString == Detail::unprintableString )
        -: 1960:            dest += m_matcherString;
        -: 1961:        else
        -: 1962:            dest += matcherAsString;
        -: 1963:    }
        -: 1964:
        -: 1965:private:
        -: 1966:    ArgT m_arg;
        -: 1967:    MatcherT m_matcher;
        -: 1968:    char const* m_matcherString;
        -: 1969:};
        -: 1970:
        -: 1971:} // end namespace Catch
        -: 1972:
        -: 1973:
        -: 1974:namespace Catch {
        -: 1975:
        -: 1976:    template<typename T>
        6: 1977:    ExpressionLhs<T const&> ResultBuilder::operator <= ( T const& operand ) {
        6: 1978:        return ExpressionLhs<T const&>( *this, operand );
        -: 1979:    }
        -: 1980:
        -: 1981:    inline ExpressionLhs<bool> ResultBuilder::operator <= ( bool value ) {
        -: 1982:        return ExpressionLhs<bool>( *this, value );
        -: 1983:    }
        -: 1984:
        -: 1985:    template<typename ArgT, typename MatcherT>
        -: 1986:    void ResultBuilder::captureMatch( ArgT const& arg, MatcherT const& matcher,
        -: 1987:                                             char const* matcherString ) {
        -: 1988:        MatchExpression<ArgT const&, MatcherT const&> expr( arg, matcher, matcherString );
        -: 1989:        setResultType( matcher.match( arg ) );
        -: 1990:        endExpression( expr );
        -: 1991:    }
        -: 1992:
        -: 1993:} // namespace Catch
        -: 1994:
        -: 1995:// #included from: catch_message.h
        -: 1996:#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED
        -: 1997:
        -: 1998:#include <string>
        -: 1999:
        -: 2000:namespace Catch {
        -: 2001:
        -: 2002:    struct MessageInfo {
        -: 2003:        MessageInfo(    std::string const& _macroName,
        -: 2004:                        SourceLineInfo const& _lineInfo,
        -: 2005:                        ResultWas::OfType _type );
        -: 2006:
        -: 2007:        std::string macroName;
        -: 2008:        SourceLineInfo lineInfo;
        -: 2009:        ResultWas::OfType type;
        -: 2010:        std::string message;
        -: 2011:        unsigned int sequence;
        -: 2012:
    #####: 2013:        bool operator == ( MessageInfo const& other ) const {
    #####: 2014:            return sequence == other.sequence;
        -: 2015:        }
        -: 2016:        bool operator < ( MessageInfo const& other ) const {
        -: 2017:            return sequence < other.sequence;
        -: 2018:        }
        -: 2019:    private:
        -: 2020:        static unsigned int globalCount;
        -: 2021:    };
        -: 2022:
        -: 2023:    struct MessageBuilder {
    #####: 2024:        MessageBuilder( std::string const& macroName,
        -: 2025:                        SourceLineInfo const& lineInfo,
        -: 2026:                        ResultWas::OfType type )
    #####: 2027:        : m_info( macroName, lineInfo, type )
    #####: 2028:        {}
        -: 2029:
        -: 2030:        template<typename T>
    #####: 2031:        MessageBuilder& operator << ( T const& value ) {
    #####: 2032:            m_stream << value;
    #####: 2033:            return *this;
        -: 2034:        }
        -: 2035:
        -: 2036:        MessageInfo m_info;
        -: 2037:        std::ostringstream m_stream;
        -: 2038:    };
        -: 2039:
        -: 2040:    class ScopedMessage {
        -: 2041:    public:
        -: 2042:        ScopedMessage( MessageBuilder const& builder );
        -: 2043:        ScopedMessage( ScopedMessage const& other );
        -: 2044:        ~ScopedMessage();
        -: 2045:
        -: 2046:        MessageInfo m_info;
        -: 2047:    };
        -: 2048:
        -: 2049:} // end namespace Catch
        -: 2050:
        -: 2051:// #included from: catch_interfaces_capture.h
        -: 2052:#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED
        -: 2053:
        -: 2054:#include <string>
        -: 2055:
        -: 2056:namespace Catch {
        -: 2057:
        -: 2058:    class TestCase;
        -: 2059:    class AssertionResult;
        -: 2060:    struct AssertionInfo;
        -: 2061:    struct SectionInfo;
        -: 2062:    struct SectionEndInfo;
        -: 2063:    struct MessageInfo;
        -: 2064:    class ScopedMessageBuilder;
        -: 2065:    struct Counts;
        -: 2066:
        -: 2067:    struct IResultCapture {
        -: 2068:
        -: 2069:        virtual ~IResultCapture();
        -: 2070:
        -: 2071:        virtual void assertionEnded( AssertionResult const& result ) = 0;
        -: 2072:        virtual bool sectionStarted(    SectionInfo const& sectionInfo,
        -: 2073:                                        Counts& assertions ) = 0;
        -: 2074:        virtual void sectionEnded( SectionEndInfo const& endInfo ) = 0;
        -: 2075:        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) = 0;
        -: 2076:        virtual void pushScopedMessage( MessageInfo const& message ) = 0;
        -: 2077:        virtual void popScopedMessage( MessageInfo const& message ) = 0;
        -: 2078:
        -: 2079:        virtual std::string getCurrentTestName() const = 0;
        -: 2080:        virtual const AssertionResult* getLastResult() const = 0;
        -: 2081:
        -: 2082:        virtual void exceptionEarlyReported() = 0;
        -: 2083:
        -: 2084:        virtual void handleFatalErrorCondition( std::string const& message ) = 0;
        -: 2085:
        -: 2086:        virtual bool lastAssertionPassed() = 0;
        -: 2087:        virtual void assertionPassed() = 0;
        -: 2088:        virtual void assertionRun() = 0;
        -: 2089:    };
        -: 2090:
        -: 2091:    IResultCapture& getResultCapture();
        -: 2092:}
        -: 2093:
        -: 2094:// #included from: catch_debugger.h
        -: 2095:#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED
        -: 2096:
        -: 2097:// #included from: catch_platform.h
        -: 2098:#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED
        -: 2099:
        -: 2100:#if defined(__MAC_OS_X_VERSION_MIN_REQUIRED)
        -: 2101:#  define CATCH_PLATFORM_MAC
        -: 2102:#elif  defined(__IPHONE_OS_VERSION_MIN_REQUIRED)
        -: 2103:#  define CATCH_PLATFORM_IPHONE
        -: 2104:#elif defined(linux) || defined(__linux) || defined(__linux__)
        -: 2105:#  define CATCH_PLATFORM_LINUX
        -: 2106:#elif defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
        -: 2107:#  define CATCH_PLATFORM_WINDOWS
        -: 2108:#  if !defined(NOMINMAX) && !defined(CATCH_CONFIG_NO_NOMINMAX)
        -: 2109:#    define CATCH_DEFINES_NOMINMAX
        -: 2110:#  endif
        -: 2111:#  if !defined(WIN32_LEAN_AND_MEAN) && !defined(CATCH_CONFIG_NO_WIN32_LEAN_AND_MEAN)
        -: 2112:#    define CATCH_DEFINES_WIN32_LEAN_AND_MEAN
        -: 2113:#  endif
        -: 2114:#endif
        -: 2115:
        -: 2116:#include <string>
        -: 2117:
        -: 2118:namespace Catch{
        -: 2119:
        -: 2120:    bool isDebuggerActive();
        -: 2121:    void writeToDebugConsole( std::string const& text );
        -: 2122:}
        -: 2123:
        -: 2124:#ifdef CATCH_PLATFORM_MAC
        -: 2125:
        -: 2126:    // The following code snippet based on:
        -: 2127:    // http://cocoawithlove.com/2008/03/break-into-debugger.html
        -: 2128:    #if defined(__ppc64__) || defined(__ppc__)
        -: 2129:        #define CATCH_TRAP() \
        -: 2130:                __asm__("li r0, 20\nsc\nnop\nli r0, 37\nli r4, 2\nsc\nnop\n" \
        -: 2131:                : : : "memory","r0","r3","r4" ) /* NOLINT */
        -: 2132:    #else
        -: 2133:        #define CATCH_TRAP() __asm__("int $3\n" : : /* NOLINT */ )
        -: 2134:    #endif
        -: 2135:
        -: 2136:#elif defined(CATCH_PLATFORM_LINUX)
        -: 2137:    // If we can use inline assembler, do it because this allows us to break
        -: 2138:    // directly at the location of the failing check instead of breaking inside
        -: 2139:    // raise() called from it, i.e. one stack frame below.
        -: 2140:    #if defined(__GNUC__) && (defined(__i386) || defined(__x86_64))
        -: 2141:        #define CATCH_TRAP() asm volatile ("int $3") /* NOLINT */
        -: 2142:    #else // Fall back to the generic way.
        -: 2143:        #include <signal.h>
        -: 2144:
        -: 2145:        #define CATCH_TRAP() raise(SIGTRAP)
        -: 2146:    #endif
        -: 2147:#elif defined(_MSC_VER)
        -: 2148:    #define CATCH_TRAP() __debugbreak()
        -: 2149:#elif defined(__MINGW32__)
        -: 2150:    extern "C" __declspec(dllimport) void __stdcall DebugBreak();
        -: 2151:    #define CATCH_TRAP() DebugBreak()
        -: 2152:#endif
        -: 2153:
        -: 2154:#ifdef CATCH_TRAP
        -: 2155:    #define CATCH_BREAK_INTO_DEBUGGER() if( Catch::isDebuggerActive() ) { CATCH_TRAP(); }
        -: 2156:#else
        -: 2157:    #define CATCH_BREAK_INTO_DEBUGGER() Catch::alwaysTrue();
        -: 2158:#endif
        -: 2159:
        -: 2160:// #included from: catch_interfaces_runner.h
        -: 2161:#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED
        -: 2162:
        -: 2163:namespace Catch {
        -: 2164:    class TestCase;
        -: 2165:
        -: 2166:    struct IRunner {
        -: 2167:        virtual ~IRunner();
        -: 2168:        virtual bool aborting() const = 0;
        -: 2169:    };
        -: 2170:}
        -: 2171:
        -: 2172:#if !defined(CATCH_CONFIG_DISABLE_STRINGIFICATION)
        -: 2173:# define CATCH_INTERNAL_STRINGIFY(expr) #expr
        -: 2174:#else
        -: 2175:# define CATCH_INTERNAL_STRINGIFY(expr) "Disabled by CATCH_CONFIG_DISABLE_STRINGIFICATION"
        -: 2176:#endif
        -: 2177:
        -: 2178:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -: 2179:///////////////////////////////////////////////////////////////////////////////
        -: 2180:// We can speedup compilation significantly by breaking into debugger lower in
        -: 2181:// the callstack, because then we don't have to expand CATCH_BREAK_INTO_DEBUGGER
        -: 2182:// macro in each assertion
        -: 2183:#define INTERNAL_CATCH_REACT( resultBuilder ) \
        -: 2184:    resultBuilder.react();
        -: 2185:
        -: 2186:///////////////////////////////////////////////////////////////////////////////
        -: 2187:// Another way to speed-up compilation is to omit local try-catch for REQUIRE*
        -: 2188:// macros.
        -: 2189:// This can potentially cause false negative, if the test code catches
        -: 2190:// the exception before it propagates back up to the runner.
        -: 2191:#define INTERNAL_CATCH_TEST_NO_TRY( macroName, resultDisposition, expr ) \
        -: 2192:    do { \
        -: 2193:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr), resultDisposition ); \
        -: 2194:        __catchResult.setExceptionGuard(); \
        -: 2195:        CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -: 2196:        ( __catchResult <= expr ).endExpression(); \
        -: 2197:        CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
        -: 2198:        __catchResult.unsetExceptionGuard(); \
        -: 2199:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2200:    } while( Catch::isTrue( false && static_cast<bool>( !!(expr) ) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look
        -: 2201:// The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.
        -: 2202:
        -: 2203:#define INTERNAL_CHECK_THAT_NO_TRY( macroName, matcher, resultDisposition, arg ) \
        -: 2204:    do { \
        -: 2205:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 2206:        __catchResult.setExceptionGuard(); \
        -: 2207:        __catchResult.captureMatch( arg, matcher, CATCH_INTERNAL_STRINGIFY(matcher) ); \
        -: 2208:        __catchResult.unsetExceptionGuard(); \
        -: 2209:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2210:    } while( Catch::alwaysFalse() )
        -: 2211:
        -: 2212:#else
        -: 2213:///////////////////////////////////////////////////////////////////////////////
        -: 2214:// In the event of a failure works out if the debugger needs to be invoked
        -: 2215:// and/or an exception thrown and takes appropriate action.
        -: 2216:// This needs to be done as a macro so the debugger will stop in the user
        -: 2217:// source code rather than in Catch library code
        -: 2218:#define INTERNAL_CATCH_REACT( resultBuilder ) \
        -: 2219:    if( resultBuilder.shouldDebugBreak() ) CATCH_BREAK_INTO_DEBUGGER(); \
        -: 2220:    resultBuilder.react();
        -: 2221:#endif
        -: 2222:
        -: 2223:///////////////////////////////////////////////////////////////////////////////
        -: 2224:#define INTERNAL_CATCH_TEST( macroName, resultDisposition, expr ) \
        -: 2225:    do { \
        -: 2226:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr), resultDisposition ); \
        -: 2227:        try { \
        -: 2228:            CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS \
        -: 2229:            ( __catchResult <= expr ).endExpression(); \
        -: 2230:            CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS \
        -: 2231:        } \
        -: 2232:        catch( ... ) { \
        -: 2233:            __catchResult.useActiveException( resultDisposition ); \
        -: 2234:        } \
        -: 2235:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2236:    } while( Catch::isTrue( false && static_cast<bool>( !!(expr) ) ) ) // expr here is never evaluated at runtime but it forces the compiler to give it a look
        -: 2237:    // The double negation silences MSVC's C4800 warning, the static_cast forces short-circuit evaluation if the type has overloaded &&.
        -: 2238:
        -: 2239:///////////////////////////////////////////////////////////////////////////////
        -: 2240:#define INTERNAL_CATCH_IF( macroName, resultDisposition, expr ) \
        -: 2241:    INTERNAL_CATCH_TEST( macroName, resultDisposition, expr ); \
        -: 2242:    if( Catch::getResultCapture().lastAssertionPassed() )
        -: 2243:
        -: 2244:///////////////////////////////////////////////////////////////////////////////
        -: 2245:#define INTERNAL_CATCH_ELSE( macroName, resultDisposition, expr ) \
        -: 2246:    INTERNAL_CATCH_TEST( macroName, resultDisposition, expr ); \
        -: 2247:    if( !Catch::getResultCapture().lastAssertionPassed() )
        -: 2248:
        -: 2249:///////////////////////////////////////////////////////////////////////////////
        -: 2250:#define INTERNAL_CATCH_NO_THROW( macroName, resultDisposition, expr ) \
        -: 2251:    do { \
        -: 2252:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr), resultDisposition ); \
        -: 2253:        try { \
        -: 2254:            static_cast<void>(expr); \
        -: 2255:            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2256:        } \
        -: 2257:        catch( ... ) { \
        -: 2258:            __catchResult.useActiveException( resultDisposition ); \
        -: 2259:        } \
        -: 2260:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2261:    } while( Catch::alwaysFalse() )
        -: 2262:
        -: 2263:///////////////////////////////////////////////////////////////////////////////
        -: 2264:#define INTERNAL_CATCH_THROWS( macroName, resultDisposition, matcher, expr ) \
        -: 2265:    do { \
        -: 2266:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr), resultDisposition, CATCH_INTERNAL_STRINGIFY(matcher) ); \
        -: 2267:        if( __catchResult.allowThrows() ) \
        -: 2268:            try { \
        -: 2269:                static_cast<void>(expr); \
        -: 2270:                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
        -: 2271:            } \
        -: 2272:            catch( ... ) { \
        -: 2273:                __catchResult.captureExpectedException( matcher ); \
        -: 2274:            } \
        -: 2275:        else \
        -: 2276:            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2277:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2278:    } while( Catch::alwaysFalse() )
        -: 2279:
        -: 2280:///////////////////////////////////////////////////////////////////////////////
        -: 2281:#define INTERNAL_CATCH_THROWS_AS( macroName, exceptionType, resultDisposition, expr ) \
        -: 2282:    do { \
        -: 2283:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(expr) ", " CATCH_INTERNAL_STRINGIFY(exceptionType), resultDisposition ); \
        -: 2284:        if( __catchResult.allowThrows() ) \
        -: 2285:            try { \
        -: 2286:                static_cast<void>(expr); \
        -: 2287:                __catchResult.captureResult( Catch::ResultWas::DidntThrowException ); \
        -: 2288:            } \
        -: 2289:            catch( exceptionType ) { \
        -: 2290:                __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2291:            } \
        -: 2292:            catch( ... ) { \
        -: 2293:                __catchResult.useActiveException( resultDisposition ); \
        -: 2294:            } \
        -: 2295:        else \
        -: 2296:            __catchResult.captureResult( Catch::ResultWas::Ok ); \
        -: 2297:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2298:    } while( Catch::alwaysFalse() )
        -: 2299:
        -: 2300:///////////////////////////////////////////////////////////////////////////////
        -: 2301:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -: 2302:    #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, ... ) \
        -: 2303:        do { \
        -: 2304:            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
        -: 2305:            __catchResult << __VA_ARGS__ + ::Catch::StreamEndStop(); \
        -: 2306:            __catchResult.captureResult( messageType ); \
        -: 2307:            INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2308:        } while( Catch::alwaysFalse() )
        -: 2309:#else
        -: 2310:    #define INTERNAL_CATCH_MSG( macroName, messageType, resultDisposition, log ) \
        -: 2311:        do { \
        -: 2312:            Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, "", resultDisposition ); \
        -: 2313:            __catchResult << log + ::Catch::StreamEndStop(); \
        -: 2314:            __catchResult.captureResult( messageType ); \
        -: 2315:            INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2316:        } while( Catch::alwaysFalse() )
        -: 2317:#endif
        -: 2318:
        -: 2319:///////////////////////////////////////////////////////////////////////////////
        -: 2320:#define INTERNAL_CATCH_INFO( macroName, log ) \
        -: 2321:    Catch::ScopedMessage INTERNAL_CATCH_UNIQUE_NAME( scopedMessage ) = Catch::MessageBuilder( macroName, CATCH_INTERNAL_LINEINFO, Catch::ResultWas::Info ) << log;
        -: 2322:
        -: 2323:///////////////////////////////////////////////////////////////////////////////
        -: 2324:#define INTERNAL_CHECK_THAT( macroName, matcher, resultDisposition, arg ) \
        -: 2325:    do { \
        -: 2326:        Catch::ResultBuilder __catchResult( macroName, CATCH_INTERNAL_LINEINFO, CATCH_INTERNAL_STRINGIFY(arg) ", " CATCH_INTERNAL_STRINGIFY(matcher), resultDisposition ); \
        -: 2327:        try { \
        -: 2328:            __catchResult.captureMatch( arg, matcher, CATCH_INTERNAL_STRINGIFY(matcher) ); \
        -: 2329:        } catch( ... ) { \
        -: 2330:            __catchResult.useActiveException( resultDisposition | Catch::ResultDisposition::ContinueOnFailure ); \
        -: 2331:        } \
        -: 2332:        INTERNAL_CATCH_REACT( __catchResult ) \
        -: 2333:    } while( Catch::alwaysFalse() )
        -: 2334:
        -: 2335:// #included from: internal/catch_section.h
        -: 2336:#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED
        -: 2337:
        -: 2338:// #included from: catch_section_info.h
        -: 2339:#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED
        -: 2340:
        -: 2341:// #included from: catch_totals.hpp
        -: 2342:#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED
        -: 2343:
        -: 2344:#include <cstddef>
        -: 2345:
        -: 2346:namespace Catch {
        -: 2347:
        -: 2348:    struct Counts {
       56: 2349:        Counts() : passed( 0 ), failed( 0 ), failedButOk( 0 ) {}
        -: 2350:
       14: 2351:        Counts operator - ( Counts const& other ) const {
       14: 2352:            Counts diff;
       14: 2353:            diff.passed = passed - other.passed;
       14: 2354:            diff.failed = failed - other.failed;
       14: 2355:            diff.failedButOk = failedButOk - other.failedButOk;
       14: 2356:            return diff;
        -: 2357:        }
        3: 2358:        Counts& operator += ( Counts const& other ) {
        3: 2359:            passed += other.passed;
        3: 2360:            failed += other.failed;
        3: 2361:            failedButOk += other.failedButOk;
        3: 2362:            return *this;
        -: 2363:        }
        -: 2364:
       18: 2365:        std::size_t total() const {
       18: 2366:            return passed + failed + failedButOk;
        -: 2367:        }
        2: 2368:        bool allPassed() const {
       2*: 2369:            return failed == 0 && failedButOk == 0;
        -: 2370:        }
    #####: 2371:        bool allOk() const {
    #####: 2372:            return failed == 0;
        -: 2373:        }
        -: 2374:
        -: 2375:        std::size_t passed;
        -: 2376:        std::size_t failed;
        -: 2377:        std::size_t failedButOk;
        -: 2378:    };
        -: 2379:
        -: 2380:    struct Totals {
        -: 2381:
        1: 2382:        Totals operator - ( Totals const& other ) const {
        1: 2383:            Totals diff;
        1: 2384:            diff.assertions = assertions - other.assertions;
        1: 2385:            diff.testCases = testCases - other.testCases;
        1: 2386:            return diff;
        -: 2387:        }
        -: 2388:
        1: 2389:        Totals delta( Totals const& prevTotals ) const {
        1: 2390:            Totals diff = *this - prevTotals;
        1: 2391:            if( diff.assertions.failed > 0 )
    #####: 2392:                ++diff.testCases.failed;
        1: 2393:            else if( diff.assertions.failedButOk > 0 )
    #####: 2394:                ++diff.testCases.failedButOk;
        -: 2395:            else
        1: 2396:                ++diff.testCases.passed;
        1: 2397:            return diff;
        -: 2398:        }
        -: 2399:
        1: 2400:        Totals& operator += ( Totals const& other ) {
        1: 2401:            assertions += other.assertions;
        1: 2402:            testCases += other.testCases;
        1: 2403:            return *this;
        -: 2404:        }
        -: 2405:
        -: 2406:        Counts assertions;
        -: 2407:        Counts testCases;
        -: 2408:    };
        -: 2409:}
        -: 2410:
        -: 2411:#include <string>
        -: 2412:
        -: 2413:namespace Catch {
        -: 2414:
        -: 2415:    struct SectionInfo {
        -: 2416:        SectionInfo
        -: 2417:            (   SourceLineInfo const& _lineInfo,
        -: 2418:                std::string const& _name,
        -: 2419:                std::string const& _description = std::string() );
        -: 2420:
        -: 2421:        std::string name;
        -: 2422:        std::string description;
        -: 2423:        SourceLineInfo lineInfo;
        -: 2424:    };
        -: 2425:
        -: 2426:    struct SectionEndInfo {
        6: 2427:        SectionEndInfo( SectionInfo const& _sectionInfo, Counts const& _prevAssertions, double _durationInSeconds )
        6: 2428:        : sectionInfo( _sectionInfo ), prevAssertions( _prevAssertions ), durationInSeconds( _durationInSeconds )
        6: 2429:        {}
        -: 2430:
        -: 2431:        SectionInfo sectionInfo;
        -: 2432:        Counts prevAssertions;
        -: 2433:        double durationInSeconds;
        -: 2434:    };
        -: 2435:
        -: 2436:} // end namespace Catch
        -: 2437:
        -: 2438:// #included from: catch_timer.h
        -: 2439:#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED
        -: 2440:
        -: 2441:#ifdef _MSC_VER
        -: 2442:
        -: 2443:namespace Catch {
        -: 2444:    typedef unsigned long long UInt64;
        -: 2445:}
        -: 2446:#else
        -: 2447:#include <stdint.h>
        -: 2448:namespace Catch {
        -: 2449:    typedef uint64_t UInt64;
        -: 2450:}
        -: 2451:#endif
        -: 2452:
        -: 2453:namespace Catch {
        -: 2454:    class Timer {
        -: 2455:    public:
       42: 2456:        Timer() : m_ticks( 0 ) {}
        -: 2457:        void start();
        -: 2458:        unsigned int getElapsedMicroseconds() const;
        -: 2459:        unsigned int getElapsedMilliseconds() const;
        -: 2460:        double getElapsedSeconds() const;
        -: 2461:
        -: 2462:    private:
        -: 2463:        UInt64 m_ticks;
        -: 2464:    };
        -: 2465:
        -: 2466:} // namespace Catch
        -: 2467:
        -: 2468:#include <string>
        -: 2469:
        -: 2470:namespace Catch {
        -: 2471:
        -: 2472:    class Section : NonCopyable {
        -: 2473:    public:
        -: 2474:        Section( SectionInfo const& info );
        -: 2475:        ~Section();
        -: 2476:
        -: 2477:        // This indicates whether the section should be executed or not
        -: 2478:        operator bool() const;
        -: 2479:
        -: 2480:    private:
        -: 2481:        SectionInfo m_info;
        -: 2482:
        -: 2483:        std::string m_name;
        -: 2484:        Counts m_assertions;
        -: 2485:        bool m_sectionIncluded;
        -: 2486:        Timer m_timer;
        -: 2487:    };
        -: 2488:
        -: 2489:} // end namespace Catch
        -: 2490:
        -: 2491:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -: 2492:    #define INTERNAL_CATCH_SECTION( ... ) \
        -: 2493:        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, __VA_ARGS__ ) )
        -: 2494:#else
        -: 2495:    #define INTERNAL_CATCH_SECTION( name, desc ) \
        -: 2496:        if( Catch::Section const& INTERNAL_CATCH_UNIQUE_NAME( catch_internal_Section ) = Catch::SectionInfo( CATCH_INTERNAL_LINEINFO, name, desc ) )
        -: 2497:#endif
        -: 2498:
        -: 2499:// #included from: internal/catch_generators.hpp
        -: 2500:#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED
        -: 2501:
        -: 2502:#include <vector>
        -: 2503:#include <string>
        -: 2504:#include <stdlib.h>
        -: 2505:
        -: 2506:namespace Catch {
        -: 2507:
        -: 2508:template<typename T>
        -: 2509:struct IGenerator {
        -: 2510:    virtual ~IGenerator() {}
        -: 2511:    virtual T getValue( std::size_t index ) const = 0;
        -: 2512:    virtual std::size_t size () const = 0;
        -: 2513:};
        -: 2514:
        -: 2515:template<typename T>
        -: 2516:class BetweenGenerator : public IGenerator<T> {
        -: 2517:public:
        -: 2518:    BetweenGenerator( T from, T to ) : m_from( from ), m_to( to ){}
        -: 2519:
        -: 2520:    virtual T getValue( std::size_t index ) const {
        -: 2521:        return m_from+static_cast<int>( index );
        -: 2522:    }
        -: 2523:
        -: 2524:    virtual std::size_t size() const {
        -: 2525:        return static_cast<std::size_t>( 1+m_to-m_from );
        -: 2526:    }
        -: 2527:
        -: 2528:private:
        -: 2529:
        -: 2530:    T m_from;
        -: 2531:    T m_to;
        -: 2532:};
        -: 2533:
        -: 2534:template<typename T>
        -: 2535:class ValuesGenerator : public IGenerator<T> {
        -: 2536:public:
        -: 2537:    ValuesGenerator(){}
        -: 2538:
        -: 2539:    void add( T value ) {
        -: 2540:        m_values.push_back( value );
        -: 2541:    }
        -: 2542:
        -: 2543:    virtual T getValue( std::size_t index ) const {
        -: 2544:        return m_values[index];
        -: 2545:    }
        -: 2546:
        -: 2547:    virtual std::size_t size() const {
        -: 2548:        return m_values.size();
        -: 2549:    }
        -: 2550:
        -: 2551:private:
        -: 2552:    std::vector<T> m_values;
        -: 2553:};
        -: 2554:
        -: 2555:template<typename T>
        -: 2556:class CompositeGenerator {
        -: 2557:public:
        -: 2558:    CompositeGenerator() : m_totalSize( 0 ) {}
        -: 2559:
        -: 2560:    // *** Move semantics, similar to auto_ptr ***
        -: 2561:    CompositeGenerator( CompositeGenerator& other )
        -: 2562:    :   m_fileInfo( other.m_fileInfo ),
        -: 2563:        m_totalSize( 0 )
        -: 2564:    {
        -: 2565:        move( other );
        -: 2566:    }
        -: 2567:
        -: 2568:    CompositeGenerator& setFileInfo( const char* fileInfo ) {
        -: 2569:        m_fileInfo = fileInfo;
        -: 2570:        return *this;
        -: 2571:    }
        -: 2572:
        -: 2573:    ~CompositeGenerator() {
        -: 2574:        deleteAll( m_composed );
        -: 2575:    }
        -: 2576:
        -: 2577:    operator T () const {
        -: 2578:        size_t overallIndex = getCurrentContext().getGeneratorIndex( m_fileInfo, m_totalSize );
        -: 2579:
        -: 2580:        typename std::vector<const IGenerator<T>*>::const_iterator it = m_composed.begin();
        -: 2581:        typename std::vector<const IGenerator<T>*>::const_iterator itEnd = m_composed.end();
        -: 2582:        for( size_t index = 0; it != itEnd; ++it )
        -: 2583:        {
        -: 2584:            const IGenerator<T>* generator = *it;
        -: 2585:            if( overallIndex >= index && overallIndex < index + generator->size() )
        -: 2586:            {
        -: 2587:                return generator->getValue( overallIndex-index );
        -: 2588:            }
        -: 2589:            index += generator->size();
        -: 2590:        }
        -: 2591:        CATCH_INTERNAL_ERROR( "Indexed past end of generated range" );
        -: 2592:        return T(); // Suppress spurious "not all control paths return a value" warning in Visual Studio - if you know how to fix this please do so
        -: 2593:    }
        -: 2594:
        -: 2595:    void add( const IGenerator<T>* generator ) {
        -: 2596:        m_totalSize += generator->size();
        -: 2597:        m_composed.push_back( generator );
        -: 2598:    }
        -: 2599:
        -: 2600:    CompositeGenerator& then( CompositeGenerator& other ) {
        -: 2601:        move( other );
        -: 2602:        return *this;
        -: 2603:    }
        -: 2604:
        -: 2605:    CompositeGenerator& then( T value ) {
        -: 2606:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2607:        valuesGen->add( value );
        -: 2608:        add( valuesGen );
        -: 2609:        return *this;
        -: 2610:    }
        -: 2611:
        -: 2612:private:
        -: 2613:
        -: 2614:    void move( CompositeGenerator& other ) {
        -: 2615:        m_composed.insert( m_composed.end(), other.m_composed.begin(), other.m_composed.end() );
        -: 2616:        m_totalSize += other.m_totalSize;
        -: 2617:        other.m_composed.clear();
        -: 2618:    }
        -: 2619:
        -: 2620:    std::vector<const IGenerator<T>*> m_composed;
        -: 2621:    std::string m_fileInfo;
        -: 2622:    size_t m_totalSize;
        -: 2623:};
        -: 2624:
        -: 2625:namespace Generators
        -: 2626:{
        -: 2627:    template<typename T>
        -: 2628:    CompositeGenerator<T> between( T from, T to ) {
        -: 2629:        CompositeGenerator<T> generators;
        -: 2630:        generators.add( new BetweenGenerator<T>( from, to ) );
        -: 2631:        return generators;
        -: 2632:    }
        -: 2633:
        -: 2634:    template<typename T>
        -: 2635:    CompositeGenerator<T> values( T val1, T val2 ) {
        -: 2636:        CompositeGenerator<T> generators;
        -: 2637:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2638:        valuesGen->add( val1 );
        -: 2639:        valuesGen->add( val2 );
        -: 2640:        generators.add( valuesGen );
        -: 2641:        return generators;
        -: 2642:    }
        -: 2643:
        -: 2644:    template<typename T>
        -: 2645:    CompositeGenerator<T> values( T val1, T val2, T val3 ){
        -: 2646:        CompositeGenerator<T> generators;
        -: 2647:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2648:        valuesGen->add( val1 );
        -: 2649:        valuesGen->add( val2 );
        -: 2650:        valuesGen->add( val3 );
        -: 2651:        generators.add( valuesGen );
        -: 2652:        return generators;
        -: 2653:    }
        -: 2654:
        -: 2655:    template<typename T>
        -: 2656:    CompositeGenerator<T> values( T val1, T val2, T val3, T val4 ) {
        -: 2657:        CompositeGenerator<T> generators;
        -: 2658:        ValuesGenerator<T>* valuesGen = new ValuesGenerator<T>();
        -: 2659:        valuesGen->add( val1 );
        -: 2660:        valuesGen->add( val2 );
        -: 2661:        valuesGen->add( val3 );
        -: 2662:        valuesGen->add( val4 );
        -: 2663:        generators.add( valuesGen );
        -: 2664:        return generators;
        -: 2665:    }
        -: 2666:
        -: 2667:} // end namespace Generators
        -: 2668:
        -: 2669:using namespace Generators;
        -: 2670:
        -: 2671:} // end namespace Catch
        -: 2672:
        -: 2673:#define INTERNAL_CATCH_LINESTR2( line ) #line
        -: 2674:#define INTERNAL_CATCH_LINESTR( line ) INTERNAL_CATCH_LINESTR2( line )
        -: 2675:
        -: 2676:#define INTERNAL_CATCH_GENERATE( expr ) expr.setFileInfo( __FILE__ "(" INTERNAL_CATCH_LINESTR( __LINE__ ) ")" )
        -: 2677:
        -: 2678:// #included from: internal/catch_interfaces_exception.h
        -: 2679:#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED
        -: 2680:
        -: 2681:#include <string>
        -: 2682:#include <vector>
        -: 2683:
        -: 2684:// #included from: catch_interfaces_registry_hub.h
        -: 2685:#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED
        -: 2686:
        -: 2687:#include <string>
        -: 2688:
        -: 2689:namespace Catch {
        -: 2690:
        -: 2691:    class TestCase;
        -: 2692:    struct ITestCaseRegistry;
        -: 2693:    struct IExceptionTranslatorRegistry;
        -: 2694:    struct IExceptionTranslator;
        -: 2695:    struct IReporterRegistry;
        -: 2696:    struct IReporterFactory;
        -: 2697:    struct ITagAliasRegistry;
        -: 2698:
        -: 2699:    struct IRegistryHub {
        -: 2700:        virtual ~IRegistryHub();
        -: 2701:
        -: 2702:        virtual IReporterRegistry const& getReporterRegistry() const = 0;
        -: 2703:        virtual ITestCaseRegistry const& getTestCaseRegistry() const = 0;
        -: 2704:        virtual ITagAliasRegistry const& getTagAliasRegistry() const = 0;
        -: 2705:
        -: 2706:        virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() = 0;
        -: 2707:    };
        -: 2708:
        -: 2709:    struct IMutableRegistryHub {
        -: 2710:        virtual ~IMutableRegistryHub();
        -: 2711:        virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) = 0;
        -: 2712:        virtual void registerListener( Ptr<IReporterFactory> const& factory ) = 0;
        -: 2713:        virtual void registerTest( TestCase const& testInfo ) = 0;
        -: 2714:        virtual void registerTranslator( const IExceptionTranslator* translator ) = 0;
        -: 2715:        virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) = 0;
        -: 2716:    };
        -: 2717:
        -: 2718:    IRegistryHub& getRegistryHub();
        -: 2719:    IMutableRegistryHub& getMutableRegistryHub();
        -: 2720:    void cleanUp();
        -: 2721:    std::string translateActiveException();
        -: 2722:
        -: 2723:}
        -: 2724:
        -: 2725:namespace Catch {
        -: 2726:
        -: 2727:    typedef std::string(*exceptionTranslateFunction)();
        -: 2728:
        -: 2729:    struct IExceptionTranslator;
        -: 2730:    typedef std::vector<const IExceptionTranslator*> ExceptionTranslators;
        -: 2731:
        -: 2732:    struct IExceptionTranslator {
        -: 2733:        virtual ~IExceptionTranslator();
        -: 2734:        virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const = 0;
        -: 2735:    };
        -: 2736:
        -: 2737:    struct IExceptionTranslatorRegistry {
        -: 2738:        virtual ~IExceptionTranslatorRegistry();
        -: 2739:
        -: 2740:        virtual std::string translateActiveException() const = 0;
        -: 2741:    };
        -: 2742:
        -: 2743:    class ExceptionTranslatorRegistrar {
        -: 2744:        template<typename T>
        -: 2745:        class ExceptionTranslator : public IExceptionTranslator {
        -: 2746:        public:
        -: 2747:
        -: 2748:            ExceptionTranslator( std::string(*translateFunction)( T& ) )
        -: 2749:            : m_translateFunction( translateFunction )
        -: 2750:            {}
        -: 2751:
        -: 2752:            virtual std::string translate( ExceptionTranslators::const_iterator it, ExceptionTranslators::const_iterator itEnd ) const CATCH_OVERRIDE {
        -: 2753:                try {
        -: 2754:                    if( it == itEnd )
        -: 2755:                        throw;
        -: 2756:                    else
        -: 2757:                        return (*it)->translate( it+1, itEnd );
        -: 2758:                }
        -: 2759:                catch( T& ex ) {
        -: 2760:                    return m_translateFunction( ex );
        -: 2761:                }
        -: 2762:            }
        -: 2763:
        -: 2764:        protected:
        -: 2765:            std::string(*m_translateFunction)( T& );
        -: 2766:        };
        -: 2767:
        -: 2768:    public:
        -: 2769:        template<typename T>
        -: 2770:        ExceptionTranslatorRegistrar( std::string(*translateFunction)( T& ) ) {
        -: 2771:            getMutableRegistryHub().registerTranslator
        -: 2772:                ( new ExceptionTranslator<T>( translateFunction ) );
        -: 2773:        }
        -: 2774:    };
        -: 2775:}
        -: 2776:
        -: 2777:///////////////////////////////////////////////////////////////////////////////
        -: 2778:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2( translatorName, signature ) \
        -: 2779:    static std::string translatorName( signature ); \
        -: 2780:    namespace{ Catch::ExceptionTranslatorRegistrar INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionRegistrar )( &translatorName ); }\
        -: 2781:    static std::string translatorName( signature )
        -: 2782:
        -: 2783:#define INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION2( INTERNAL_CATCH_UNIQUE_NAME( catch_internal_ExceptionTranslator ), signature )
        -: 2784:
        -: 2785:// #included from: internal/catch_approx.hpp
        -: 2786:#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED
        -: 2787:
        -: 2788:#include <cmath>
        -: 2789:#include <limits>
        -: 2790:
        -: 2791:#if defined(CATCH_CONFIG_CPP11_TYPE_TRAITS)
        -: 2792:#include <type_traits>
        -: 2793:#endif
        -: 2794:
        -: 2795:namespace Catch {
        -: 2796:namespace Detail {
        -: 2797:
        -: 2798:    class Approx {
        -: 2799:    public:
        -: 2800:        explicit Approx ( double value )
        -: 2801:        :   m_epsilon( std::numeric_limits<float>::epsilon()*100 ),
        -: 2802:            m_margin( 0.0 ),
        -: 2803:            m_scale( 1.0 ),
        -: 2804:            m_value( value )
        -: 2805:        {}
        -: 2806:
        -: 2807:        static Approx custom() {
        -: 2808:            return Approx( 0 );
        -: 2809:        }
        -: 2810:
        -: 2811:#if defined(CATCH_CONFIG_CPP11_TYPE_TRAITS)
        -: 2812:
        -: 2813:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2814:        Approx operator()( T value ) {
        -: 2815:            Approx approx( static_cast<double>(value) );
        -: 2816:            approx.epsilon( m_epsilon );
        -: 2817:            approx.margin( m_margin );
        -: 2818:            approx.scale( m_scale );
        -: 2819:            return approx;
        -: 2820:        }
        -: 2821:
        -: 2822:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2823:        explicit Approx( T value ): Approx(static_cast<double>(value))
        -: 2824:        {}
        -: 2825:
        -: 2826:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2827:        friend bool operator == ( const T& lhs, Approx const& rhs ) {
        -: 2828:            // Thanks to Richard Harris for his help refining this formula
        -: 2829:            auto lhs_v = double(lhs);
        -: 2830:            bool relativeOK = std::fabs(lhs_v - rhs.m_value) < rhs.m_epsilon * (rhs.m_scale + (std::max)(std::fabs(lhs_v), std::fabs(rhs.m_value)));
        -: 2831:            if (relativeOK) {
        -: 2832:                return true;
        -: 2833:            }
        -: 2834:
        -: 2835:            return std::fabs(lhs_v - rhs.m_value) <= rhs.m_margin;
        -: 2836:        }
        -: 2837:
        -: 2838:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2839:        friend bool operator == ( Approx const& lhs, const T& rhs ) {
        -: 2840:            return operator==( rhs, lhs );
        -: 2841:        }
        -: 2842:
        -: 2843:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2844:        friend bool operator != ( T lhs, Approx const& rhs ) {
        -: 2845:            return !operator==( lhs, rhs );
        -: 2846:        }
        -: 2847:
        -: 2848:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2849:        friend bool operator != ( Approx const& lhs, T rhs ) {
        -: 2850:            return !operator==( rhs, lhs );
        -: 2851:        }
        -: 2852:
        -: 2853:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2854:        friend bool operator <= ( T lhs, Approx const& rhs ) {
        -: 2855:            return double(lhs) < rhs.m_value || lhs == rhs;
        -: 2856:        }
        -: 2857:
        -: 2858:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2859:        friend bool operator <= ( Approx const& lhs, T rhs ) {
        -: 2860:            return lhs.m_value < double(rhs) || lhs == rhs;
        -: 2861:        }
        -: 2862:
        -: 2863:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2864:        friend bool operator >= ( T lhs, Approx const& rhs ) {
        -: 2865:            return double(lhs) > rhs.m_value || lhs == rhs;
        -: 2866:        }
        -: 2867:
        -: 2868:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2869:        friend bool operator >= ( Approx const& lhs, T rhs ) {
        -: 2870:            return lhs.m_value > double(rhs) || lhs == rhs;
        -: 2871:        }
        -: 2872:
        -: 2873:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2874:        Approx& epsilon( T newEpsilon ) {
        -: 2875:            m_epsilon = double(newEpsilon);
        -: 2876:            return *this;
        -: 2877:        }
        -: 2878:
        -: 2879:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2880:        Approx& margin( T newMargin ) {
        -: 2881:            m_margin = double(newMargin);
        -: 2882:            return *this;
        -: 2883:        }
        -: 2884:
        -: 2885:        template <typename T, typename = typename std::enable_if<std::is_constructible<double, T>::value>::type>
        -: 2886:        Approx& scale( T newScale ) {
        -: 2887:            m_scale = double(newScale);
        -: 2888:            return *this;
        -: 2889:        }
        -: 2890:
        -: 2891:#else
        -: 2892:
        -: 2893:        Approx operator()( double value ) {
        -: 2894:            Approx approx( value );
        -: 2895:            approx.epsilon( m_epsilon );
        -: 2896:            approx.margin( m_margin );
        -: 2897:            approx.scale( m_scale );
        -: 2898:            return approx;
        -: 2899:        }
        -: 2900:
        -: 2901:        friend bool operator == ( double lhs, Approx const& rhs ) {
        -: 2902:            // Thanks to Richard Harris for his help refining this formula
        -: 2903:            bool relativeOK = std::fabs( lhs - rhs.m_value ) < rhs.m_epsilon * (rhs.m_scale + (std::max)( std::fabs(lhs), std::fabs(rhs.m_value) ) );
        -: 2904:            if (relativeOK) {
        -: 2905:                return true;
        -: 2906:            }
        -: 2907:            return std::fabs(lhs - rhs.m_value) <= rhs.m_margin;
        -: 2908:        }
        -: 2909:
        -: 2910:        friend bool operator == ( Approx const& lhs, double rhs ) {
        -: 2911:            return operator==( rhs, lhs );
        -: 2912:        }
        -: 2913:
        -: 2914:        friend bool operator != ( double lhs, Approx const& rhs ) {
        -: 2915:            return !operator==( lhs, rhs );
        -: 2916:        }
        -: 2917:
        -: 2918:        friend bool operator != ( Approx const& lhs, double rhs ) {
        -: 2919:            return !operator==( rhs, lhs );
        -: 2920:        }
        -: 2921:
        -: 2922:        friend bool operator <= ( double lhs, Approx const& rhs ) {
        -: 2923:            return lhs < rhs.m_value || lhs == rhs;
        -: 2924:        }
        -: 2925:
        -: 2926:        friend bool operator <= ( Approx const& lhs, double rhs ) {
        -: 2927:            return lhs.m_value < rhs || lhs == rhs;
        -: 2928:        }
        -: 2929:
        -: 2930:        friend bool operator >= ( double lhs, Approx const& rhs ) {
        -: 2931:            return lhs > rhs.m_value || lhs == rhs;
        -: 2932:        }
        -: 2933:
        -: 2934:        friend bool operator >= ( Approx const& lhs, double rhs ) {
        -: 2935:            return lhs.m_value > rhs || lhs == rhs;
        -: 2936:        }
        -: 2937:
        -: 2938:        Approx& epsilon( double newEpsilon ) {
        -: 2939:            m_epsilon = newEpsilon;
        -: 2940:            return *this;
        -: 2941:        }
        -: 2942:
        -: 2943:        Approx& margin( double newMargin ) {
        -: 2944:            m_margin = newMargin;
        -: 2945:            return *this;
        -: 2946:        }
        -: 2947:
        -: 2948:        Approx& scale( double newScale ) {
        -: 2949:            m_scale = newScale;
        -: 2950:            return *this;
        -: 2951:        }
        -: 2952:#endif
        -: 2953:
        -: 2954:        std::string toString() const {
        -: 2955:            std::ostringstream oss;
        -: 2956:            oss << "Approx( " << Catch::toString( m_value ) << " )";
        -: 2957:            return oss.str();
        -: 2958:        }
        -: 2959:
        -: 2960:    private:
        -: 2961:        double m_epsilon;
        -: 2962:        double m_margin;
        -: 2963:        double m_scale;
        -: 2964:        double m_value;
        -: 2965:    };
        -: 2966:}
        -: 2967:
        -: 2968:template<>
        -: 2969:inline std::string toString<Detail::Approx>( Detail::Approx const& value ) {
        -: 2970:    return value.toString();
        -: 2971:}
        -: 2972:
        -: 2973:} // end namespace Catch
        -: 2974:
        -: 2975:// #included from: internal/catch_matchers_string.h
        -: 2976:#define TWOBLUECUBES_CATCH_MATCHERS_STRING_H_INCLUDED
        -: 2977:
        -: 2978:namespace Catch {
        -: 2979:namespace Matchers {
        -: 2980:
        -: 2981:    namespace StdString {
        -: 2982:
        -: 2983:        struct CasedString
        -: 2984:        {
        -: 2985:            CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity );
        -: 2986:            std::string adjustString( std::string const& str ) const;
        -: 2987:            std::string caseSensitivitySuffix() const;
        -: 2988:
        -: 2989:            CaseSensitive::Choice m_caseSensitivity;
        -: 2990:            std::string m_str;
        -: 2991:        };
        -: 2992:
        -: 2993:        struct StringMatcherBase : MatcherBase<std::string> {
        -: 2994:            StringMatcherBase( std::string const& operation, CasedString const& comparator );
        -: 2995:            virtual std::string describe() const CATCH_OVERRIDE;
        -: 2996:
        -: 2997:            CasedString m_comparator;
        -: 2998:            std::string m_operation;
        -: 2999:        };
        -: 3000:
        -: 3001:        struct EqualsMatcher : StringMatcherBase {
        -: 3002:            EqualsMatcher( CasedString const& comparator );
        -: 3003:            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;
        -: 3004:        };
        -: 3005:        struct ContainsMatcher : StringMatcherBase {
        -: 3006:            ContainsMatcher( CasedString const& comparator );
        -: 3007:            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;
        -: 3008:        };
        -: 3009:        struct StartsWithMatcher : StringMatcherBase {
        -: 3010:            StartsWithMatcher( CasedString const& comparator );
        -: 3011:            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;
        -: 3012:        };
        -: 3013:        struct EndsWithMatcher : StringMatcherBase {
        -: 3014:            EndsWithMatcher( CasedString const& comparator );
        -: 3015:            virtual bool match( std::string const& source ) const CATCH_OVERRIDE;
        -: 3016:        };
        -: 3017:
        -: 3018:    } // namespace StdString
        -: 3019:
        -: 3020:    // The following functions create the actual matcher objects.
        -: 3021:    // This allows the types to be inferred
        -: 3022:
        -: 3023:    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 3024:    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 3025:    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 3026:    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity = CaseSensitive::Yes );
        -: 3027:
        -: 3028:} // namespace Matchers
        -: 3029:} // namespace Catch
        -: 3030:
        -: 3031:// #included from: internal/catch_matchers_vector.h
        -: 3032:#define TWOBLUECUBES_CATCH_MATCHERS_VECTOR_H_INCLUDED
        -: 3033:
        -: 3034:namespace Catch {
        -: 3035:namespace Matchers {
        -: 3036:
        -: 3037:    namespace Vector {
        -: 3038:
        -: 3039:        template<typename T>
        -: 3040:        struct ContainsElementMatcher : MatcherBase<std::vector<T>, T> {
        -: 3041:
        -: 3042:            ContainsElementMatcher(T const &comparator) : m_comparator( comparator) {}
        -: 3043:
        -: 3044:            bool match(std::vector<T> const &v) const CATCH_OVERRIDE {
        -: 3045:                return std::find(v.begin(), v.end(), m_comparator) != v.end();
        -: 3046:            }
        -: 3047:
        -: 3048:            virtual std::string describe() const CATCH_OVERRIDE {
        -: 3049:                return "Contains: " + Catch::toString( m_comparator );
        -: 3050:            }
        -: 3051:
        -: 3052:            T const& m_comparator;
        -: 3053:        };
        -: 3054:
        -: 3055:        template<typename T>
        -: 3056:        struct ContainsMatcher : MatcherBase<std::vector<T>, std::vector<T> > {
        -: 3057:
        -: 3058:            ContainsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}
        -: 3059:
        -: 3060:            bool match(std::vector<T> const &v) const CATCH_OVERRIDE {
        -: 3061:                // !TBD: see note in EqualsMatcher
        -: 3062:                if (m_comparator.size() > v.size())
        -: 3063:                    return false;
        -: 3064:                for (size_t i = 0; i < m_comparator.size(); ++i)
        -: 3065:                    if (std::find(v.begin(), v.end(), m_comparator[i]) == v.end())
        -: 3066:                        return false;
        -: 3067:                return true;
        -: 3068:            }
        -: 3069:            virtual std::string describe() const CATCH_OVERRIDE {
        -: 3070:                return "Contains: " + Catch::toString( m_comparator );
        -: 3071:            }
        -: 3072:
        -: 3073:            std::vector<T> const& m_comparator;
        -: 3074:        };
        -: 3075:
        -: 3076:        template<typename T>
        -: 3077:        struct EqualsMatcher : MatcherBase<std::vector<T>, std::vector<T> > {
        -: 3078:
        -: 3079:            EqualsMatcher(std::vector<T> const &comparator) : m_comparator( comparator ) {}
        -: 3080:
        -: 3081:            bool match(std::vector<T> const &v) const CATCH_OVERRIDE {
        -: 3082:                // !TBD: This currently works if all elements can be compared using !=
        -: 3083:                // - a more general approach would be via a compare template that defaults
        -: 3084:                // to using !=. but could be specialised for, e.g. std::vector<T> etc
        -: 3085:                // - then just call that directly
        -: 3086:                if (m_comparator.size() != v.size())
        -: 3087:                    return false;
        -: 3088:                for (size_t i = 0; i < v.size(); ++i)
        -: 3089:                    if (m_comparator[i] != v[i])
        -: 3090:                        return false;
        -: 3091:                return true;
        -: 3092:            }
        -: 3093:            virtual std::string describe() const CATCH_OVERRIDE {
        -: 3094:                return "Equals: " + Catch::toString( m_comparator );
        -: 3095:            }
        -: 3096:            std::vector<T> const& m_comparator;
        -: 3097:        };
        -: 3098:
        -: 3099:    } // namespace Vector
        -: 3100:
        -: 3101:    // The following functions create the actual matcher objects.
        -: 3102:    // This allows the types to be inferred
        -: 3103:
        -: 3104:    template<typename T>
        -: 3105:    Vector::ContainsMatcher<T> Contains( std::vector<T> const& comparator ) {
        -: 3106:        return Vector::ContainsMatcher<T>( comparator );
        -: 3107:    }
        -: 3108:
        -: 3109:    template<typename T>
        -: 3110:    Vector::ContainsElementMatcher<T> VectorContains( T const& comparator ) {
        -: 3111:        return Vector::ContainsElementMatcher<T>( comparator );
        -: 3112:    }
        -: 3113:
        -: 3114:    template<typename T>
        -: 3115:    Vector::EqualsMatcher<T> Equals( std::vector<T> const& comparator ) {
        -: 3116:        return Vector::EqualsMatcher<T>( comparator );
        -: 3117:    }
        -: 3118:
        -: 3119:} // namespace Matchers
        -: 3120:} // namespace Catch
        -: 3121:
        -: 3122:// #included from: internal/catch_interfaces_tag_alias_registry.h
        -: 3123:#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED
        -: 3124:
        -: 3125:// #included from: catch_tag_alias.h
        -: 3126:#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED
        -: 3127:
        -: 3128:#include <string>
        -: 3129:
        -: 3130:namespace Catch {
        -: 3131:
        -: 3132:    struct TagAlias {
    #####: 3133:        TagAlias( std::string const& _tag, SourceLineInfo _lineInfo ) : tag( _tag ), lineInfo( _lineInfo ) {}
        -: 3134:
        -: 3135:        std::string tag;
        -: 3136:        SourceLineInfo lineInfo;
        -: 3137:    };
        -: 3138:
        -: 3139:    struct RegistrarForTagAliases {
        -: 3140:        RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo );
        -: 3141:    };
        -: 3142:
        -: 3143:} // end namespace Catch
        -: 3144:
        -: 3145:#define CATCH_REGISTER_TAG_ALIAS( alias, spec ) namespace{ Catch::RegistrarForTagAliases INTERNAL_CATCH_UNIQUE_NAME( AutoRegisterTagAlias )( alias, spec, CATCH_INTERNAL_LINEINFO ); }
        -: 3146:// #included from: catch_option.hpp
        -: 3147:#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED
        -: 3148:
        -: 3149:namespace Catch {
        -: 3150:
        -: 3151:    // An optional type
        -: 3152:    template<typename T>
        -: 3153:    class Option {
        -: 3154:    public:
       4*: 3155:        Option() : nullableValue( CATCH_NULL ) {}
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEEC2Ev:
        1: 3155:        Option() : nullableValue( CATCH_NULL ) {}
------------------
_ZN5Catch6OptionINS_9GroupInfoEEC2Ev:
        1: 3155:        Option() : nullableValue( CATCH_NULL ) {}
------------------
_ZN5Catch6OptionINS_11TestRunInfoEEC2Ev:
        1: 3155:        Option() : nullableValue( CATCH_NULL ) {}
------------------
_ZN5Catch6OptionINS_8TagAliasEEC2Ev:
    #####: 3155:        Option() : nullableValue( CATCH_NULL ) {}
------------------
_ZN5Catch6OptionImEC2Ev:
        1: 3155:        Option() : nullableValue( CATCH_NULL ) {}
------------------
    #####: 3156:        Option( T const& _value )
    #####: 3157:        : nullableValue( new( storage ) T( _value ) )
    #####: 3158:        {}
        -: 3159:        Option( Option const& _other )
        -: 3160:        : nullableValue( _other ? new( storage ) T( *_other ) : CATCH_NULL )
        -: 3161:        {}
        -: 3162:
       4*: 3163:        ~Option() {
       4*: 3164:            reset();
       4*: 3165:        }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEED2Ev:
        1: 3163:        ~Option() {
        1: 3164:            reset();
        1: 3165:        }
------------------
_ZN5Catch6OptionINS_9GroupInfoEED2Ev:
        1: 3163:        ~Option() {
        1: 3164:            reset();
        1: 3165:        }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEED2Ev:
        1: 3163:        ~Option() {
        1: 3164:            reset();
        1: 3165:        }
------------------
_ZN5Catch6OptionINS_8TagAliasEED2Ev:
    #####: 3163:        ~Option() {
    #####: 3164:            reset();
    #####: 3165:        }
------------------
_ZN5Catch6OptionImED2Ev:
        1: 3163:        ~Option() {
        1: 3164:            reset();
        1: 3165:        }
------------------
        -: 3166:
        -: 3167:        Option& operator= ( Option const& _other ) {
        -: 3168:            if( &_other != this ) {
        -: 3169:                reset();
        -: 3170:                if( _other )
        -: 3171:                    nullableValue = new( storage ) T( *_other );
        -: 3172:            }
        -: 3173:            return *this;
        -: 3174:        }
       3*: 3175:        Option& operator = ( T const& _value ) {
       3*: 3176:            reset();
       3*: 3177:            nullableValue = new( storage ) T( _value );
       3*: 3178:            return *this;
        -: 3179:        }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEEaSERKS1_:
        1: 3175:        Option& operator = ( T const& _value ) {
        1: 3176:            reset();
        1: 3177:            nullableValue = new( storage ) T( _value );
        1: 3178:            return *this;
        -: 3179:        }
------------------
_ZN5Catch6OptionINS_9GroupInfoEEaSERKS1_:
        1: 3175:        Option& operator = ( T const& _value ) {
        1: 3176:            reset();
        1: 3177:            nullableValue = new( storage ) T( _value );
        1: 3178:            return *this;
        -: 3179:        }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEEaSERKS1_:
        1: 3175:        Option& operator = ( T const& _value ) {
        1: 3176:            reset();
        1: 3177:            nullableValue = new( storage ) T( _value );
        1: 3178:            return *this;
        -: 3179:        }
------------------
_ZN5Catch6OptionImEaSERKm:
    #####: 3175:        Option& operator = ( T const& _value ) {
    #####: 3176:            reset();
    #####: 3177:            nullableValue = new( storage ) T( _value );
    #####: 3178:            return *this;
        -: 3179:        }
------------------
        -: 3180:
      12*: 3181:        void reset() {
      12*: 3182:            if( nullableValue )
       3*: 3183:                nullableValue->~T();
      12*: 3184:            nullableValue = CATCH_NULL;
      12*: 3185:        }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEE5resetEv:
        4: 3181:        void reset() {
        4: 3182:            if( nullableValue )
        1: 3183:                nullableValue->~T();
        4: 3184:            nullableValue = CATCH_NULL;
        4: 3185:        }
------------------
_ZN5Catch6OptionINS_9GroupInfoEE5resetEv:
        4: 3181:        void reset() {
        4: 3182:            if( nullableValue )
        1: 3183:                nullableValue->~T();
        4: 3184:            nullableValue = CATCH_NULL;
        4: 3185:        }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEE5resetEv:
        3: 3181:        void reset() {
        3: 3182:            if( nullableValue )
        1: 3183:                nullableValue->~T();
        3: 3184:            nullableValue = CATCH_NULL;
        3: 3185:        }
------------------
_ZN5Catch6OptionINS_8TagAliasEE5resetEv:
    #####: 3181:        void reset() {
    #####: 3182:            if( nullableValue )
    #####: 3183:                nullableValue->~T();
    #####: 3184:            nullableValue = CATCH_NULL;
    #####: 3185:        }
------------------
_ZN5Catch6OptionImE5resetEv:
        1: 3181:        void reset() {
        1: 3182:            if( nullableValue )
    #####: 3183:                nullableValue->~T();
        1: 3184:            nullableValue = CATCH_NULL;
        1: 3185:        }
------------------
        -: 3186:
    #####: 3187:        T& operator*() { return *nullableValue; }
        -: 3188:        T const& operator*() const { return *nullableValue; }
    #####: 3189:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_12TestCaseInfoEEptEv:
    #####: 3189:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_9GroupInfoEEptEv:
    #####: 3189:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_11TestRunInfoEEptEv:
    #####: 3189:        T* operator->() { return nullableValue; }
------------------
_ZN5Catch6OptionINS_8TagAliasEEptEv:
    #####: 3189:        T* operator->() { return nullableValue; }
------------------
        -: 3190:        const T* operator->() const { return nullableValue; }
        -: 3191:
    #####: 3192:        T valueOr( T const& defaultValue ) const {
    #####: 3193:            return nullableValue ? *nullableValue : defaultValue;
        -: 3194:        }
        -: 3195:
        1: 3196:        bool some() const { return nullableValue != CATCH_NULL; }
        -: 3197:        bool none() const { return nullableValue == CATCH_NULL; }
        -: 3198:
        -: 3199:        bool operator !() const { return nullableValue == CATCH_NULL; }
        1: 3200:        operator SafeBool::type() const {
        1: 3201:            return SafeBool::makeSafe( some() );
        -: 3202:        }
        -: 3203:
        -: 3204:    private:
        -: 3205:        T *nullableValue;
        -: 3206:        union {
        -: 3207:            char storage[sizeof(T)];
        -: 3208:
        -: 3209:            // These are here to force alignment for the storage
        -: 3210:            long double dummy1;
        -: 3211:            void (*dummy2)();
        -: 3212:            long double dummy3;
        -: 3213:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
        -: 3214:            long long dummy4;
        -: 3215:#endif
        -: 3216:        };
        -: 3217:    };
        -: 3218:
        -: 3219:} // end namespace Catch
        -: 3220:
        -: 3221:namespace Catch {
        -: 3222:
        -: 3223:    struct ITagAliasRegistry {
        -: 3224:        virtual ~ITagAliasRegistry();
        -: 3225:        virtual Option<TagAlias> find( std::string const& alias ) const = 0;
        -: 3226:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const = 0;
        -: 3227:
        -: 3228:        static ITagAliasRegistry const& get();
        -: 3229:    };
        -: 3230:
        -: 3231:} // end namespace Catch
        -: 3232:
        -: 3233:// These files are included here so the single_include script doesn't put them
        -: 3234:// in the conditionally compiled sections
        -: 3235:// #included from: internal/catch_test_case_info.h
        -: 3236:#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED
        -: 3237:
        -: 3238:#include <string>
        -: 3239:#include <set>
        -: 3240:
        -: 3241:#ifdef __clang__
        -: 3242:#pragma clang diagnostic push
        -: 3243:#pragma clang diagnostic ignored "-Wpadded"
        -: 3244:#endif
        -: 3245:
        -: 3246:namespace Catch {
        -: 3247:
        -: 3248:    struct ITestCase;
        -: 3249:
        -: 3250:    struct TestCaseInfo {
        -: 3251:        enum SpecialProperties{
        -: 3252:            None = 0,
        -: 3253:            IsHidden = 1 << 1,
        -: 3254:            ShouldFail = 1 << 2,
        -: 3255:            MayFail = 1 << 3,
        -: 3256:            Throws = 1 << 4,
        -: 3257:            NonPortable = 1 << 5
        -: 3258:        };
        -: 3259:
        -: 3260:        TestCaseInfo(   std::string const& _name,
        -: 3261:                        std::string const& _className,
        -: 3262:                        std::string const& _description,
        -: 3263:                        std::set<std::string> const& _tags,
        -: 3264:                        SourceLineInfo const& _lineInfo );
        -: 3265:
        -: 3266:        TestCaseInfo( TestCaseInfo const& other );
        -: 3267:
        -: 3268:        friend void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags );
        -: 3269:
        -: 3270:        bool isHidden() const;
        -: 3271:        bool throws() const;
        -: 3272:        bool okToFail() const;
        -: 3273:        bool expectedToFail() const;
        -: 3274:
        -: 3275:        std::string name;
        -: 3276:        std::string className;
        -: 3277:        std::string description;
        -: 3278:        std::set<std::string> tags;
        -: 3279:        std::set<std::string> lcaseTags;
        -: 3280:        std::string tagsAsString;
        -: 3281:        SourceLineInfo lineInfo;
        -: 3282:        SpecialProperties properties;
        -: 3283:    };
        -: 3284:
        -: 3285:    class TestCase : public TestCaseInfo {
        -: 3286:    public:
        -: 3287:
        -: 3288:        TestCase( ITestCase* testCase, TestCaseInfo const& info );
        -: 3289:        TestCase( TestCase const& other );
        -: 3290:
        -: 3291:        TestCase withName( std::string const& _newName ) const;
        -: 3292:
        -: 3293:        void invoke() const;
        -: 3294:
        -: 3295:        TestCaseInfo const& getTestCaseInfo() const;
        -: 3296:
        -: 3297:        void swap( TestCase& other );
        -: 3298:        bool operator == ( TestCase const& other ) const;
        -: 3299:        bool operator < ( TestCase const& other ) const;
        -: 3300:        TestCase& operator = ( TestCase const& other );
        -: 3301:
        -: 3302:    private:
        -: 3303:        Ptr<ITestCase> test;
        -: 3304:    };
        -: 3305:
        -: 3306:    TestCase makeTestCase(  ITestCase* testCase,
        -: 3307:                            std::string const& className,
        -: 3308:                            std::string const& name,
        -: 3309:                            std::string const& description,
        -: 3310:                            SourceLineInfo const& lineInfo );
        -: 3311:}
        -: 3312:
        -: 3313:#ifdef __clang__
        -: 3314:#pragma clang diagnostic pop
        -: 3315:#endif
        -: 3316:
        -: 3317:
        -: 3318:#ifdef __OBJC__
        -: 3319:// #included from: internal/catch_objc.hpp
        -: 3320:#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED
        -: 3321:
        -: 3322:#import <objc/runtime.h>
        -: 3323:
        -: 3324:#include <string>
        -: 3325:
        -: 3326:// NB. Any general catch headers included here must be included
        -: 3327:// in catch.hpp first to make sure they are included by the single
        -: 3328:// header for non obj-usage
        -: 3329:
        -: 3330:///////////////////////////////////////////////////////////////////////////////
        -: 3331:// This protocol is really only here for (self) documenting purposes, since
        -: 3332:// all its methods are optional.
        -: 3333:@protocol OcFixture
        -: 3334:
        -: 3335:@optional
        -: 3336:
        -: 3337:-(void) setUp;
        -: 3338:-(void) tearDown;
        -: 3339:
        -: 3340:@end
        -: 3341:
        -: 3342:namespace Catch {
        -: 3343:
        -: 3344:    class OcMethod : public SharedImpl<ITestCase> {
        -: 3345:
        -: 3346:    public:
        -: 3347:        OcMethod( Class cls, SEL sel ) : m_cls( cls ), m_sel( sel ) {}
        -: 3348:
        -: 3349:        virtual void invoke() const {
        -: 3350:            id obj = [[m_cls alloc] init];
        -: 3351:
        -: 3352:            performOptionalSelector( obj, @selector(setUp)  );
        -: 3353:            performOptionalSelector( obj, m_sel );
        -: 3354:            performOptionalSelector( obj, @selector(tearDown)  );
        -: 3355:
        -: 3356:            arcSafeRelease( obj );
        -: 3357:        }
        -: 3358:    private:
        -: 3359:        virtual ~OcMethod() {}
        -: 3360:
        -: 3361:        Class m_cls;
        -: 3362:        SEL m_sel;
        -: 3363:    };
        -: 3364:
        -: 3365:    namespace Detail{
        -: 3366:
        -: 3367:        inline std::string getAnnotation(   Class cls,
        -: 3368:                                            std::string const& annotationName,
        -: 3369:                                            std::string const& testCaseName ) {
        -: 3370:            NSString* selStr = [[NSString alloc] initWithFormat:@"Catch_%s_%s", annotationName.c_str(), testCaseName.c_str()];
        -: 3371:            SEL sel = NSSelectorFromString( selStr );
        -: 3372:            arcSafeRelease( selStr );
        -: 3373:            id value = performOptionalSelector( cls, sel );
        -: 3374:            if( value )
        -: 3375:                return [(NSString*)value UTF8String];
        -: 3376:            return "";
        -: 3377:        }
        -: 3378:    }
        -: 3379:
        -: 3380:    inline size_t registerTestMethods() {
        -: 3381:        size_t noTestMethods = 0;
        -: 3382:        int noClasses = objc_getClassList( CATCH_NULL, 0 );
        -: 3383:
        -: 3384:        Class* classes = (CATCH_UNSAFE_UNRETAINED Class *)malloc( sizeof(Class) * noClasses);
        -: 3385:        objc_getClassList( classes, noClasses );
        -: 3386:
        -: 3387:        for( int c = 0; c < noClasses; c++ ) {
        -: 3388:            Class cls = classes[c];
        -: 3389:            {
        -: 3390:                u_int count;
        -: 3391:                Method* methods = class_copyMethodList( cls, &count );
        -: 3392:                for( u_int m = 0; m < count ; m++ ) {
        -: 3393:                    SEL selector = method_getName(methods[m]);
        -: 3394:                    std::string methodName = sel_getName(selector);
        -: 3395:                    if( startsWith( methodName, "Catch_TestCase_" ) ) {
        -: 3396:                        std::string testCaseName = methodName.substr( 15 );
        -: 3397:                        std::string name = Detail::getAnnotation( cls, "Name", testCaseName );
        -: 3398:                        std::string desc = Detail::getAnnotation( cls, "Description", testCaseName );
        -: 3399:                        const char* className = class_getName( cls );
        -: 3400:
        -: 3401:                        getMutableRegistryHub().registerTest( makeTestCase( new OcMethod( cls, selector ), className, name.c_str(), desc.c_str(), SourceLineInfo() ) );
        -: 3402:                        noTestMethods++;
        -: 3403:                    }
        -: 3404:                }
        -: 3405:                free(methods);
        -: 3406:            }
        -: 3407:        }
        -: 3408:        return noTestMethods;
        -: 3409:    }
        -: 3410:
        -: 3411:    namespace Matchers {
        -: 3412:        namespace Impl {
        -: 3413:        namespace NSStringMatchers {
        -: 3414:
        -: 3415:            struct StringHolder : MatcherBase<NSString*>{
        -: 3416:                StringHolder( NSString* substr ) : m_substr( [substr copy] ){}
        -: 3417:                StringHolder( StringHolder const& other ) : m_substr( [other.m_substr copy] ){}
        -: 3418:                StringHolder() {
        -: 3419:                    arcSafeRelease( m_substr );
        -: 3420:                }
        -: 3421:
        -: 3422:                virtual bool match( NSString* arg ) const CATCH_OVERRIDE {
        -: 3423:                    return false;
        -: 3424:                }
        -: 3425:
        -: 3426:                NSString* m_substr;
        -: 3427:            };
        -: 3428:
        -: 3429:            struct Equals : StringHolder {
        -: 3430:                Equals( NSString* substr ) : StringHolder( substr ){}
        -: 3431:
        -: 3432:                virtual bool match( NSString* str ) const CATCH_OVERRIDE {
        -: 3433:                    return  (str != nil || m_substr == nil ) &&
        -: 3434:                            [str isEqualToString:m_substr];
        -: 3435:                }
        -: 3436:
        -: 3437:                virtual std::string describe() const CATCH_OVERRIDE {
        -: 3438:                    return "equals string: " + Catch::toString( m_substr );
        -: 3439:                }
        -: 3440:            };
        -: 3441:
        -: 3442:            struct Contains : StringHolder {
        -: 3443:                Contains( NSString* substr ) : StringHolder( substr ){}
        -: 3444:
        -: 3445:                virtual bool match( NSString* str ) const {
        -: 3446:                    return  (str != nil || m_substr == nil ) &&
        -: 3447:                            [str rangeOfString:m_substr].location != NSNotFound;
        -: 3448:                }
        -: 3449:
        -: 3450:                virtual std::string describe() const CATCH_OVERRIDE {
        -: 3451:                    return "contains string: " + Catch::toString( m_substr );
        -: 3452:                }
        -: 3453:            };
        -: 3454:
        -: 3455:            struct StartsWith : StringHolder {
        -: 3456:                StartsWith( NSString* substr ) : StringHolder( substr ){}
        -: 3457:
        -: 3458:                virtual bool match( NSString* str ) const {
        -: 3459:                    return  (str != nil || m_substr == nil ) &&
        -: 3460:                            [str rangeOfString:m_substr].location == 0;
        -: 3461:                }
        -: 3462:
        -: 3463:                virtual std::string describe() const CATCH_OVERRIDE {
        -: 3464:                    return "starts with: " + Catch::toString( m_substr );
        -: 3465:                }
        -: 3466:            };
        -: 3467:            struct EndsWith : StringHolder {
        -: 3468:                EndsWith( NSString* substr ) : StringHolder( substr ){}
        -: 3469:
        -: 3470:                virtual bool match( NSString* str ) const {
        -: 3471:                    return  (str != nil || m_substr == nil ) &&
        -: 3472:                            [str rangeOfString:m_substr].location == [str length] - [m_substr length];
        -: 3473:                }
        -: 3474:
        -: 3475:                virtual std::string describe() const CATCH_OVERRIDE {
        -: 3476:                    return "ends with: " + Catch::toString( m_substr );
        -: 3477:                }
        -: 3478:            };
        -: 3479:
        -: 3480:        } // namespace NSStringMatchers
        -: 3481:        } // namespace Impl
        -: 3482:
        -: 3483:        inline Impl::NSStringMatchers::Equals
        -: 3484:            Equals( NSString* substr ){ return Impl::NSStringMatchers::Equals( substr ); }
        -: 3485:
        -: 3486:        inline Impl::NSStringMatchers::Contains
        -: 3487:            Contains( NSString* substr ){ return Impl::NSStringMatchers::Contains( substr ); }
        -: 3488:
        -: 3489:        inline Impl::NSStringMatchers::StartsWith
        -: 3490:            StartsWith( NSString* substr ){ return Impl::NSStringMatchers::StartsWith( substr ); }
        -: 3491:
        -: 3492:        inline Impl::NSStringMatchers::EndsWith
        -: 3493:            EndsWith( NSString* substr ){ return Impl::NSStringMatchers::EndsWith( substr ); }
        -: 3494:
        -: 3495:    } // namespace Matchers
        -: 3496:
        -: 3497:    using namespace Matchers;
        -: 3498:
        -: 3499:} // namespace Catch
        -: 3500:
        -: 3501:///////////////////////////////////////////////////////////////////////////////
        -: 3502:#define OC_TEST_CASE( name, desc )\
        -: 3503:+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Name_test ) \
        -: 3504:{\
        -: 3505:return @ name; \
        -: 3506:}\
        -: 3507:+(NSString*) INTERNAL_CATCH_UNIQUE_NAME( Catch_Description_test ) \
        -: 3508:{ \
        -: 3509:return @ desc; \
        -: 3510:} \
        -: 3511:-(void) INTERNAL_CATCH_UNIQUE_NAME( Catch_TestCase_test )
        -: 3512:
        -: 3513:#endif
        -: 3514:
        -: 3515:#ifdef CATCH_IMPL
        -: 3516:
        -: 3517:// !TBD: Move the leak detector code into a separate header
        -: 3518:#ifdef CATCH_CONFIG_WINDOWS_CRTDBG
        -: 3519:#include <crtdbg.h>
        -: 3520:class LeakDetector {
        -: 3521:public:
        -: 3522:    LeakDetector() {
        -: 3523:        int flag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
        -: 3524:        flag |= _CRTDBG_LEAK_CHECK_DF;
        -: 3525:        flag |= _CRTDBG_ALLOC_MEM_DF;
        -: 3526:        _CrtSetDbgFlag(flag);
        -: 3527:        _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);
        -: 3528:        _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);
        -: 3529:        // Change this to leaking allocation's number to break there
        -: 3530:        _CrtSetBreakAlloc(-1);
        -: 3531:    }
        -: 3532:};
        -: 3533:#else
        -: 3534:class LeakDetector {};
        -: 3535:#endif
        -: 3536:
        -: 3537:LeakDetector leakDetector;
        -: 3538:
        -: 3539:// #included from: internal/catch_impl.hpp
        -: 3540:#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED
        -: 3541:
        -: 3542:// Collect all the implementation files together here
        -: 3543:// These are the equivalent of what would usually be cpp files
        -: 3544:
        -: 3545:#ifdef __clang__
        -: 3546:#pragma clang diagnostic push
        -: 3547:#pragma clang diagnostic ignored "-Wweak-vtables"
        -: 3548:#endif
        -: 3549:
        -: 3550:// #included from: ../catch_session.hpp
        -: 3551:#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED
        -: 3552:
        -: 3553:// #included from: internal/catch_commandline.hpp
        -: 3554:#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED
        -: 3555:
        -: 3556:// #included from: catch_config.hpp
        -: 3557:#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED
        -: 3558:
        -: 3559:// #included from: catch_test_spec_parser.hpp
        -: 3560:#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED
        -: 3561:
        -: 3562:#ifdef __clang__
        -: 3563:#pragma clang diagnostic push
        -: 3564:#pragma clang diagnostic ignored "-Wpadded"
        -: 3565:#endif
        -: 3566:
        -: 3567:// #included from: catch_test_spec.hpp
        -: 3568:#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED
        -: 3569:
        -: 3570:#ifdef __clang__
        -: 3571:#pragma clang diagnostic push
        -: 3572:#pragma clang diagnostic ignored "-Wpadded"
        -: 3573:#endif
        -: 3574:
        -: 3575:// #included from: catch_wildcard_pattern.hpp
        -: 3576:#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED
        -: 3577:
        -: 3578:#include <stdexcept>
        -: 3579:
        -: 3580:namespace Catch
        -: 3581:{
        -: 3582:    class WildcardPattern {
        -: 3583:        enum WildcardPosition {
        -: 3584:            NoWildcard = 0,
        -: 3585:            WildcardAtStart = 1,
        -: 3586:            WildcardAtEnd = 2,
        -: 3587:            WildcardAtBothEnds = WildcardAtStart | WildcardAtEnd
        -: 3588:        };
        -: 3589:
        -: 3590:    public:
        -: 3591:
    #####: 3592:        WildcardPattern( std::string const& pattern, CaseSensitive::Choice caseSensitivity )
    #####: 3593:        :   m_caseSensitivity( caseSensitivity ),
        -: 3594:            m_wildcard( NoWildcard ),
    #####: 3595:            m_pattern( adjustCase( pattern ) )
        -: 3596:        {
    #####: 3597:            if( startsWith( m_pattern, '*' ) ) {
    #####: 3598:                m_pattern = m_pattern.substr( 1 );
    #####: 3599:                m_wildcard = WildcardAtStart;
        -: 3600:            }
    #####: 3601:            if( endsWith( m_pattern, '*' ) ) {
    #####: 3602:                m_pattern = m_pattern.substr( 0, m_pattern.size()-1 );
    #####: 3603:                m_wildcard = static_cast<WildcardPosition>( m_wildcard | WildcardAtEnd );
        -: 3604:            }
    #####: 3605:        }
        -: 3606:        virtual ~WildcardPattern();
    #####: 3607:        virtual bool matches( std::string const& str ) const {
    #####: 3608:            switch( m_wildcard ) {
    #####: 3609:                case NoWildcard:
    #####: 3610:                    return m_pattern == adjustCase( str );
    #####: 3611:                case WildcardAtStart:
    #####: 3612:                    return endsWith( adjustCase( str ), m_pattern );
    #####: 3613:                case WildcardAtEnd:
    #####: 3614:                    return startsWith( adjustCase( str ), m_pattern );
    #####: 3615:                case WildcardAtBothEnds:
    #####: 3616:                    return contains( adjustCase( str ), m_pattern );
        -: 3617:            }
        -: 3618:
        -: 3619:#ifdef __clang__
        -: 3620:#pragma clang diagnostic push
        -: 3621:#pragma clang diagnostic ignored "-Wunreachable-code"
        -: 3622:#endif
    #####: 3623:            throw std::logic_error( "Unknown enum" );
        -: 3624:#ifdef __clang__
        -: 3625:#pragma clang diagnostic pop
        -: 3626:#endif
        -: 3627:        }
        -: 3628:    private:
    #####: 3629:        std::string adjustCase( std::string const& str ) const {
    #####: 3630:            return m_caseSensitivity == CaseSensitive::No ? toLower( str ) : str;
        -: 3631:        }
        -: 3632:        CaseSensitive::Choice m_caseSensitivity;
        -: 3633:        WildcardPosition m_wildcard;
        -: 3634:        std::string m_pattern;
        -: 3635:    };
        -: 3636:}
        -: 3637:
        -: 3638:#include <string>
        -: 3639:#include <vector>
        -: 3640:
        -: 3641:namespace Catch {
        -: 3642:
        -: 3643:    class TestSpec {
        -: 3644:        struct Pattern : SharedImpl<> {
        -: 3645:            virtual ~Pattern();
        -: 3646:            virtual bool matches( TestCaseInfo const& testCase ) const = 0;
        -: 3647:        };
        -: 3648:        class NamePattern : public Pattern {
        -: 3649:        public:
    #####: 3650:            NamePattern( std::string const& name )
    #####: 3651:            : m_wildcardPattern( toLower( name ), CaseSensitive::No )
    #####: 3652:            {}
        -: 3653:            virtual ~NamePattern();
    #####: 3654:            virtual bool matches( TestCaseInfo const& testCase ) const {
    #####: 3655:                return m_wildcardPattern.matches( toLower( testCase.name ) );
        -: 3656:            }
        -: 3657:        private:
        -: 3658:            WildcardPattern m_wildcardPattern;
        -: 3659:        };
        -: 3660:
        -: 3661:        class TagPattern : public Pattern {
        -: 3662:        public:
        1: 3663:            TagPattern( std::string const& tag ) : m_tag( toLower( tag ) ) {}
        -: 3664:            virtual ~TagPattern();
        1: 3665:            virtual bool matches( TestCaseInfo const& testCase ) const {
        1: 3666:                return testCase.lcaseTags.find( m_tag ) != testCase.lcaseTags.end();
        -: 3667:            }
        -: 3668:        private:
        -: 3669:            std::string m_tag;
        -: 3670:        };
        -: 3671:
        -: 3672:        class ExcludedPattern : public Pattern {
        -: 3673:        public:
        1: 3674:            ExcludedPattern( Ptr<Pattern> const& underlyingPattern ) : m_underlyingPattern( underlyingPattern ) {}
        -: 3675:            virtual ~ExcludedPattern();
        1: 3676:            virtual bool matches( TestCaseInfo const& testCase ) const { return !m_underlyingPattern->matches( testCase ); }
        -: 3677:        private:
        -: 3678:            Ptr<Pattern> m_underlyingPattern;
        -: 3679:        };
        -: 3680:
        -: 3681:        struct Filter {
        -: 3682:            std::vector<Ptr<Pattern> > m_patterns;
        -: 3683:
        1: 3684:            bool matches( TestCaseInfo const& testCase ) const {
        -: 3685:                // All patterns in a filter must match for the filter to be a match
        2: 3686:                for( std::vector<Ptr<Pattern> >::const_iterator it = m_patterns.begin(), itEnd = m_patterns.end(); it != itEnd; ++it ) {
        1: 3687:                    if( !(*it)->matches( testCase ) )
    #####: 3688:                        return false;
        -: 3689:                }
        1: 3690:                return true;
        -: 3691:            }
        -: 3692:        };
        -: 3693:
        -: 3694:    public:
        1: 3695:        bool hasFilters() const {
        1: 3696:            return !m_filters.empty();
        -: 3697:        }
        1: 3698:        bool matches( TestCaseInfo const& testCase ) const {
        -: 3699:            // A TestSpec matches if any filter matches
       1*: 3700:            for( std::vector<Filter>::const_iterator it = m_filters.begin(), itEnd = m_filters.end(); it != itEnd; ++it )
        1: 3701:                if( it->matches( testCase ) )
        1: 3702:                    return true;
    #####: 3703:            return false;
        -: 3704:        }
        -: 3705:
        -: 3706:    private:
        -: 3707:        std::vector<Filter> m_filters;
        -: 3708:
        -: 3709:        friend class TestSpecParser;
        -: 3710:    };
        -: 3711:}
        -: 3712:
        -: 3713:#ifdef __clang__
        -: 3714:#pragma clang diagnostic pop
        -: 3715:#endif
        -: 3716:
        -: 3717:namespace Catch {
        -: 3718:
        -: 3719:    class TestSpecParser {
        -: 3720:        enum Mode{ None, Name, QuotedName, Tag, EscapedName };
        -: 3721:        Mode m_mode;
        -: 3722:        bool m_exclusion;
        -: 3723:        std::size_t m_start, m_pos;
        -: 3724:        std::string m_arg;
        -: 3725:        std::vector<std::size_t> m_escapeChars;
        -: 3726:        TestSpec::Filter m_currentFilter;
        -: 3727:        TestSpec m_testSpec;
        -: 3728:        ITagAliasRegistry const* m_tagAliases;
        -: 3729:
        -: 3730:    public:
        1: 3731:        TestSpecParser( ITagAliasRegistry const& tagAliases ) :m_mode(None), m_exclusion(false), m_start(0), m_pos(0), m_tagAliases( &tagAliases ) {}
        -: 3732:
        1: 3733:        TestSpecParser& parse( std::string const& arg ) {
        1: 3734:            m_mode = None;
        1: 3735:            m_exclusion = false;
        1: 3736:            m_start = std::string::npos;
        1: 3737:            m_arg = m_tagAliases->expandAliases( arg );
        1: 3738:            m_escapeChars.clear();
        4: 3739:            for( m_pos = 0; m_pos < m_arg.size(); ++m_pos )
        3: 3740:                visitChar( m_arg[m_pos] );
        1: 3741:            if( m_mode == Name )
    #####: 3742:                addPattern<TestSpec::NamePattern>();
        1: 3743:            return *this;
        -: 3744:        }
        1: 3745:        TestSpec testSpec() {
        1: 3746:            addFilter();
        1: 3747:            return m_testSpec;
        -: 3748:        }
        -: 3749:    private:
        3: 3750:        void visitChar( char c ) {
        3: 3751:            if( m_mode == None ) {
        2: 3752:                switch( c ) {
    #####: 3753:                case ' ': return;
        1: 3754:                case '~': m_exclusion = true; return;
        1: 3755:                case '[': return startNewMode( Tag, ++m_pos );
    #####: 3756:                case '"': return startNewMode( QuotedName, ++m_pos );
    #####: 3757:                case '\\': return escape();
    #####: 3758:                default: startNewMode( Name, m_pos ); break;
        -: 3759:                }
        -: 3760:            }
        1: 3761:            if( m_mode == Name ) {
    #####: 3762:                if( c == ',' ) {
    #####: 3763:                    addPattern<TestSpec::NamePattern>();
    #####: 3764:                    addFilter();
        -: 3765:                }
    #####: 3766:                else if( c == '[' ) {
    #####: 3767:                    if( subString() == "exclude:" )
    #####: 3768:                        m_exclusion = true;
        -: 3769:                    else
    #####: 3770:                        addPattern<TestSpec::NamePattern>();
    #####: 3771:                    startNewMode( Tag, ++m_pos );
        -: 3772:                }
    #####: 3773:                else if( c == '\\' )
    #####: 3774:                    escape();
        -: 3775:            }
        1: 3776:            else if( m_mode == EscapedName )
    #####: 3777:                m_mode = Name;
       1*: 3778:            else if( m_mode == QuotedName && c == '"' )
    #####: 3779:                addPattern<TestSpec::NamePattern>();
        1: 3780:            else if( m_mode == Tag && c == ']' )
        1: 3781:                addPattern<TestSpec::TagPattern>();
        -: 3782:        }
        1: 3783:        void startNewMode( Mode mode, std::size_t start ) {
        1: 3784:            m_mode = mode;
        1: 3785:            m_start = start;
        1: 3786:        }
    #####: 3787:        void escape() {
    #####: 3788:            if( m_mode == None )
    #####: 3789:                m_start = m_pos;
    #####: 3790:            m_mode = EscapedName;
    #####: 3791:            m_escapeChars.push_back( m_pos );
    #####: 3792:        }
        1: 3793:        std::string subString() const { return m_arg.substr( m_start, m_pos - m_start ); }
        -: 3794:        template<typename T>
       1*: 3795:        void addPattern() {
       1*: 3796:            std::string token = subString();
       1*: 3797:            for( size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3798:                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
       1*: 3799:            m_escapeChars.clear();
       1*: 3800:            if( startsWith( token, "exclude:" ) ) {
    #####: 3801:                m_exclusion = true;
    #####: 3802:                token = token.substr( 8 );
        -: 3803:            }
       1*: 3804:            if( !token.empty() ) {
       2*: 3805:                Ptr<TestSpec::Pattern> pattern = new T( token );
       1*: 3806:                if( m_exclusion )
       1*: 3807:                    pattern = new TestSpec::ExcludedPattern( pattern );
       1*: 3808:                m_currentFilter.m_patterns.push_back( pattern );
        -: 3809:            }
       1*: 3810:            m_exclusion = false;
       1*: 3811:            m_mode = None;
       1*: 3812:        }
------------------
_ZN5Catch14TestSpecParser10addPatternINS_8TestSpec10TagPatternEEEvv:
        1: 3795:        void addPattern() {
        1: 3796:            std::string token = subString();
       1*: 3797:            for( size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3798:                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
        1: 3799:            m_escapeChars.clear();
        1: 3800:            if( startsWith( token, "exclude:" ) ) {
    #####: 3801:                m_exclusion = true;
    #####: 3802:                token = token.substr( 8 );
        -: 3803:            }
        1: 3804:            if( !token.empty() ) {
        2: 3805:                Ptr<TestSpec::Pattern> pattern = new T( token );
        1: 3806:                if( m_exclusion )
        1: 3807:                    pattern = new TestSpec::ExcludedPattern( pattern );
        1: 3808:                m_currentFilter.m_patterns.push_back( pattern );
        -: 3809:            }
        1: 3810:            m_exclusion = false;
        1: 3811:            m_mode = None;
        1: 3812:        }
------------------
_ZN5Catch14TestSpecParser10addPatternINS_8TestSpec11NamePatternEEEvv:
    #####: 3795:        void addPattern() {
    #####: 3796:            std::string token = subString();
    #####: 3797:            for( size_t i = 0; i < m_escapeChars.size(); ++i )
    #####: 3798:                token = token.substr( 0, m_escapeChars[i]-m_start-i ) + token.substr( m_escapeChars[i]-m_start-i+1 );
    #####: 3799:            m_escapeChars.clear();
    #####: 3800:            if( startsWith( token, "exclude:" ) ) {
    #####: 3801:                m_exclusion = true;
    #####: 3802:                token = token.substr( 8 );
        -: 3803:            }
    #####: 3804:            if( !token.empty() ) {
    #####: 3805:                Ptr<TestSpec::Pattern> pattern = new T( token );
    #####: 3806:                if( m_exclusion )
    #####: 3807:                    pattern = new TestSpec::ExcludedPattern( pattern );
    #####: 3808:                m_currentFilter.m_patterns.push_back( pattern );
        -: 3809:            }
    #####: 3810:            m_exclusion = false;
    #####: 3811:            m_mode = None;
    #####: 3812:        }
------------------
        1: 3813:        void addFilter() {
        1: 3814:            if( !m_currentFilter.m_patterns.empty() ) {
        1: 3815:                m_testSpec.m_filters.push_back( m_currentFilter );
        1: 3816:                m_currentFilter = TestSpec::Filter();
        -: 3817:            }
        1: 3818:        }
        -: 3819:    };
        -: 3820:    inline TestSpec parseTestSpec( std::string const& arg ) {
        -: 3821:        return TestSpecParser( ITagAliasRegistry::get() ).parse( arg ).testSpec();
        -: 3822:    }
        -: 3823:
        -: 3824:} // namespace Catch
        -: 3825:
        -: 3826:#ifdef __clang__
        -: 3827:#pragma clang diagnostic pop
        -: 3828:#endif
        -: 3829:
        -: 3830:// #included from: catch_interfaces_config.h
        -: 3831:#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED
        -: 3832:
        -: 3833:#include <iosfwd>
        -: 3834:#include <string>
        -: 3835:#include <vector>
        -: 3836:
        -: 3837:namespace Catch {
        -: 3838:
        -: 3839:    struct Verbosity { enum Level {
        -: 3840:        NoOutput = 0,
        -: 3841:        Quiet,
        -: 3842:        Normal
        -: 3843:    }; };
        -: 3844:
        -: 3845:    struct WarnAbout { enum What {
        -: 3846:        Nothing = 0x00,
        -: 3847:        NoAssertions = 0x01
        -: 3848:    }; };
        -: 3849:
        -: 3850:    struct ShowDurations { enum OrNot {
        -: 3851:        DefaultForReporter,
        -: 3852:        Always,
        -: 3853:        Never
        -: 3854:    }; };
        -: 3855:    struct RunTests { enum InWhatOrder {
        -: 3856:        InDeclarationOrder,
        -: 3857:        InLexicographicalOrder,
        -: 3858:        InRandomOrder
        -: 3859:    }; };
        -: 3860:    struct UseColour { enum YesOrNo {
        -: 3861:        Auto,
        -: 3862:        Yes,
        -: 3863:        No
        -: 3864:    }; };
        -: 3865:    struct WaitForKeypress { enum When {
        -: 3866:        Never,
        -: 3867:        BeforeStart = 1,
        -: 3868:        BeforeExit = 2,
        -: 3869:        BeforeStartAndExit = BeforeStart | BeforeExit
        -: 3870:    }; };
        -: 3871:
        -: 3872:    class TestSpec;
        -: 3873:
        -: 3874:    struct IConfig : IShared {
        -: 3875:
        -: 3876:        virtual ~IConfig();
        -: 3877:
        -: 3878:        virtual bool allowThrows() const = 0;
        -: 3879:        virtual std::ostream& stream() const = 0;
        -: 3880:        virtual std::string name() const = 0;
        -: 3881:        virtual bool includeSuccessfulResults() const = 0;
        -: 3882:        virtual bool shouldDebugBreak() const = 0;
        -: 3883:        virtual bool warnAboutMissingAssertions() const = 0;
        -: 3884:        virtual int abortAfter() const = 0;
        -: 3885:        virtual bool showInvisibles() const = 0;
        -: 3886:        virtual ShowDurations::OrNot showDurations() const = 0;
        -: 3887:        virtual TestSpec const& testSpec() const = 0;
        -: 3888:        virtual RunTests::InWhatOrder runOrder() const = 0;
        -: 3889:        virtual unsigned int rngSeed() const = 0;
        -: 3890:        virtual UseColour::YesOrNo useColour() const = 0;
        -: 3891:        virtual std::vector<std::string> const& getSectionsToRun() const = 0;
        -: 3892:
        -: 3893:    };
        -: 3894:}
        -: 3895:
        -: 3896:// #included from: catch_stream.h
        -: 3897:#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED
        -: 3898:
        -: 3899:// #included from: catch_streambuf.h
        -: 3900:#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED
        -: 3901:
        -: 3902:#include <streambuf>
        -: 3903:
        -: 3904:namespace Catch {
        -: 3905:
        -: 3906:    class StreamBufBase : public std::streambuf {
        -: 3907:    public:
        -: 3908:        virtual ~StreamBufBase() CATCH_NOEXCEPT;
        -: 3909:    };
        -: 3910:}
        -: 3911:
        -: 3912:#include <streambuf>
        -: 3913:#include <ostream>
        -: 3914:#include <fstream>
        -: 3915:#include <memory>
        -: 3916:
        -: 3917:namespace Catch {
        -: 3918:
        -: 3919:    std::ostream& cout();
        -: 3920:    std::ostream& cerr();
        -: 3921:    std::ostream& clog();
        -: 3922:
        -: 3923:    struct IStream {
        -: 3924:        virtual ~IStream() CATCH_NOEXCEPT;
        -: 3925:        virtual std::ostream& stream() const = 0;
        -: 3926:    };
        -: 3927:
        -: 3928:    class FileStream : public IStream {
        -: 3929:        mutable std::ofstream m_ofs;
        -: 3930:    public:
        -: 3931:        FileStream( std::string const& filename );
        -: 3932:        virtual ~FileStream() CATCH_NOEXCEPT;
        -: 3933:    public: // IStream
        -: 3934:        virtual std::ostream& stream() const CATCH_OVERRIDE;
        -: 3935:    };
        -: 3936:
        -: 3937:    class CoutStream : public IStream {
        -: 3938:        mutable std::ostream m_os;
        -: 3939:    public:
        -: 3940:        CoutStream();
        -: 3941:        virtual ~CoutStream() CATCH_NOEXCEPT;
        -: 3942:
        -: 3943:    public: // IStream
        -: 3944:        virtual std::ostream& stream() const CATCH_OVERRIDE;
        -: 3945:    };
        -: 3946:
        -: 3947:    class DebugOutStream : public IStream {
        -: 3948:        CATCH_AUTO_PTR( StreamBufBase ) m_streamBuf;
        -: 3949:        mutable std::ostream m_os;
        -: 3950:    public:
        -: 3951:        DebugOutStream();
        -: 3952:        virtual ~DebugOutStream() CATCH_NOEXCEPT;
        -: 3953:
        -: 3954:    public: // IStream
        -: 3955:        virtual std::ostream& stream() const CATCH_OVERRIDE;
        -: 3956:    };
        -: 3957:}
        -: 3958:
        -: 3959:#include <memory>
        -: 3960:#include <vector>
        -: 3961:#include <string>
        -: 3962:#include <stdexcept>
        -: 3963:
        -: 3964:#ifndef CATCH_CONFIG_CONSOLE_WIDTH
        -: 3965:#define CATCH_CONFIG_CONSOLE_WIDTH 80
        -: 3966:#endif
        -: 3967:
        -: 3968:namespace Catch {
        -: 3969:
        -: 3970:    struct ConfigData {
        -: 3971:
        1: 3972:        ConfigData()
        1: 3973:        :   listTests( false ),
        -: 3974:            listTags( false ),
        -: 3975:            listReporters( false ),
        -: 3976:            listTestNamesOnly( false ),
        -: 3977:            listExtraInfo( false ),
        -: 3978:            showSuccessfulTests( false ),
        -: 3979:            shouldDebugBreak( false ),
        -: 3980:            noThrow( false ),
        -: 3981:            showHelp( false ),
        -: 3982:            showInvisibles( false ),
        -: 3983:            filenamesAsTags( false ),
        -: 3984:            libIdentify( false ),
        -: 3985:            abortAfter( -1 ),
        -: 3986:            rngSeed( 0 ),
        -: 3987:            verbosity( Verbosity::Normal ),
        -: 3988:            warnings( WarnAbout::Nothing ),
        -: 3989:            showDurations( ShowDurations::DefaultForReporter ),
        -: 3990:            runOrder( RunTests::InDeclarationOrder ),
        -: 3991:            useColour( UseColour::Auto ),
        1: 3992:            waitForKeypress( WaitForKeypress::Never )
        1: 3993:        {}
        -: 3994:
        -: 3995:        bool listTests;
        -: 3996:        bool listTags;
        -: 3997:        bool listReporters;
        -: 3998:        bool listTestNamesOnly;
        -: 3999:        bool listExtraInfo;
        -: 4000:
        -: 4001:        bool showSuccessfulTests;
        -: 4002:        bool shouldDebugBreak;
        -: 4003:        bool noThrow;
        -: 4004:        bool showHelp;
        -: 4005:        bool showInvisibles;
        -: 4006:        bool filenamesAsTags;
        -: 4007:        bool libIdentify;
        -: 4008:
        -: 4009:        int abortAfter;
        -: 4010:        unsigned int rngSeed;
        -: 4011:
        -: 4012:        Verbosity::Level verbosity;
        -: 4013:        WarnAbout::What warnings;
        -: 4014:        ShowDurations::OrNot showDurations;
        -: 4015:        RunTests::InWhatOrder runOrder;
        -: 4016:        UseColour::YesOrNo useColour;
        -: 4017:        WaitForKeypress::When waitForKeypress;
        -: 4018:
        -: 4019:        std::string outputFilename;
        -: 4020:        std::string name;
        -: 4021:        std::string processName;
        -: 4022:
        -: 4023:        std::vector<std::string> reporterNames;
        -: 4024:        std::vector<std::string> testsOrTags;
        -: 4025:        std::vector<std::string> sectionsToRun;
        -: 4026:    };
        -: 4027:
        -: 4028:    class Config : public SharedImpl<IConfig> {
        -: 4029:    private:
        -: 4030:        Config( Config const& other );
        -: 4031:        Config& operator = ( Config const& other );
        -: 4032:        virtual void dummy();
        -: 4033:    public:
        -: 4034:
        -: 4035:        Config()
        -: 4036:        {}
        -: 4037:
        1: 4038:        Config( ConfigData const& data )
        1: 4039:        :   m_data( data ),
        1: 4040:            m_stream( openStream() )
        -: 4041:        {
        1: 4042:            if( !data.testsOrTags.empty() ) {
    #####: 4043:                TestSpecParser parser( ITagAliasRegistry::get() );
    #####: 4044:                for( std::size_t i = 0; i < data.testsOrTags.size(); ++i )
    #####: 4045:                    parser.parse( data.testsOrTags[i] );
    #####: 4046:                m_testSpec = parser.testSpec();
        -: 4047:            }
        1: 4048:        }
        -: 4049:
        2: 4050:        virtual ~Config() {}
------------------
_ZN5Catch6ConfigD0Ev:
        1: 4050:        virtual ~Config() {}
------------------
_ZN5Catch6ConfigD2Ev:
        1: 4050:        virtual ~Config() {}
------------------
        -: 4051:
        -: 4052:        std::string const& getFilename() const {
        -: 4053:            return m_data.outputFilename ;
        -: 4054:        }
        -: 4055:
        1: 4056:        bool listTests() const { return m_data.listTests; }
        1: 4057:        bool listTestNamesOnly() const { return m_data.listTestNamesOnly; }
        1: 4058:        bool listTags() const { return m_data.listTags; }
        1: 4059:        bool listReporters() const { return m_data.listReporters; }
        1: 4060:        bool listExtraInfo() const { return m_data.listExtraInfo; }
        -: 4061:
        -: 4062:        std::string getProcessName() const { return m_data.processName; }
        -: 4063:
        1: 4064:        std::vector<std::string> const& getReporterNames() const { return m_data.reporterNames; }
        1: 4065:        std::vector<std::string> const& getSectionsToRun() const CATCH_OVERRIDE { return m_data.sectionsToRun; }
        -: 4066:
        1: 4067:        virtual TestSpec const& testSpec() const CATCH_OVERRIDE { return m_testSpec; }
        -: 4068:
        -: 4069:        bool showHelp() const { return m_data.showHelp; }
        -: 4070:
        -: 4071:        // IConfig interface
        1: 4072:        virtual bool allowThrows() const CATCH_OVERRIDE                 { return !m_data.noThrow; }
        1: 4073:        virtual std::ostream& stream() const CATCH_OVERRIDE             { return m_stream->stream(); }
       3*: 4074:        virtual std::string name() const CATCH_OVERRIDE                 { return m_data.name.empty() ? m_data.processName : m_data.name; }
        6: 4075:        virtual bool includeSuccessfulResults() const CATCH_OVERRIDE    { return m_data.showSuccessfulTests; }
    #####: 4076:        virtual bool warnAboutMissingAssertions() const CATCH_OVERRIDE  { return m_data.warnings & WarnAbout::NoAssertions; }
       12: 4077:        virtual ShowDurations::OrNot showDurations() const CATCH_OVERRIDE { return m_data.showDurations; }
        3: 4078:        virtual RunTests::InWhatOrder runOrder() const CATCH_OVERRIDE   { return m_data.runOrder; }
        7: 4079:        virtual unsigned int rngSeed() const CATCH_OVERRIDE             { return m_data.rngSeed; }
        1: 4080:        virtual UseColour::YesOrNo useColour() const CATCH_OVERRIDE     { return m_data.useColour; }
    #####: 4081:        virtual bool shouldDebugBreak() const CATCH_OVERRIDE { return m_data.shouldDebugBreak; }
        9: 4082:        virtual int abortAfter() const CATCH_OVERRIDE { return m_data.abortAfter; }
    #####: 4083:        virtual bool showInvisibles() const CATCH_OVERRIDE { return m_data.showInvisibles; }
        -: 4084:
        -: 4085:    private:
        -: 4086:
        1: 4087:        IStream const* openStream() {
        1: 4088:            if( m_data.outputFilename.empty() )
        1: 4089:                return new CoutStream();
    #####: 4090:            else if( m_data.outputFilename[0] == '%' ) {
    #####: 4091:                if( m_data.outputFilename == "%debug" )
    #####: 4092:                    return new DebugOutStream();
        -: 4093:                else
    #####: 4094:                    throw std::domain_error( "Unrecognised stream: " + m_data.outputFilename );
        -: 4095:            }
        -: 4096:            else
    #####: 4097:                return new FileStream( m_data.outputFilename );
        -: 4098:        }
        -: 4099:        ConfigData m_data;
        -: 4100:
        -: 4101:        CATCH_AUTO_PTR( IStream const ) m_stream;
        -: 4102:        TestSpec m_testSpec;
        -: 4103:    };
        -: 4104:
        -: 4105:} // end namespace Catch
        -: 4106:
        -: 4107:// #included from: catch_clara.h
        -: 4108:#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED
        -: 4109:
        -: 4110:// Use Catch's value for console width (store Clara's off to the side, if present)
        -: 4111:#ifdef CLARA_CONFIG_CONSOLE_WIDTH
        -: 4112:#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH CLARA_CONFIG_CONSOLE_WIDTH
        -: 4113:#undef CLARA_CONFIG_CONSOLE_WIDTH
        -: 4114:#endif
        -: 4115:#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH
        -: 4116:
        -: 4117:// Declare Clara inside the Catch namespace
        -: 4118:#define STITCH_CLARA_OPEN_NAMESPACE namespace Catch {
        -: 4119:// #included from: ../external/clara.h
        -: 4120:
        -: 4121:// Version 0.0.2.4
        -: 4122:
        -: 4123:// Only use header guard if we are not using an outer namespace
        -: 4124:#if !defined(TWOBLUECUBES_CLARA_H_INCLUDED) || defined(STITCH_CLARA_OPEN_NAMESPACE)
        -: 4125:
        -: 4126:#ifndef STITCH_CLARA_OPEN_NAMESPACE
        -: 4127:#define TWOBLUECUBES_CLARA_H_INCLUDED
        -: 4128:#define STITCH_CLARA_OPEN_NAMESPACE
        -: 4129:#define STITCH_CLARA_CLOSE_NAMESPACE
        -: 4130:#else
        -: 4131:#define STITCH_CLARA_CLOSE_NAMESPACE }
        -: 4132:#endif
        -: 4133:
        -: 4134:#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE STITCH_CLARA_OPEN_NAMESPACE
        -: 4135:
        -: 4136:// ----------- #included from tbc_text_format.h -----------
        -: 4137:
        -: 4138:// Only use header guard if we are not using an outer namespace
        -: 4139:#if !defined(TBC_TEXT_FORMAT_H_INCLUDED) || defined(STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE)
        -: 4140:#ifndef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 4141:#define TBC_TEXT_FORMAT_H_INCLUDED
        -: 4142:#endif
        -: 4143:
        -: 4144:#include <string>
        -: 4145:#include <vector>
        -: 4146:#include <sstream>
        -: 4147:#include <algorithm>
        -: 4148:#include <cctype>
        -: 4149:
        -: 4150:// Use optional outer namespace
        -: 4151:#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 4152:namespace STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
        -: 4153:#endif
        -: 4154:
        -: 4155:namespace Tbc {
        -: 4156:
        -: 4157:#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
        -: 4158:    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
        -: 4159:#else
        -: 4160:    const unsigned int consoleWidth = 80;
        -: 4161:#endif
        -: 4162:
        -: 4163:    struct TextAttributes {
    #####: 4164:        TextAttributes()
    #####: 4165:        :   initialIndent( std::string::npos ),
        -: 4166:            indent( 0 ),
        -: 4167:            width( consoleWidth-1 ),
    #####: 4168:            tabChar( '\t' )
    #####: 4169:        {}
        -: 4170:
        -: 4171:        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
    #####: 4172:        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
    #####: 4173:        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
        -: 4174:        TextAttributes& setTabChar( char _value )               { tabChar = _value; return *this; }
        -: 4175:
        -: 4176:        std::size_t initialIndent;  // indent of first line, or npos
        -: 4177:        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
        -: 4178:        std::size_t width;          // maximum width of text, including indent. Longer text will wrap
        -: 4179:        char tabChar;               // If this char is seen the indent is changed to current pos
        -: 4180:    };
        -: 4181:
        -: 4182:    class Text {
        -: 4183:    public:
    #####: 4184:        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )
    #####: 4185:        : attr( _attr )
        -: 4186:        {
    #####: 4187:            std::string wrappableChars = " [({.,/|\\-";
    #####: 4188:            std::size_t indent = _attr.initialIndent != std::string::npos
    #####: 4189:                ? _attr.initialIndent
        -: 4190:                : _attr.indent;
    #####: 4191:            std::string remainder = _str;
        -: 4192:
    #####: 4193:            while( !remainder.empty() ) {
    #####: 4194:                if( lines.size() >= 1000 ) {
    #####: 4195:                    lines.push_back( "... message truncated due to excessive size" );
    #####: 4196:                    return;
        -: 4197:                }
    #####: 4198:                std::size_t tabPos = std::string::npos;
    #####: 4199:                std::size_t width = (std::min)( remainder.size(), _attr.width - indent );
    #####: 4200:                std::size_t pos = remainder.find_first_of( '\n' );
    #####: 4201:                if( pos <= width ) {
    #####: 4202:                    width = pos;
        -: 4203:                }
    #####: 4204:                pos = remainder.find_last_of( _attr.tabChar, width );
    #####: 4205:                if( pos != std::string::npos ) {
    #####: 4206:                    tabPos = pos;
    #####: 4207:                    if( remainder[width] == '\n' )
    #####: 4208:                        width--;
    #####: 4209:                    remainder = remainder.substr( 0, tabPos ) + remainder.substr( tabPos+1 );
        -: 4210:                }
        -: 4211:
    #####: 4212:                if( width == remainder.size() ) {
    #####: 4213:                    spliceLine( indent, remainder, width );
        -: 4214:                }
    #####: 4215:                else if( remainder[width] == '\n' ) {
    #####: 4216:                    spliceLine( indent, remainder, width );
    #####: 4217:                    if( width <= 1 || remainder.size() != 1 )
    #####: 4218:                        remainder = remainder.substr( 1 );
    #####: 4219:                    indent = _attr.indent;
        -: 4220:                }
        -: 4221:                else {
    #####: 4222:                    pos = remainder.find_last_of( wrappableChars, width );
    #####: 4223:                    if( pos != std::string::npos && pos > 0 ) {
    #####: 4224:                        spliceLine( indent, remainder, pos );
    #####: 4225:                        if( remainder[0] == ' ' )
    #####: 4226:                            remainder = remainder.substr( 1 );
        -: 4227:                    }
        -: 4228:                    else {
    #####: 4229:                        spliceLine( indent, remainder, width-1 );
    #####: 4230:                        lines.back() += "-";
        -: 4231:                    }
    #####: 4232:                    if( lines.size() == 1 )
    #####: 4233:                        indent = _attr.indent;
    #####: 4234:                    if( tabPos != std::string::npos )
    #####: 4235:                        indent += tabPos;
        -: 4236:                }
        -: 4237:            }
        -: 4238:        }
        -: 4239:
    #####: 4240:        void spliceLine( std::size_t _indent, std::string& _remainder, std::size_t _pos ) {
    #####: 4241:            lines.push_back( std::string( _indent, ' ' ) + _remainder.substr( 0, _pos ) );
    #####: 4242:            _remainder = _remainder.substr( _pos );
    #####: 4243:        }
        -: 4244:
        -: 4245:        typedef std::vector<std::string>::const_iterator const_iterator;
        -: 4246:
        -: 4247:        const_iterator begin() const { return lines.begin(); }
        -: 4248:        const_iterator end() const { return lines.end(); }
        -: 4249:        std::string const& last() const { return lines.back(); }
    #####: 4250:        std::size_t size() const { return lines.size(); }
    #####: 4251:        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }
        -: 4252:        std::string toString() const {
        -: 4253:            std::ostringstream oss;
        -: 4254:            oss << *this;
        -: 4255:            return oss.str();
        -: 4256:        }
        -: 4257:
        -: 4258:        friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {
        -: 4259:            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();
        -: 4260:                it != itEnd; ++it ) {
        -: 4261:                if( it != _text.begin() )
        -: 4262:                    _stream << "\n";
        -: 4263:                _stream << *it;
        -: 4264:            }
        -: 4265:            return _stream;
        -: 4266:        }
        -: 4267:
        -: 4268:    private:
        -: 4269:        std::string str;
        -: 4270:        TextAttributes attr;
        -: 4271:        std::vector<std::string> lines;
        -: 4272:    };
        -: 4273:
        -: 4274:} // end namespace Tbc
        -: 4275:
        -: 4276:#ifdef STITCH_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 4277:} // end outer namespace
        -: 4278:#endif
        -: 4279:
        -: 4280:#endif // TBC_TEXT_FORMAT_H_INCLUDED
        -: 4281:
        -: 4282:// ----------- end of #include from tbc_text_format.h -----------
        -: 4283:// ........... back in clara.h
        -: 4284:
        -: 4285:#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE
        -: 4286:
        -: 4287:// ----------- #included from clara_compilers.h -----------
        -: 4288:
        -: 4289:#ifndef TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
        -: 4290:#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
        -: 4291:
        -: 4292:// Detect a number of compiler features - mostly C++11/14 conformance - by compiler
        -: 4293:// The following features are defined:
        -: 4294://
        -: 4295:// CLARA_CONFIG_CPP11_NULLPTR : is nullptr supported?
        -: 4296:// CLARA_CONFIG_CPP11_NOEXCEPT : is noexcept supported?
        -: 4297:// CLARA_CONFIG_CPP11_GENERATED_METHODS : The delete and default keywords for compiler generated methods
        -: 4298:// CLARA_CONFIG_CPP11_OVERRIDE : is override supported?
        -: 4299:// CLARA_CONFIG_CPP11_UNIQUE_PTR : is unique_ptr supported (otherwise use auto_ptr)
        -: 4300:
        -: 4301:// CLARA_CONFIG_CPP11_OR_GREATER : Is C++11 supported?
        -: 4302:
        -: 4303:// CLARA_CONFIG_VARIADIC_MACROS : are variadic macros supported?
        -: 4304:
        -: 4305:// In general each macro has a _NO_<feature name> form
        -: 4306:// (e.g. CLARA_CONFIG_CPP11_NO_NULLPTR) which disables the feature.
        -: 4307:// Many features, at point of detection, define an _INTERNAL_ macro, so they
        -: 4308:// can be combined, en-mass, with the _NO_ forms later.
        -: 4309:
        -: 4310:// All the C++11 features can be disabled with CLARA_CONFIG_NO_CPP11
        -: 4311:
        -: 4312:#ifdef __clang__
        -: 4313:
        -: 4314:#if __has_feature(cxx_nullptr)
        -: 4315:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 4316:#endif
        -: 4317:
        -: 4318:#if __has_feature(cxx_noexcept)
        -: 4319:#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 4320:#endif
        -: 4321:
        -: 4322:#endif // __clang__
        -: 4323:
        -: 4324:////////////////////////////////////////////////////////////////////////////////
        -: 4325:// GCC
        -: 4326:#ifdef __GNUC__
        -: 4327:
        -: 4328:#if __GNUC__ == 4 && __GNUC_MINOR__ >= 6 && defined(__GXX_EXPERIMENTAL_CXX0X__)
        -: 4329:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 4330:#endif
        -: 4331:
        -: 4332:// - otherwise more recent versions define __cplusplus >= 201103L
        -: 4333:// and will get picked up below
        -: 4334:
        -: 4335:#endif // __GNUC__
        -: 4336:
        -: 4337:////////////////////////////////////////////////////////////////////////////////
        -: 4338:// Visual C++
        -: 4339:#ifdef _MSC_VER
        -: 4340:
        -: 4341:#if (_MSC_VER >= 1600)
        -: 4342:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 4343:#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -: 4344:#endif
        -: 4345:
        -: 4346:#if (_MSC_VER >= 1900 ) // (VC++ 13 (VS2015))
        -: 4347:#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 4348:#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -: 4349:#endif
        -: 4350:
        -: 4351:#endif // _MSC_VER
        -: 4352:
        -: 4353:////////////////////////////////////////////////////////////////////////////////
        -: 4354:// C++ language feature support
        -: 4355:
        -: 4356:// catch all support for C++11
        -: 4357:#if defined(__cplusplus) && __cplusplus >= 201103L
        -: 4358:
        -: 4359:#define CLARA_CPP11_OR_GREATER
        -: 4360:
        -: 4361:#if !defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR)
        -: 4362:#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR
        -: 4363:#endif
        -: 4364:
        -: 4365:#ifndef CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 4366:#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT
        -: 4367:#endif
        -: 4368:
        -: 4369:#ifndef CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -: 4370:#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS
        -: 4371:#endif
        -: 4372:
        -: 4373:#if !defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE)
        -: 4374:#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE
        -: 4375:#endif
        -: 4376:#if !defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR)
        -: 4377:#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR
        -: 4378:#endif
        -: 4379:
        -: 4380:#endif // __cplusplus >= 201103L
        -: 4381:
        -: 4382:// Now set the actual defines based on the above + anything the user has configured
        -: 4383:#if defined(CLARA_INTERNAL_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NO_NULLPTR) && !defined(CLARA_CONFIG_CPP11_NULLPTR) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 4384:#define CLARA_CONFIG_CPP11_NULLPTR
        -: 4385:#endif
        -: 4386:#if defined(CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NO_NOEXCEPT) && !defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 4387:#define CLARA_CONFIG_CPP11_NOEXCEPT
        -: 4388:#endif
        -: 4389:#if defined(CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_NO_GENERATED_METHODS) && !defined(CLARA_CONFIG_CPP11_GENERATED_METHODS) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 4390:#define CLARA_CONFIG_CPP11_GENERATED_METHODS
        -: 4391:#endif
        -: 4392:#if defined(CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_OVERRIDE) && !defined(CLARA_CONFIG_CPP11_OVERRIDE) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 4393:#define CLARA_CONFIG_CPP11_OVERRIDE
        -: 4394:#endif
        -: 4395:#if defined(CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_UNIQUE_PTR) && !defined(CLARA_CONFIG_CPP11_UNIQUE_PTR) && !defined(CLARA_CONFIG_NO_CPP11)
        -: 4396:#define CLARA_CONFIG_CPP11_UNIQUE_PTR
        -: 4397:#endif
        -: 4398:
        -: 4399:// noexcept support:
        -: 4400:#if defined(CLARA_CONFIG_CPP11_NOEXCEPT) && !defined(CLARA_NOEXCEPT)
        -: 4401:#define CLARA_NOEXCEPT noexcept
        -: 4402:#  define CLARA_NOEXCEPT_IS(x) noexcept(x)
        -: 4403:#else
        -: 4404:#define CLARA_NOEXCEPT throw()
        -: 4405:#  define CLARA_NOEXCEPT_IS(x)
        -: 4406:#endif
        -: 4407:
        -: 4408:// nullptr support
        -: 4409:#ifdef CLARA_CONFIG_CPP11_NULLPTR
        -: 4410:#define CLARA_NULL nullptr
        -: 4411:#else
        -: 4412:#define CLARA_NULL NULL
        -: 4413:#endif
        -: 4414:
        -: 4415:// override support
        -: 4416:#ifdef CLARA_CONFIG_CPP11_OVERRIDE
        -: 4417:#define CLARA_OVERRIDE override
        -: 4418:#else
        -: 4419:#define CLARA_OVERRIDE
        -: 4420:#endif
        -: 4421:
        -: 4422:// unique_ptr support
        -: 4423:#ifdef CLARA_CONFIG_CPP11_UNIQUE_PTR
        -: 4424:#   define CLARA_AUTO_PTR( T ) std::unique_ptr<T>
        -: 4425:#else
        -: 4426:#   define CLARA_AUTO_PTR( T ) std::auto_ptr<T>
        -: 4427:#endif
        -: 4428:
        -: 4429:#endif // TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED
        -: 4430:
        -: 4431:// ----------- end of #include from clara_compilers.h -----------
        -: 4432:// ........... back in clara.h
        -: 4433:
        -: 4434:#include <map>
        -: 4435:#include <stdexcept>
        -: 4436:#include <memory>
        -: 4437:
        -: 4438:#if defined(WIN32) || defined(__WIN32__) || defined(_WIN32) || defined(_MSC_VER)
        -: 4439:#define CLARA_PLATFORM_WINDOWS
        -: 4440:#endif
        -: 4441:
        -: 4442:// Use optional outer namespace
        -: 4443:#ifdef STITCH_CLARA_OPEN_NAMESPACE
        -: 4444:STITCH_CLARA_OPEN_NAMESPACE
        -: 4445:#endif
        -: 4446:
        -: 4447:namespace Clara {
        -: 4448:
        -: 4449:    struct UnpositionalTag {};
        -: 4450:
        -: 4451:    extern UnpositionalTag _;
        -: 4452:
        -: 4453:#ifdef CLARA_CONFIG_MAIN
        -: 4454:    UnpositionalTag _;
        -: 4455:#endif
        -: 4456:
        -: 4457:    namespace Detail {
        -: 4458:
        -: 4459:#ifdef CLARA_CONSOLE_WIDTH
        -: 4460:    const unsigned int consoleWidth = CLARA_CONFIG_CONSOLE_WIDTH;
        -: 4461:#else
        -: 4462:    const unsigned int consoleWidth = 80;
        -: 4463:#endif
        -: 4464:
        -: 4465:        using namespace Tbc;
        -: 4466:
       62: 4467:        inline bool startsWith( std::string const& str, std::string const& prefix ) {
       62: 4468:            return str.size() >= prefix.size() && str.substr( 0, prefix.size() ) == prefix;
        -: 4469:        }
        -: 4470:
        -: 4471:        template<typename T> struct RemoveConstRef{ typedef T type; };
        -: 4472:        template<typename T> struct RemoveConstRef<T&>{ typedef T type; };
        -: 4473:        template<typename T> struct RemoveConstRef<T const&>{ typedef T type; };
        -: 4474:        template<typename T> struct RemoveConstRef<T const>{ typedef T type; };
        -: 4475:
        -: 4476:        template<typename T>    struct IsBool       { static const bool value = false; };
        -: 4477:        template<>              struct IsBool<bool> { static const bool value = true; };
        -: 4478:
        -: 4479:        template<typename T>
    #####: 4480:        void convertInto( std::string const& _source, T& _dest ) {
    #####: 4481:            std::stringstream ss;
    #####: 4482:            ss << _source;
    #####: 4483:            ss >> _dest;
    #####: 4484:            if( ss.fail() )
    #####: 4485:                throw std::runtime_error( "Unable to convert " + _source + " to destination type" );
    #####: 4486:        }
        1: 4487:        inline void convertInto( std::string const& _source, std::string& _dest ) {
        1: 4488:            _dest = _source;
        1: 4489:        }
    #####: 4490:        char toLowerCh(char c) {
    #####: 4491:            return static_cast<char>( std::tolower( c ) );
        -: 4492:        }
    #####: 4493:        inline void convertInto( std::string const& _source, bool& _dest ) {
    #####: 4494:            std::string sourceLC = _source;
    #####: 4495:            std::transform( sourceLC.begin(), sourceLC.end(), sourceLC.begin(), toLowerCh );
    #####: 4496:            if( sourceLC == "y" || sourceLC == "1" || sourceLC == "true" || sourceLC == "yes" || sourceLC == "on" )
    #####: 4497:                _dest = true;
    #####: 4498:            else if( sourceLC == "n" || sourceLC == "0" || sourceLC == "false" || sourceLC == "no" || sourceLC == "off" )
    #####: 4499:                _dest = false;
        -: 4500:            else
    #####: 4501:                throw std::runtime_error( "Expected a boolean value but did not recognise:\n  '" + _source + "'" );
    #####: 4502:        }
        -: 4503:
        -: 4504:        template<typename ConfigT>
        -: 4505:        struct IArgFunction {
      88*: 4506:            virtual ~IArgFunction() {}
------------------
_ZN5Catch5Clara6Detail12IArgFunctionINS_10ConfigDataEED0Ev:
    #####: 4506:            virtual ~IArgFunction() {}
------------------
_ZN5Catch5Clara6Detail12IArgFunctionINS_10ConfigDataEED2Ev:
       88: 4506:            virtual ~IArgFunction() {}
------------------
        -: 4507:#ifdef CLARA_CONFIG_CPP11_GENERATED_METHODS
       29: 4508:            IArgFunction()                      = default;
       59: 4509:            IArgFunction( IArgFunction const& ) = default;
        -: 4510:#endif
        -: 4511:            virtual void set( ConfigT& config, std::string const& value ) const = 0;
        -: 4512:            virtual bool takesArg() const = 0;
        -: 4513:            virtual IArgFunction* clone() const = 0;
        -: 4514:        };
        -: 4515:
        -: 4516:        template<typename ConfigT>
        -: 4517:        class BoundArgFunction {
        -: 4518:        public:
       27: 4519:            BoundArgFunction() : functionObj( CLARA_NULL ) {}
       29: 4520:            BoundArgFunction( IArgFunction<ConfigT>* _functionObj ) : functionObj( _functionObj ) {}
       57: 4521:            BoundArgFunction( BoundArgFunction const& other ) : functionObj( other.functionObj ? other.functionObj->clone() : CLARA_NULL ) {}
       28: 4522:            BoundArgFunction& operator = ( BoundArgFunction const& other ) {
      28*: 4523:                IArgFunction<ConfigT>* newFunctionObj = other.functionObj ? other.functionObj->clone() : CLARA_NULL;
       28: 4524:                delete functionObj;
       28: 4525:                functionObj = newFunctionObj;
       28: 4526:                return *this;
        -: 4527:            }
      113: 4528:            ~BoundArgFunction() { delete functionObj; }
        -: 4529:
        1: 4530:            void set( ConfigT& config, std::string const& value ) const {
        1: 4531:                functionObj->set( config, value );
        1: 4532:            }
        -: 4533:            bool takesArg() const { return functionObj->takesArg(); }
        -: 4534:
       26: 4535:            bool isSet() const {
       26: 4536:                return functionObj != CLARA_NULL;
        -: 4537:            }
        -: 4538:        private:
        -: 4539:            IArgFunction<ConfigT>* functionObj;
        -: 4540:        };
        -: 4541:
        -: 4542:        template<typename C>
        -: 4543:        struct NullBinder : IArgFunction<C>{
    #####: 4544:            virtual void set( C&, std::string const& ) const {}
    #####: 4545:            virtual bool takesArg() const { return true; }
    #####: 4546:            virtual IArgFunction<C>* clone() const { return new NullBinder( *this ); }
        -: 4547:        };
        -: 4548:
        -: 4549:        template<typename C, typename M>
        -: 4550:        struct BoundDataMember : IArgFunction<C>{
       15: 4551:            BoundDataMember( M C::* _member ) : member( _member ) {}
------------------
_ZN5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataEbEC2EMS3_b:
       12: 4551:            BoundDataMember( M C::* _member ) : member( _member ) {}
------------------
_ZN5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EMS3_S9_:
        3: 4551:            BoundDataMember( M C::* _member ) : member( _member ) {}
------------------
       1*: 4552:            virtual void set( C& p, std::string const& stringValue ) const {
       1*: 4553:                convertInto( stringValue, p.*member );
       1*: 4554:            }
------------------
_ZNK5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3setERS3_RKS9_:
        1: 4552:            virtual void set( C& p, std::string const& stringValue ) const {
        1: 4553:                convertInto( stringValue, p.*member );
        1: 4554:            }
------------------
_ZNK5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataEbE3setERS3_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 4552:            virtual void set( C& p, std::string const& stringValue ) const {
    #####: 4553:                convertInto( stringValue, p.*member );
    #####: 4554:            }
------------------
    #####: 4555:            virtual bool takesArg() const { return !IsBool<M>::value; }
------------------
_ZNK5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE8takesArgEv:
    #####: 4555:            virtual bool takesArg() const { return !IsBool<M>::value; }
------------------
_ZNK5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataEbE8takesArgEv:
    #####: 4555:            virtual bool takesArg() const { return !IsBool<M>::value; }
------------------
       40: 4556:            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }
------------------
_ZNK5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5cloneEv:
        6: 4556:            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }
------------------
_ZNK5Catch5Clara6Detail15BoundDataMemberINS_10ConfigDataEbE5cloneEv:
       34: 4556:            virtual IArgFunction<C>* clone() const { return new BoundDataMember( *this ); }
------------------
        -: 4557:            M C::* member;
        -: 4558:        };
        -: 4559:        template<typename C, typename M>
        -: 4560:        struct BoundUnaryMethod : IArgFunction<C>{
        -: 4561:            BoundUnaryMethod( void (C::*_member)( M ) ) : member( _member ) {}
        -: 4562:            virtual void set( C& p, std::string const& stringValue ) const {
        -: 4563:                typename RemoveConstRef<M>::type value;
        -: 4564:                convertInto( stringValue, value );
        -: 4565:                (p.*member)( value );
        -: 4566:            }
        -: 4567:            virtual bool takesArg() const { return !IsBool<M>::value; }
        -: 4568:            virtual IArgFunction<C>* clone() const { return new BoundUnaryMethod( *this ); }
        -: 4569:            void (C::*member)( M );
        -: 4570:        };
        -: 4571:        template<typename C>
        -: 4572:        struct BoundNullaryMethod : IArgFunction<C>{
        -: 4573:            BoundNullaryMethod( void (C::*_member)() ) : member( _member ) {}
        -: 4574:            virtual void set( C& p, std::string const& stringValue ) const {
        -: 4575:                bool value;
        -: 4576:                convertInto( stringValue, value );
        -: 4577:                if( value )
        -: 4578:                    (p.*member)();
        -: 4579:            }
        -: 4580:            virtual bool takesArg() const { return false; }
        -: 4581:            virtual IArgFunction<C>* clone() const { return new BoundNullaryMethod( *this ); }
        -: 4582:            void (C::*member)();
        -: 4583:        };
        -: 4584:
        -: 4585:        template<typename C>
        -: 4586:        struct BoundUnaryFunction : IArgFunction<C>{
        2: 4587:            BoundUnaryFunction( void (*_function)( C& ) ) : function( _function ) {}
    #####: 4588:            virtual void set( C& obj, std::string const& stringValue ) const {
        -: 4589:                bool value;
    #####: 4590:                convertInto( stringValue, value );
    #####: 4591:                if( value )
    #####: 4592:                    function( obj );
    #####: 4593:            }
    #####: 4594:            virtual bool takesArg() const { return false; }
        3: 4595:            virtual IArgFunction<C>* clone() const { return new BoundUnaryFunction( *this ); }
        -: 4596:            void (*function)( C& );
        -: 4597:        };
        -: 4598:
        -: 4599:        template<typename C, typename T>
        -: 4600:        struct BoundBinaryFunction : IArgFunction<C>{
       11: 4601:            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
------------------
_ZN5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEbEC2EPFvRS3_bE:
        1: 4601:            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
------------------
_ZN5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEiEC2EPFvRS3_iE:
        1: 4601:            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
------------------
_ZN5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEC2EPFvRS3_SB_E:
        9: 4601:            BoundBinaryFunction( void (*_function)( C&, T ) ) : function( _function ) {}
------------------
    #####: 4602:            virtual void set( C& obj, std::string const& stringValue ) const {
    #####: 4603:                typename RemoveConstRef<T>::type value;
    #####: 4604:                convertInto( stringValue, value );
    #####: 4605:                function( obj, value );
    #####: 4606:            }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE3setERS3_SB_:
    #####: 4602:            virtual void set( C& obj, std::string const& stringValue ) const {
    #####: 4603:                typename RemoveConstRef<T>::type value;
    #####: 4604:                convertInto( stringValue, value );
    #####: 4605:                function( obj, value );
    #####: 4606:            }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEiE3setERS3_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 4602:            virtual void set( C& obj, std::string const& stringValue ) const {
        -: 4603:                typename RemoveConstRef<T>::type value;
    #####: 4604:                convertInto( stringValue, value );
    #####: 4605:                function( obj, value );
    #####: 4606:            }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEbE3setERS3_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
    #####: 4602:            virtual void set( C& obj, std::string const& stringValue ) const {
        -: 4603:                typename RemoveConstRef<T>::type value;
    #####: 4604:                convertInto( stringValue, value );
    #####: 4605:                function( obj, value );
    #####: 4606:            }
------------------
    #####: 4607:            virtual bool takesArg() const { return !IsBool<T>::value; }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE8takesArgEv:
    #####: 4607:            virtual bool takesArg() const { return !IsBool<T>::value; }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEiE8takesArgEv:
    #####: 4607:            virtual bool takesArg() const { return !IsBool<T>::value; }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEbE8takesArgEv:
    #####: 4607:            virtual bool takesArg() const { return !IsBool<T>::value; }
------------------
       16: 4608:            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEE5cloneEv:
       12: 4608:            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEiE5cloneEv:
        2: 4608:            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
------------------
_ZNK5Catch5Clara6Detail19BoundBinaryFunctionINS_10ConfigDataEbE5cloneEv:
        2: 4608:            virtual IArgFunction<C>* clone() const { return new BoundBinaryFunction( *this ); }
------------------
        -: 4609:            void (*function)( C&, T );
        -: 4610:        };
        -: 4611:
        -: 4612:    } // namespace Detail
        -: 4613:
        1: 4614:    inline std::vector<std::string> argsToVector( int argc, char const* const* const argv ) {
        1: 4615:        std::vector<std::string> args( static_cast<std::size_t>( argc ) );
        2: 4616:        for( std::size_t i = 0; i < static_cast<std::size_t>( argc ); ++i )
        1: 4617:            args[i] = argv[i];
        -: 4618:
        1: 4619:        return args;
        -: 4620:    }
        -: 4621:
        -: 4622:    class Parser {
        -: 4623:        enum Mode { None, MaybeShortOpt, SlashOpt, ShortOpt, LongOpt, Positional };
        -: 4624:        Mode mode;
        -: 4625:        std::size_t from;
        -: 4626:        bool inQuotes;
        -: 4627:    public:
        -: 4628:
        -: 4629:        struct Token {
        -: 4630:            enum Type { Positional, ShortOpt, LongOpt };
    #####: 4631:            Token( Type _type, std::string const& _data ) : type( _type ), data( _data ) {}
        -: 4632:            Type type;
        -: 4633:            std::string data;
        -: 4634:        };
        -: 4635:
        1: 4636:        Parser() : mode( None ), from( 0 ), inQuotes( false ){}
        -: 4637:
        1: 4638:        void parseIntoTokens( std::vector<std::string> const& args, std::vector<Token>& tokens ) {
        2: 4639:            const std::string doubleDash = "--";
       1*: 4640:            for( std::size_t i = 1; i < args.size() && args[i] != doubleDash; ++i )
    #####: 4641:                parseIntoTokens( args[i], tokens);
        1: 4642:        }
        -: 4643:
    #####: 4644:        void parseIntoTokens( std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4645:            for( std::size_t i = 0; i < arg.size(); ++i ) {
    #####: 4646:                char c = arg[i];
    #####: 4647:                if( c == '"' )
    #####: 4648:                    inQuotes = !inQuotes;
    #####: 4649:                mode = handleMode( i, c, arg, tokens );
        -: 4650:            }
    #####: 4651:            mode = handleMode( arg.size(), '\0', arg, tokens );
    #####: 4652:        }
    #####: 4653:        Mode handleMode( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4654:            switch( mode ) {
    #####: 4655:                case None: return handleNone( i, c );
    #####: 4656:                case MaybeShortOpt: return handleMaybeShortOpt( i, c );
    #####: 4657:                case ShortOpt:
        -: 4658:                case LongOpt:
    #####: 4659:                case SlashOpt: return handleOpt( i, c, arg, tokens );
    #####: 4660:                case Positional: return handlePositional( i, c, arg, tokens );
    #####: 4661:                default: throw std::logic_error( "Unknown mode" );
        -: 4662:            }
        -: 4663:        }
        -: 4664:
    #####: 4665:        Mode handleNone( std::size_t i, char c ) {
    #####: 4666:            if( inQuotes ) {
    #####: 4667:                from = i;
    #####: 4668:                return Positional;
        -: 4669:            }
    #####: 4670:            switch( c ) {
    #####: 4671:                case '-': return MaybeShortOpt;
        -: 4672:#ifdef CLARA_PLATFORM_WINDOWS
        -: 4673:                case '/': from = i+1; return SlashOpt;
        -: 4674:#endif
    #####: 4675:                default: from = i; return Positional;
        -: 4676:            }
        -: 4677:        }
    #####: 4678:        Mode handleMaybeShortOpt( std::size_t i, char c ) {
    #####: 4679:            switch( c ) {
    #####: 4680:                case '-': from = i+1; return LongOpt;
    #####: 4681:                default: from = i; return ShortOpt;
        -: 4682:            }
        -: 4683:        }
        -: 4684:
    #####: 4685:        Mode handleOpt( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4686:            if( std::string( ":=\0", 3 ).find( c ) == std::string::npos )
    #####: 4687:                return mode;
        -: 4688:
    #####: 4689:            std::string optName = arg.substr( from, i-from );
    #####: 4690:            if( mode == ShortOpt )
    #####: 4691:                for( std::size_t j = 0; j < optName.size(); ++j )
    #####: 4692:                    tokens.push_back( Token( Token::ShortOpt, optName.substr( j, 1 ) ) );
    #####: 4693:            else if( mode == SlashOpt && optName.size() == 1 )
    #####: 4694:                tokens.push_back( Token( Token::ShortOpt, optName ) );
        -: 4695:            else
    #####: 4696:                tokens.push_back( Token( Token::LongOpt, optName ) );
    #####: 4697:            return None;
        -: 4698:        }
    #####: 4699:        Mode handlePositional( std::size_t i, char c, std::string const& arg, std::vector<Token>& tokens ) {
    #####: 4700:            if( inQuotes || std::string( "\0", 1 ).find( c ) == std::string::npos )
    #####: 4701:                return mode;
        -: 4702:
    #####: 4703:            std::string data = arg.substr( from, i-from );
    #####: 4704:            tokens.push_back( Token( Token::Positional, data ) );
    #####: 4705:            return None;
        -: 4706:        }
        -: 4707:    };
        -: 4708:
        -: 4709:    template<typename ConfigT>
        -: 4710:    struct CommonArgProperties {
       27: 4711:        CommonArgProperties() {}
        -: 4712:        CommonArgProperties( Detail::BoundArgFunction<ConfigT> const& _boundField ) : boundField( _boundField ) {}
        -: 4713:
        -: 4714:        Detail::BoundArgFunction<ConfigT> boundField;
        -: 4715:        std::string description;
        -: 4716:        std::string detail;
        -: 4717:        std::string placeholder; // Only value if boundField takes an arg
        -: 4718:
    #####: 4719:        bool takesArg() const {
    #####: 4720:            return !placeholder.empty();
        -: 4721:        }
       26: 4722:        void validate() const {
       26: 4723:            if( !boundField.isSet() )
    #####: 4724:                throw std::logic_error( "option not bound" );
       26: 4725:        }
        -: 4726:    };
        -: 4727:    struct OptionArgProperties {
        -: 4728:        std::vector<std::string> shortNames;
        -: 4729:        std::string longName;
        -: 4730:
    #####: 4731:        bool hasShortName( std::string const& shortName ) const {
    #####: 4732:            return std::find( shortNames.begin(), shortNames.end(), shortName ) != shortNames.end();
        -: 4733:        }
    #####: 4734:        bool hasLongName( std::string const& _longName ) const {
    #####: 4735:            return _longName == longName;
        -: 4736:        }
        -: 4737:    };
        -: 4738:    struct PositionalArgProperties {
       27: 4739:        PositionalArgProperties() : position( -1 ) {}
        -: 4740:        int position; // -1 means non-positional (floating)
        -: 4741:
        -: 4742:        bool isFixedPositional() const {
        -: 4743:            return position != -1;
        -: 4744:        }
        -: 4745:    };
        -: 4746:
        -: 4747:    template<typename ConfigT>
        -: 4748:    class CommandLine {
        -: 4749:
        -: 4750:        struct Arg : CommonArgProperties<ConfigT>, OptionArgProperties, PositionalArgProperties {
       27: 4751:            Arg() {}
        -: 4752:            Arg( Detail::BoundArgFunction<ConfigT> const& _boundField ) : CommonArgProperties<ConfigT>( _boundField ) {}
        -: 4753:
        -: 4754:            using CommonArgProperties<ConfigT>::placeholder; // !TBD
        -: 4755:
        -: 4756:            std::string dbgName() const {
        -: 4757:                if( !longName.empty() )
        -: 4758:                    return "--" + longName;
        -: 4759:                if( !shortNames.empty() )
        -: 4760:                    return "-" + shortNames[0];
        -: 4761:                return "positional args";
        -: 4762:            }
    #####: 4763:            std::string commands() const {
    #####: 4764:                std::ostringstream oss;
    #####: 4765:                bool first = true;
    #####: 4766:                std::vector<std::string>::const_iterator it = shortNames.begin(), itEnd = shortNames.end();
    #####: 4767:                for(; it != itEnd; ++it ) {
    #####: 4768:                    if( first )
    #####: 4769:                        first = false;
        -: 4770:                    else
    #####: 4771:                        oss << ", ";
    #####: 4772:                    oss << "-" << *it;
        -: 4773:                }
    #####: 4774:                if( !longName.empty() ) {
    #####: 4775:                    if( !first )
    #####: 4776:                        oss << ", ";
    #####: 4777:                    oss << "--" << longName;
        -: 4778:                }
    #####: 4779:                if( !placeholder.empty() )
    #####: 4780:                    oss << " <" << placeholder << ">";
    #####: 4781:                return oss.str();
        -: 4782:            }
        -: 4783:        };
        -: 4784:
        -: 4785:        typedef CLARA_AUTO_PTR( Arg ) ArgAutoPtr;
        -: 4786:
       44: 4787:        friend void addOptName( Arg& arg, std::string const& optName )
        -: 4788:        {
       44: 4789:            if( optName.empty() )
    #####: 4790:                return;
       44: 4791:            if( Detail::startsWith( optName, "--" ) ) {
       26: 4792:                if( !arg.longName.empty() )
        -: 4793:                    throw std::logic_error( "Only one long opt may be specified. '"
    #####: 4794:                        + arg.longName
        -: 4795:                        + "' already specified, now attempting to add '"
    #####: 4796:                        + optName + "'" );
       26: 4797:                arg.longName = optName.substr( 2 );
        -: 4798:            }
       18: 4799:            else if( Detail::startsWith( optName, "-" ) )
       18: 4800:                arg.shortNames.push_back( optName.substr( 1 ) );
        -: 4801:            else
    #####: 4802:                throw std::logic_error( "option must begin with - or --. Option was: '" + optName + "'" );
        -: 4803:        }
        -: 4804:        friend void setPositionalArg( Arg& arg, int position )
        -: 4805:        {
        -: 4806:            arg.position = position;
        -: 4807:        }
        -: 4808:
        -: 4809:        class ArgBuilder {
        -: 4810:        public:
       27: 4811:            ArgBuilder( Arg* arg ) : m_arg( arg ) {}
        -: 4812:
        -: 4813:            // Bind a non-boolean data member (requires placeholder string)
        -: 4814:            template<typename C, typename M>
        2: 4815:            void bind( M C::* field, std::string const& placeholder ) {
        2: 4816:                m_arg->boundField = new Detail::BoundDataMember<C,M>( field );
        2: 4817:                m_arg->placeholder = placeholder;
        2: 4818:            }
        -: 4819:            // Bind a boolean data member (no placeholder required)
        -: 4820:            template<typename C>
       12: 4821:            void bind( bool C::* field ) {
       12: 4822:                m_arg->boundField = new Detail::BoundDataMember<C,bool>( field );
       12: 4823:            }
        -: 4824:
        -: 4825:            // Bind a method taking a single, non-boolean argument (requires a placeholder string)
        -: 4826:            template<typename C, typename M>
        -: 4827:            void bind( void (C::* unaryMethod)( M ), std::string const& placeholder ) {
        -: 4828:                m_arg->boundField = new Detail::BoundUnaryMethod<C,M>( unaryMethod );
        -: 4829:                m_arg->placeholder = placeholder;
        -: 4830:            }
        -: 4831:
        -: 4832:            // Bind a method taking a single, boolean argument (no placeholder string required)
        -: 4833:            template<typename C>
        -: 4834:            void bind( void (C::* unaryMethod)( bool ) ) {
        -: 4835:                m_arg->boundField = new Detail::BoundUnaryMethod<C,bool>( unaryMethod );
        -: 4836:            }
        -: 4837:
        -: 4838:            // Bind a method that takes no arguments (will be called if opt is present)
        -: 4839:            template<typename C>
        -: 4840:            void bind( void (C::* nullaryMethod)() ) {
        -: 4841:                m_arg->boundField = new Detail::BoundNullaryMethod<C>( nullaryMethod );
        -: 4842:            }
        -: 4843:
        -: 4844:            // Bind a free function taking a single argument - the object to operate on (no placeholder string required)
        -: 4845:            template<typename C>
        2: 4846:            void bind( void (* unaryFunction)( C& ) ) {
        2: 4847:                m_arg->boundField = new Detail::BoundUnaryFunction<C>( unaryFunction );
        2: 4848:            }
        -: 4849:
        -: 4850:            // Bind a free function taking a single argument - the object to operate on (requires a placeholder string)
        -: 4851:            template<typename C, typename T>
       11: 4852:            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {
       11: 4853:                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );
       11: 4854:                m_arg->placeholder = placeholder;
       11: 4855:            }
------------------
_ZN5Catch5Clara11CommandLineINS_10ConfigDataEE10ArgBuilder4bindIS2_bEEvPFvRT_T0_ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 4852:            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {
        1: 4853:                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );
        1: 4854:                m_arg->placeholder = placeholder;
        1: 4855:            }
------------------
_ZN5Catch5Clara11CommandLineINS_10ConfigDataEE10ArgBuilder4bindIS2_iEEvPFvRT_T0_ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 4852:            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {
        1: 4853:                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );
        1: 4854:                m_arg->placeholder = placeholder;
        1: 4855:            }
------------------
_ZN5Catch5Clara11CommandLineINS_10ConfigDataEE10ArgBuilder4bindIS2_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEvPFvRT_T0_ESD_:
        9: 4852:            void bind( void (* binaryFunction)( C&, T ), std::string const& placeholder ) {
        9: 4853:                m_arg->boundField = new Detail::BoundBinaryFunction<C, T>( binaryFunction );
        9: 4854:                m_arg->placeholder = placeholder;
        9: 4855:            }
------------------
        -: 4856:
       27: 4857:            ArgBuilder& describe( std::string const& description ) {
       27: 4858:                m_arg->description = description;
       27: 4859:                return *this;
        -: 4860:            }
        -: 4861:            ArgBuilder& detail( std::string const& detail ) {
        -: 4862:                m_arg->detail = detail;
        -: 4863:                return *this;
        -: 4864:            }
        -: 4865:
        -: 4866:        protected:
        -: 4867:            Arg* m_arg;
        -: 4868:        };
        -: 4869:
        -: 4870:        class OptBuilder : public ArgBuilder {
        -: 4871:        public:
       26: 4872:            OptBuilder( Arg* arg ) : ArgBuilder( arg ) {}
        -: 4873:            OptBuilder( OptBuilder& other ) : ArgBuilder( other ) {}
        -: 4874:
       18: 4875:            OptBuilder& operator[]( std::string const& optName ) {
       18: 4876:                addOptName( *ArgBuilder::m_arg, optName );
       18: 4877:                return *this;
        -: 4878:            }
        -: 4879:        };
        -: 4880:
        -: 4881:    public:
        -: 4882:
        1: 4883:        CommandLine()
        1: 4884:        :   m_boundProcessName( new Detail::NullBinder<ConfigT>() ),
        -: 4885:            m_highestSpecifiedArgPosition( 0 ),
        2: 4886:            m_throwOnUnrecognisedTokens( false )
        1: 4887:        {}
        -: 4888:        CommandLine( CommandLine const& other )
        -: 4889:        :   m_boundProcessName( other.m_boundProcessName ),
        -: 4890:            m_options ( other.m_options ),
        -: 4891:            m_positionalArgs( other.m_positionalArgs ),
        -: 4892:            m_highestSpecifiedArgPosition( other.m_highestSpecifiedArgPosition ),
        -: 4893:            m_throwOnUnrecognisedTokens( other.m_throwOnUnrecognisedTokens )
        -: 4894:        {
        -: 4895:            if( other.m_floatingArg.get() )
        -: 4896:                m_floatingArg.reset( new Arg( *other.m_floatingArg ) );
        -: 4897:        }
        -: 4898:
        1: 4899:        CommandLine& setThrowOnUnrecognisedTokens( bool shouldThrow = true ) {
        1: 4900:            m_throwOnUnrecognisedTokens = shouldThrow;
        1: 4901:            return *this;
        -: 4902:        }
        -: 4903:
       26: 4904:        OptBuilder operator[]( std::string const& optName ) {
       26: 4905:            m_options.push_back( Arg() );
       26: 4906:            addOptName( m_options.back(), optName );
       26: 4907:            OptBuilder builder( &m_options.back() );
       26: 4908:            return builder;
        -: 4909:        }
        -: 4910:
        -: 4911:        ArgBuilder operator[]( int position ) {
        -: 4912:            m_positionalArgs.insert( std::make_pair( position, Arg() ) );
        -: 4913:            if( position > m_highestSpecifiedArgPosition )
        -: 4914:                m_highestSpecifiedArgPosition = position;
        -: 4915:            setPositionalArg( m_positionalArgs[position], position );
        -: 4916:            ArgBuilder builder( &m_positionalArgs[position] );
        -: 4917:            return builder;
        -: 4918:        }
        -: 4919:
        -: 4920:        // Invoke this with the _ instance
        1: 4921:        ArgBuilder operator[]( UnpositionalTag ) {
        1: 4922:            if( m_floatingArg.get() )
    #####: 4923:                throw std::logic_error( "Only one unpositional argument can be added" );
        1: 4924:            m_floatingArg.reset( new Arg() );
        1: 4925:            ArgBuilder builder( m_floatingArg.get() );
        1: 4926:            return builder;
        -: 4927:        }
        -: 4928:
        -: 4929:        template<typename C, typename M>
        1: 4930:        void bindProcessName( M C::* field ) {
        1: 4931:            m_boundProcessName = new Detail::BoundDataMember<C,M>( field );
        1: 4932:        }
        -: 4933:        template<typename C, typename M>
        -: 4934:        void bindProcessName( void (C::*_unaryMethod)( M ) ) {
        -: 4935:            m_boundProcessName = new Detail::BoundUnaryMethod<C,M>( _unaryMethod );
        -: 4936:        }
        -: 4937:
    #####: 4938:        void optUsage( std::ostream& os, std::size_t indent = 0, std::size_t width = Detail::consoleWidth ) const {
    #####: 4939:            typename std::vector<Arg>::const_iterator itBegin = m_options.begin(), itEnd = m_options.end(), it;
    #####: 4940:            std::size_t maxWidth = 0;
    #####: 4941:            for( it = itBegin; it != itEnd; ++it )
    #####: 4942:                maxWidth = (std::max)( maxWidth, it->commands().size() );
        -: 4943:
    #####: 4944:            for( it = itBegin; it != itEnd; ++it ) {
    #####: 4945:                Detail::Text usage( it->commands(), Detail::TextAttributes()
    #####: 4946:                                                        .setWidth( maxWidth+indent )
    #####: 4947:                                                        .setIndent( indent ) );
    #####: 4948:                Detail::Text desc( it->description, Detail::TextAttributes()
    #####: 4949:                                                        .setWidth( width - maxWidth - 3 ) );
        -: 4950:
    #####: 4951:                for( std::size_t i = 0; i < (std::max)( usage.size(), desc.size() ); ++i ) {
    #####: 4952:                    std::string usageCol = i < usage.size() ? usage[i] : "";
    #####: 4953:                    os << usageCol;
        -: 4954:
    #####: 4955:                    if( i < desc.size() && !desc[i].empty() )
    #####: 4956:                        os  << std::string( indent + 2 + maxWidth - usageCol.size(), ' ' )
    #####: 4957:                            << desc[i];
    #####: 4958:                    os << "\n";
        -: 4959:                }
        -: 4960:            }
    #####: 4961:        }
        -: 4962:        std::string optUsage() const {
        -: 4963:            std::ostringstream oss;
        -: 4964:            optUsage( oss );
        -: 4965:            return oss.str();
        -: 4966:        }
        -: 4967:
    #####: 4968:        void argSynopsis( std::ostream& os ) const {
    #####: 4969:            for( int i = 1; i <= m_highestSpecifiedArgPosition; ++i ) {
    #####: 4970:                if( i > 1 )
    #####: 4971:                    os << " ";
    #####: 4972:                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( i );
    #####: 4973:                if( it != m_positionalArgs.end() )
    #####: 4974:                    os << "<" << it->second.placeholder << ">";
    #####: 4975:                else if( m_floatingArg.get() )
    #####: 4976:                    os << "<" << m_floatingArg->placeholder << ">";
        -: 4977:                else
    #####: 4978:                    throw std::logic_error( "non consecutive positional arguments with no floating args" );
        -: 4979:            }
        -: 4980:            // !TBD No indication of mandatory args
    #####: 4981:            if( m_floatingArg.get() ) {
    #####: 4982:                if( m_highestSpecifiedArgPosition > 1 )
    #####: 4983:                    os << " ";
    #####: 4984:                os << "[<" << m_floatingArg->placeholder << "> ...]";
        -: 4985:            }
    #####: 4986:        }
        -: 4987:        std::string argSynopsis() const {
        -: 4988:            std::ostringstream oss;
        -: 4989:            argSynopsis( oss );
        -: 4990:            return oss.str();
        -: 4991:        }
        -: 4992:
    #####: 4993:        void usage( std::ostream& os, std::string const& procName ) const {
    #####: 4994:            validate();
    #####: 4995:            os << "usage:\n  " << procName << " ";
    #####: 4996:            argSynopsis( os );
    #####: 4997:            if( !m_options.empty() ) {
    #####: 4998:                os << " [options]\n\nwhere options are: \n";
    #####: 4999:                optUsage( os, 2 );
        -: 5000:            }
    #####: 5001:            os << "\n";
    #####: 5002:        }
        -: 5003:        std::string usage( std::string const& procName ) const {
        -: 5004:            std::ostringstream oss;
        -: 5005:            usage( oss, procName );
        -: 5006:            return oss.str();
        -: 5007:        }
        -: 5008:
        -: 5009:        ConfigT parse( std::vector<std::string> const& args ) const {
        -: 5010:            ConfigT config;
        -: 5011:            parseInto( args, config );
        -: 5012:            return config;
        -: 5013:        }
        -: 5014:
        1: 5015:        std::vector<Parser::Token> parseInto( std::vector<std::string> const& args, ConfigT& config ) const {
       2*: 5016:            std::string processName = args.empty() ? std::string() : args[0];
        1: 5017:            std::size_t lastSlash = processName.find_last_of( "/\\" );
        1: 5018:            if( lastSlash != std::string::npos )
        1: 5019:                processName = processName.substr( lastSlash+1 );
        1: 5020:            m_boundProcessName.set( config, processName );
        2: 5021:            std::vector<Parser::Token> tokens;
        1: 5022:            Parser parser;
        1: 5023:            parser.parseIntoTokens( args, tokens );
        2: 5024:            return populate( tokens, config );
        -: 5025:        }
        -: 5026:
        1: 5027:        std::vector<Parser::Token> populate( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 5028:            validate();
        1: 5029:            std::vector<Parser::Token> unusedTokens = populateOptions( tokens, config );
        1: 5030:            unusedTokens = populateFixedArgs( unusedTokens, config );
        1: 5031:            unusedTokens = populateFloatingArgs( unusedTokens, config );
        1: 5032:            return unusedTokens;
        -: 5033:        }
        -: 5034:
        1: 5035:        std::vector<Parser::Token> populateOptions( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 5036:            std::vector<Parser::Token> unusedTokens;
        2: 5037:            std::vector<std::string> errors;
       1*: 5038:            for( std::size_t i = 0; i < tokens.size(); ++i ) {
    #####: 5039:                Parser::Token const& token = tokens[i];
    #####: 5040:                typename std::vector<Arg>::const_iterator it = m_options.begin(), itEnd = m_options.end();
    #####: 5041:                for(; it != itEnd; ++it ) {
    #####: 5042:                    Arg const& arg = *it;
        -: 5043:
        -: 5044:                    try {
    #####: 5045:                        if( ( token.type == Parser::Token::ShortOpt && arg.hasShortName( token.data ) ) ||
    #####: 5046:                            ( token.type == Parser::Token::LongOpt && arg.hasLongName( token.data ) ) ) {
    #####: 5047:                            if( arg.takesArg() ) {
    #####: 5048:                                if( i == tokens.size()-1 || tokens[i+1].type != Parser::Token::Positional )
    #####: 5049:                                    errors.push_back( "Expected argument to option: " + token.data );
        -: 5050:                                else
    #####: 5051:                                    arg.boundField.set( config, tokens[++i].data );
        -: 5052:                            }
        -: 5053:                            else {
    #####: 5054:                                arg.boundField.set( config, "true" );
        -: 5055:                            }
    #####: 5056:                            break;
        -: 5057:                        }
        -: 5058:                    }
    =====: 5059:                    catch( std::exception& ex ) {
    =====: 5060:                        errors.push_back( std::string( ex.what() ) + "\n- while parsing: (" + arg.commands() + ")" );
        -: 5061:                    }
        -: 5062:                }
    #####: 5063:                if( it == itEnd ) {
    #####: 5064:                    if( token.type == Parser::Token::Positional || !m_throwOnUnrecognisedTokens )
    #####: 5065:                        unusedTokens.push_back( token );
    #####: 5066:                    else if( errors.empty() && m_throwOnUnrecognisedTokens )
    #####: 5067:                        errors.push_back( "unrecognised option: " + token.data );
        -: 5068:                }
        -: 5069:            }
        1: 5070:            if( !errors.empty() ) {
    #####: 5071:                std::ostringstream oss;
    #####: 5072:                for( std::vector<std::string>::const_iterator it = errors.begin(), itEnd = errors.end();
    #####: 5073:                        it != itEnd;
    #####: 5074:                        ++it ) {
    #####: 5075:                    if( it != errors.begin() )
    #####: 5076:                        oss << "\n";
    #####: 5077:                    oss << *it;
        -: 5078:                }
    #####: 5079:                throw std::runtime_error( oss.str() );
        -: 5080:            }
        2: 5081:            return unusedTokens;
        -: 5082:        }
        1: 5083:        std::vector<Parser::Token> populateFixedArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 5084:            std::vector<Parser::Token> unusedTokens;
        1: 5085:            int position = 1;
       1*: 5086:            for( std::size_t i = 0; i < tokens.size(); ++i ) {
    #####: 5087:                Parser::Token const& token = tokens[i];
    #####: 5088:                typename std::map<int, Arg>::const_iterator it = m_positionalArgs.find( position );
    #####: 5089:                if( it != m_positionalArgs.end() )
    #####: 5090:                    it->second.boundField.set( config, token.data );
        -: 5091:                else
    #####: 5092:                    unusedTokens.push_back( token );
    #####: 5093:                if( token.type == Parser::Token::Positional )
    #####: 5094:                    position++;
        -: 5095:            }
        2: 5096:            return unusedTokens;
        -: 5097:        }
        1: 5098:        std::vector<Parser::Token> populateFloatingArgs( std::vector<Parser::Token> const& tokens, ConfigT& config ) const {
        1: 5099:            if( !m_floatingArg.get() )
    #####: 5100:                return tokens;
        2: 5101:            std::vector<Parser::Token> unusedTokens;
       1*: 5102:            for( std::size_t i = 0; i < tokens.size(); ++i ) {
    #####: 5103:                Parser::Token const& token = tokens[i];
    #####: 5104:                if( token.type == Parser::Token::Positional )
    #####: 5105:                    m_floatingArg->boundField.set( config, token.data );
        -: 5106:                else
    #####: 5107:                    unusedTokens.push_back( token );
        -: 5108:            }
        1: 5109:            return unusedTokens;
        -: 5110:        }
        -: 5111:
        1: 5112:        void validate() const
        -: 5113:        {
       1*: 5114:            if( m_options.empty() && m_positionalArgs.empty() && !m_floatingArg.get() )
    #####: 5115:                throw std::logic_error( "No options or arguments specified" );
        -: 5116:
       27: 5117:            for( typename std::vector<Arg>::const_iterator  it = m_options.begin(),
        1: 5118:                                                            itEnd = m_options.end();
       53: 5119:                    it != itEnd; ++it )
       26: 5120:                it->validate();
        1: 5121:        }
        -: 5122:
        -: 5123:    private:
        -: 5124:        Detail::BoundArgFunction<ConfigT> m_boundProcessName;
        -: 5125:        std::vector<Arg> m_options;
        -: 5126:        std::map<int, Arg> m_positionalArgs;
        -: 5127:        ArgAutoPtr m_floatingArg;
        -: 5128:        int m_highestSpecifiedArgPosition;
        -: 5129:        bool m_throwOnUnrecognisedTokens;
        -: 5130:    };
        -: 5131:
        -: 5132:} // end namespace Clara
        -: 5133:
        -: 5134:STITCH_CLARA_CLOSE_NAMESPACE
        -: 5135:#undef STITCH_CLARA_OPEN_NAMESPACE
        -: 5136:#undef STITCH_CLARA_CLOSE_NAMESPACE
        -: 5137:
        -: 5138:#endif // TWOBLUECUBES_CLARA_H_INCLUDED
        -: 5139:#undef STITCH_CLARA_OPEN_NAMESPACE
        -: 5140:
        -: 5141:// Restore Clara's value for console width, if present
        -: 5142:#ifdef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 5143:#define CLARA_CONFIG_CONSOLE_WIDTH CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 5144:#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH
        -: 5145:#endif
        -: 5146:
        -: 5147:#include <fstream>
        -: 5148:#include <ctime>
        -: 5149:
        -: 5150:namespace Catch {
        -: 5151:
    #####: 5152:    inline void abortAfterFirst( ConfigData& config ) { config.abortAfter = 1; }
    #####: 5153:    inline void abortAfterX( ConfigData& config, int x ) {
    #####: 5154:        if( x < 1 )
    #####: 5155:            throw std::runtime_error( "Value after -x or --abortAfter must be greater than zero" );
    #####: 5156:        config.abortAfter = x;
    #####: 5157:    }
    #####: 5158:    inline void addTestOrTags( ConfigData& config, std::string const& _testSpec ) { config.testsOrTags.push_back( _testSpec ); }
    #####: 5159:    inline void addSectionToRun( ConfigData& config, std::string const& sectionName ) { config.sectionsToRun.push_back( sectionName ); }
    #####: 5160:    inline void addReporterName( ConfigData& config, std::string const& _reporterName ) { config.reporterNames.push_back( _reporterName ); }
        -: 5161:
    #####: 5162:    inline void addWarning( ConfigData& config, std::string const& _warning ) {
    #####: 5163:        if( _warning == "NoAssertions" )
    #####: 5164:            config.warnings = static_cast<WarnAbout::What>( config.warnings | WarnAbout::NoAssertions );
        -: 5165:        else
    #####: 5166:            throw std::runtime_error( "Unrecognised warning: '" + _warning + '\'' );
    #####: 5167:    }
    #####: 5168:    inline void setOrder( ConfigData& config, std::string const& order ) {
    #####: 5169:        if( startsWith( "declared", order ) )
    #####: 5170:            config.runOrder = RunTests::InDeclarationOrder;
    #####: 5171:        else if( startsWith( "lexical", order ) )
    #####: 5172:            config.runOrder = RunTests::InLexicographicalOrder;
    #####: 5173:        else if( startsWith( "random", order ) )
    #####: 5174:            config.runOrder = RunTests::InRandomOrder;
        -: 5175:        else
    #####: 5176:            throw std::runtime_error( "Unrecognised ordering: '" + order + '\'' );
    #####: 5177:    }
    #####: 5178:    inline void setRngSeed( ConfigData& config, std::string const& seed ) {
    #####: 5179:        if( seed == "time" ) {
    #####: 5180:            config.rngSeed = static_cast<unsigned int>( std::time(0) );
        -: 5181:        }
        -: 5182:        else {
    #####: 5183:            std::stringstream ss;
    #####: 5184:            ss << seed;
    #####: 5185:            ss >> config.rngSeed;
    #####: 5186:            if( ss.fail() )
    #####: 5187:                throw std::runtime_error( "Argument to --rng-seed should be the word 'time' or a number" );
        -: 5188:        }
    #####: 5189:    }
        -: 5190:    inline void setVerbosity( ConfigData& config, int level ) {
        -: 5191:        // !TBD: accept strings?
        -: 5192:        config.verbosity = static_cast<Verbosity::Level>( level );
        -: 5193:    }
    #####: 5194:    inline void setShowDurations( ConfigData& config, bool _showDurations ) {
    #####: 5195:        config.showDurations = _showDurations
    #####: 5196:            ? ShowDurations::Always
        -: 5197:            : ShowDurations::Never;
    #####: 5198:    }
    #####: 5199:    inline void setUseColour( ConfigData& config, std::string const& value ) {
    #####: 5200:        std::string mode = toLower( value );
        -: 5201:
    #####: 5202:        if( mode == "yes" )
    #####: 5203:            config.useColour = UseColour::Yes;
    #####: 5204:        else if( mode == "no" )
    #####: 5205:            config.useColour = UseColour::No;
    #####: 5206:        else if( mode == "auto" )
    #####: 5207:            config.useColour = UseColour::Auto;
        -: 5208:        else
    #####: 5209:            throw std::runtime_error( "colour mode must be one of: auto, yes or no" );
    #####: 5210:    }
    #####: 5211:    inline void setWaitForKeypress( ConfigData& config, std::string const& keypress ) {
    #####: 5212:        std::string keypressLc = toLower( keypress );
    #####: 5213:        if( keypressLc == "start" )
    #####: 5214:            config.waitForKeypress = WaitForKeypress::BeforeStart;
    #####: 5215:        else if( keypressLc == "exit" )
    #####: 5216:            config.waitForKeypress = WaitForKeypress::BeforeExit;
    #####: 5217:        else if( keypressLc == "both" )
    #####: 5218:            config.waitForKeypress = WaitForKeypress::BeforeStartAndExit;
        -: 5219:        else
    #####: 5220:            throw std::runtime_error( "keypress argument must be one of: start, exit or both. '" + keypress + "' not recognised" );
    #####: 5221:    };
        -: 5222:
    #####: 5223:    inline void forceColour( ConfigData& config ) {
    #####: 5224:        config.useColour = UseColour::Yes;
    #####: 5225:    }
    #####: 5226:    inline void loadTestNamesFromFile( ConfigData& config, std::string const& _filename ) {
    #####: 5227:        std::ifstream f( _filename.c_str() );
    #####: 5228:        if( !f.is_open() )
    #####: 5229:            throw std::domain_error( "Unable to load input file: " + _filename );
        -: 5230:
    #####: 5231:        std::string line;
    #####: 5232:        while( std::getline( f, line ) ) {
    #####: 5233:            line = trim(line);
    #####: 5234:            if( !line.empty() && !startsWith( line, '#' ) ) {
    #####: 5235:                if( !startsWith( line, '"' ) )
    #####: 5236:                    line = '"' + line + '"';
    #####: 5237:                addTestOrTags( config, line + ',' );
        -: 5238:            }
        -: 5239:        }
    #####: 5240:    }
        -: 5241:
        1: 5242:    inline Clara::CommandLine<ConfigData> makeCommandLineParser() {
        -: 5243:
        -: 5244:        using namespace Clara;
        1: 5245:        CommandLine<ConfigData> cli;
        -: 5246:
        1: 5247:        cli.bindProcessName( &ConfigData::processName );
        -: 5248:
        2: 5249:        cli["-?"]["-h"]["--help"]
        2: 5250:            .describe( "display usage information" )
        1: 5251:            .bind( &ConfigData::showHelp );
        -: 5252:
        2: 5253:        cli["-l"]["--list-tests"]
        2: 5254:            .describe( "list all/matching test cases" )
        1: 5255:            .bind( &ConfigData::listTests );
        -: 5256:
        2: 5257:        cli["-t"]["--list-tags"]
        2: 5258:            .describe( "list all/matching tags" )
        1: 5259:            .bind( &ConfigData::listTags );
        -: 5260:
        2: 5261:        cli["-s"]["--success"]
        2: 5262:            .describe( "include successful tests in output" )
        1: 5263:            .bind( &ConfigData::showSuccessfulTests );
        -: 5264:
        2: 5265:        cli["-b"]["--break"]
        2: 5266:            .describe( "break into debugger on failure" )
        1: 5267:            .bind( &ConfigData::shouldDebugBreak );
        -: 5268:
        2: 5269:        cli["-e"]["--nothrow"]
        2: 5270:            .describe( "skip exception tests" )
        1: 5271:            .bind( &ConfigData::noThrow );
        -: 5272:
        2: 5273:        cli["-i"]["--invisibles"]
        2: 5274:            .describe( "show invisibles (tabs, newlines)" )
        1: 5275:            .bind( &ConfigData::showInvisibles );
        -: 5276:
        2: 5277:        cli["-o"]["--out"]
        2: 5278:            .describe( "output filename" )
        1: 5279:            .bind( &ConfigData::outputFilename, "filename" );
        -: 5280:
        2: 5281:        cli["-r"]["--reporter"]
        -: 5282://            .placeholder( "name[:filename]" )
        2: 5283:            .describe( "reporter to use (defaults to console)" )
        1: 5284:            .bind( &addReporterName, "name" );
        -: 5285:
        2: 5286:        cli["-n"]["--name"]
        2: 5287:            .describe( "suite name" )
        1: 5288:            .bind( &ConfigData::name, "name" );
        -: 5289:
        2: 5290:        cli["-a"]["--abort"]
        2: 5291:            .describe( "abort at first failure" )
        1: 5292:            .bind( &abortAfterFirst );
        -: 5293:
        2: 5294:        cli["-x"]["--abortx"]
        2: 5295:            .describe( "abort after x failures" )
        1: 5296:            .bind( &abortAfterX, "no. failures" );
        -: 5297:
        2: 5298:        cli["-w"]["--warn"]
        2: 5299:            .describe( "enable warnings" )
        1: 5300:            .bind( &addWarning, "warning name" );
        -: 5301:
        -: 5302:// - needs updating if reinstated
        -: 5303://        cli.into( &setVerbosity )
        -: 5304://            .describe( "level of verbosity (0=no output)" )
        -: 5305://            .shortOpt( "v")
        -: 5306://            .longOpt( "verbosity" )
        -: 5307://            .placeholder( "level" );
        -: 5308:
        1: 5309:        cli[_]
        2: 5310:            .describe( "which test or tests to use" )
        1: 5311:            .bind( &addTestOrTags, "test name, pattern or tags" );
        -: 5312:
        2: 5313:        cli["-d"]["--durations"]
        2: 5314:            .describe( "show test durations" )
        1: 5315:            .bind( &setShowDurations, "yes|no" );
        -: 5316:
        2: 5317:        cli["-f"]["--input-file"]
        2: 5318:            .describe( "load test names to run from a file" )
        1: 5319:            .bind( &loadTestNamesFromFile, "filename" );
        -: 5320:
        2: 5321:        cli["-#"]["--filenames-as-tags"]
        2: 5322:            .describe( "adds a tag for the filename" )
        1: 5323:            .bind( &ConfigData::filenamesAsTags );
        -: 5324:
        2: 5325:        cli["-c"]["--section"]
        2: 5326:                .describe( "specify section to run" )
        1: 5327:                .bind( &addSectionToRun, "section name" );
        -: 5328:
        -: 5329:        // Less common commands which don't have a short form
        -: 5330:        cli["--list-test-names-only"]
        2: 5331:            .describe( "list all/matching test cases names only" )
        1: 5332:            .bind( &ConfigData::listTestNamesOnly );
        -: 5333:
        -: 5334:        cli["--list-extra-info"]
        2: 5335:            .describe( "list all/matching test cases with more info" )
        1: 5336:            .bind( &ConfigData::listExtraInfo );
        -: 5337:
        -: 5338:        cli["--list-reporters"]
        2: 5339:            .describe( "list all reporters" )
        1: 5340:            .bind( &ConfigData::listReporters );
        -: 5341:
        -: 5342:        cli["--order"]
        2: 5343:            .describe( "test case order (defaults to decl)" )
        1: 5344:            .bind( &setOrder, "decl|lex|rand" );
        -: 5345:
        -: 5346:        cli["--rng-seed"]
        2: 5347:            .describe( "set a specific seed for random numbers" )
        1: 5348:            .bind( &setRngSeed, "'time'|number" );
        -: 5349:
        -: 5350:        cli["--force-colour"]
        2: 5351:            .describe( "force colourised output (deprecated)" )
        1: 5352:            .bind( &forceColour );
        -: 5353:
        -: 5354:        cli["--use-colour"]
        2: 5355:            .describe( "should output be colourised" )
        1: 5356:            .bind( &setUseColour, "yes|no" );
        -: 5357:
        -: 5358:        cli["--libidentify"]
        2: 5359:            .describe( "report name and version according to libidentify standard" )
        1: 5360:            .bind( &ConfigData::libIdentify );
        -: 5361:
        -: 5362:        cli["--wait-for-keypress"]
        2: 5363:                .describe( "waits for a keypress before exiting" )
        1: 5364:                .bind( &setWaitForKeypress, "start|exit|both" );
        -: 5365:
        1: 5366:        return cli;
        -: 5367:    }
        -: 5368:
        -: 5369:} // end namespace Catch
        -: 5370:
        -: 5371:// #included from: internal/catch_list.hpp
        -: 5372:#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED
        -: 5373:
        -: 5374:// #included from: catch_text.h
        -: 5375:#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED
        -: 5376:
        -: 5377:#define TBC_TEXT_FORMAT_CONSOLE_WIDTH CATCH_CONFIG_CONSOLE_WIDTH
        -: 5378:
        -: 5379:#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE Catch
        -: 5380:// #included from: ../external/tbc_text_format.h
        -: 5381:// Only use header guard if we are not using an outer namespace
        -: 5382:#ifndef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 5383:# ifdef TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
        -: 5384:#  ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 5385:#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 5386:#  endif
        -: 5387:# else
        -: 5388:#  define TWOBLUECUBES_TEXT_FORMAT_H_INCLUDED
        -: 5389:# endif
        -: 5390:#endif
        -: 5391:#ifndef TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 5392:#include <string>
        -: 5393:#include <vector>
        -: 5394:#include <sstream>
        -: 5395:
        -: 5396:// Use optional outer namespace
        -: 5397:#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 5398:namespace CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE {
        -: 5399:#endif
        -: 5400:
        -: 5401:namespace Tbc {
        -: 5402:
        -: 5403:#ifdef TBC_TEXT_FORMAT_CONSOLE_WIDTH
        -: 5404:    const unsigned int consoleWidth = TBC_TEXT_FORMAT_CONSOLE_WIDTH;
        -: 5405:#else
        -: 5406:    const unsigned int consoleWidth = 80;
        -: 5407:#endif
        -: 5408:
        -: 5409:    struct TextAttributes {
    #####: 5410:        TextAttributes()
    #####: 5411:        :   initialIndent( std::string::npos ),
        -: 5412:            indent( 0 ),
    #####: 5413:            width( consoleWidth-1 )
    #####: 5414:        {}
        -: 5415:
    #####: 5416:        TextAttributes& setInitialIndent( std::size_t _value )  { initialIndent = _value; return *this; }
    #####: 5417:        TextAttributes& setIndent( std::size_t _value )         { indent = _value; return *this; }
    #####: 5418:        TextAttributes& setWidth( std::size_t _value )          { width = _value; return *this; }
        -: 5419:
        -: 5420:        std::size_t initialIndent;  // indent of first line, or npos
        -: 5421:        std::size_t indent;         // indent of subsequent lines, or all if initialIndent is npos
        -: 5422:        std::size_t width;          // maximum width of text, including indent. Longer text will wrap
        -: 5423:    };
        -: 5424:
        -: 5425:    class Text {
        -: 5426:    public:
    #####: 5427:        Text( std::string const& _str, TextAttributes const& _attr = TextAttributes() )
    #####: 5428:        : attr( _attr )
        -: 5429:        {
    #####: 5430:            const std::string wrappableBeforeChars = "[({<\t";
    #####: 5431:            const std::string wrappableAfterChars = "])}>-,./|\\";
    #####: 5432:            const std::string wrappableInsteadOfChars = " \n\r";
    #####: 5433:            std::string indent = _attr.initialIndent != std::string::npos
    #####: 5434:                ? std::string( _attr.initialIndent, ' ' )
    #####: 5435:                : std::string( _attr.indent, ' ' );
        -: 5436:
        -: 5437:            typedef std::string::const_iterator iterator;
    #####: 5438:            iterator it = _str.begin();
    #####: 5439:            const iterator strEnd = _str.end();
        -: 5440:
    #####: 5441:            while( it != strEnd ) {
        -: 5442:
    #####: 5443:                if( lines.size() >= 1000 ) {
    #####: 5444:                    lines.push_back( "... message truncated due to excessive size" );
    #####: 5445:                    return;
        -: 5446:                }
        -: 5447:
    #####: 5448:                std::string suffix;
    #####: 5449:                std::size_t width = (std::min)( static_cast<size_t>( strEnd-it ), _attr.width-static_cast<size_t>( indent.size() ) );
    #####: 5450:                iterator itEnd = it+width;
    #####: 5451:                iterator itNext = _str.end();
        -: 5452:
    #####: 5453:                iterator itNewLine = std::find( it, itEnd, '\n' );
    #####: 5454:                if( itNewLine != itEnd )
    #####: 5455:                    itEnd = itNewLine;
        -: 5456:
    #####: 5457:                if( itEnd != strEnd  ) {
    #####: 5458:                    bool foundWrapPoint = false;
    #####: 5459:                    iterator findIt = itEnd;
    #####: 5460:                    do {
    #####: 5461:                        if( wrappableAfterChars.find( *findIt ) != std::string::npos && findIt != itEnd ) {
    #####: 5462:                            itEnd = findIt+1;
    #####: 5463:                            itNext = findIt+1;
    #####: 5464:                            foundWrapPoint = true;
        -: 5465:                        }
    #####: 5466:                        else if( findIt > it && wrappableBeforeChars.find( *findIt ) != std::string::npos ) {
    #####: 5467:                            itEnd = findIt;
    #####: 5468:                            itNext = findIt;
    #####: 5469:                            foundWrapPoint = true;
        -: 5470:                        }
    #####: 5471:                        else if( wrappableInsteadOfChars.find( *findIt ) != std::string::npos ) {
    #####: 5472:                            itNext = findIt+1;
    #####: 5473:                            itEnd = findIt;
    #####: 5474:                            foundWrapPoint = true;
        -: 5475:                        }
    #####: 5476:                        if( findIt == it )
    #####: 5477:                            break;
        -: 5478:                        else
    #####: 5479:                            --findIt;
        -: 5480:                    }
    #####: 5481:                    while( !foundWrapPoint );
        -: 5482:
    #####: 5483:                    if( !foundWrapPoint ) {
        -: 5484:                        // No good wrap char, so we'll break mid word and add a hyphen
    #####: 5485:                        --itEnd;
    #####: 5486:                        itNext = itEnd;
    #####: 5487:                        suffix = "-";
        -: 5488:                    }
        -: 5489:                    else {
    #####: 5490:                        while( itEnd > it && wrappableInsteadOfChars.find( *(itEnd-1) ) != std::string::npos )
    #####: 5491:                            --itEnd;
        -: 5492:                    }
        -: 5493:                }
    #####: 5494:                lines.push_back( indent + std::string( it, itEnd ) + suffix );
        -: 5495:
    #####: 5496:                if( indent.size() != _attr.indent )
    #####: 5497:                    indent = std::string( _attr.indent, ' ' );
    #####: 5498:                it = itNext;
        -: 5499:            }
        -: 5500:        }
        -: 5501:
        -: 5502:        typedef std::vector<std::string>::const_iterator const_iterator;
        -: 5503:
    #####: 5504:        const_iterator begin() const { return lines.begin(); }
    #####: 5505:        const_iterator end() const { return lines.end(); }
        -: 5506:        std::string const& last() const { return lines.back(); }
        -: 5507:        std::size_t size() const { return lines.size(); }
        -: 5508:        std::string const& operator[]( std::size_t _index ) const { return lines[_index]; }
        -: 5509:        std::string toString() const {
        -: 5510:            std::ostringstream oss;
        -: 5511:            oss << *this;
        -: 5512:            return oss.str();
        -: 5513:        }
        -: 5514:
    #####: 5515:        inline friend std::ostream& operator << ( std::ostream& _stream, Text const& _text ) {
    #####: 5516:            for( Text::const_iterator it = _text.begin(), itEnd = _text.end();
    #####: 5517:                it != itEnd; ++it ) {
    #####: 5518:                if( it != _text.begin() )
    #####: 5519:                    _stream << "\n";
    #####: 5520:                _stream << *it;
        -: 5521:            }
    #####: 5522:            return _stream;
        -: 5523:        }
        -: 5524:
        -: 5525:    private:
        -: 5526:        std::string str;
        -: 5527:        TextAttributes attr;
        -: 5528:        std::vector<std::string> lines;
        -: 5529:    };
        -: 5530:
        -: 5531:} // end namespace Tbc
        -: 5532:
        -: 5533:#ifdef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 5534:} // end outer namespace
        -: 5535:#endif
        -: 5536:
        -: 5537:#endif // TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED
        -: 5538:#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE
        -: 5539:
        -: 5540:namespace Catch {
        -: 5541:    using Tbc::Text;
        -: 5542:    using Tbc::TextAttributes;
        -: 5543:}
        -: 5544:
        -: 5545:// #included from: catch_console_colour.hpp
        -: 5546:#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED
        -: 5547:
        -: 5548:namespace Catch {
        -: 5549:
        -: 5550:    struct Colour {
        -: 5551:        enum Code {
        -: 5552:            None = 0,
        -: 5553:
        -: 5554:            White,
        -: 5555:            Red,
        -: 5556:            Green,
        -: 5557:            Blue,
        -: 5558:            Cyan,
        -: 5559:            Yellow,
        -: 5560:            Grey,
        -: 5561:
        -: 5562:            Bright = 0x10,
        -: 5563:
        -: 5564:            BrightRed = Bright | Red,
        -: 5565:            BrightGreen = Bright | Green,
        -: 5566:            LightGrey = Bright | Grey,
        -: 5567:            BrightWhite = Bright | White,
        -: 5568:
        -: 5569:            // By intention
        -: 5570:            FileName = LightGrey,
        -: 5571:            Warning = Yellow,
        -: 5572:            ResultError = BrightRed,
        -: 5573:            ResultSuccess = BrightGreen,
        -: 5574:            ResultExpectedFailure = Warning,
        -: 5575:
        -: 5576:            Error = BrightRed,
        -: 5577:            Success = Green,
        -: 5578:
        -: 5579:            OriginalExpression = Cyan,
        -: 5580:            ReconstructedExpression = Yellow,
        -: 5581:
        -: 5582:            SecondaryText = LightGrey,
        -: 5583:            Headers = White
        -: 5584:        };
        -: 5585:
        -: 5586:        // Use constructed object for RAII guard
        -: 5587:        Colour( Code _colourCode );
        -: 5588:        Colour( Colour const& other );
        -: 5589:        ~Colour();
        -: 5590:
        -: 5591:        // Use static method for one-shot changes
        -: 5592:        static void use( Code _colourCode );
        -: 5593:
        -: 5594:    private:
        -: 5595:        bool m_moved;
        -: 5596:    };
        -: 5597:
        4: 5598:    inline std::ostream& operator << ( std::ostream& os, Colour const& ) { return os; }
        -: 5599:
        -: 5600:} // end namespace Catch
        -: 5601:
        -: 5602:// #included from: catch_interfaces_reporter.h
        -: 5603:#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED
        -: 5604:
        -: 5605:#include <string>
        -: 5606:#include <ostream>
        -: 5607:#include <map>
        -: 5608:
        -: 5609:namespace Catch
        -: 5610:{
        -: 5611:    struct ReporterConfig {
        1: 5612:        explicit ReporterConfig( Ptr<IConfig const> const& _fullConfig )
        1: 5613:        :   m_stream( &_fullConfig->stream() ), m_fullConfig( _fullConfig ) {}
        -: 5614:
        -: 5615:        ReporterConfig( Ptr<IConfig const> const& _fullConfig, std::ostream& _stream )
        -: 5616:        :   m_stream( &_stream ), m_fullConfig( _fullConfig ) {}
        -: 5617:
        1: 5618:        std::ostream& stream() const    { return *m_stream; }
        1: 5619:        Ptr<IConfig const> fullConfig() const { return m_fullConfig; }
        -: 5620:
        -: 5621:    private:
        -: 5622:        std::ostream* m_stream;
        -: 5623:        Ptr<IConfig const> m_fullConfig;
        -: 5624:    };
        -: 5625:
        -: 5626:    struct ReporterPreferences {
        1: 5627:        ReporterPreferences()
        1: 5628:        : shouldRedirectStdOut( false )
        1: 5629:        {}
        -: 5630:
        -: 5631:        bool shouldRedirectStdOut;
        -: 5632:    };
        -: 5633:
        -: 5634:    template<typename T>
        -: 5635:    struct LazyStat : Option<T> {
        3: 5636:        LazyStat() : used( false ) {}
------------------
_ZN5Catch8LazyStatINS_12TestCaseInfoEEC2Ev:
        1: 5636:        LazyStat() : used( false ) {}
------------------
_ZN5Catch8LazyStatINS_9GroupInfoEEC2Ev:
        1: 5636:        LazyStat() : used( false ) {}
------------------
_ZN5Catch8LazyStatINS_11TestRunInfoEEC2Ev:
        1: 5636:        LazyStat() : used( false ) {}
------------------
        3: 5637:        LazyStat& operator=( T const& _value ) {
        3: 5638:            Option<T>::operator=( _value );
        3: 5639:            used = false;
        3: 5640:            return *this;
        -: 5641:        }
------------------
_ZN5Catch8LazyStatINS_12TestCaseInfoEEaSERKS1_:
        1: 5637:        LazyStat& operator=( T const& _value ) {
        1: 5638:            Option<T>::operator=( _value );
        1: 5639:            used = false;
        1: 5640:            return *this;
        -: 5641:        }
------------------
_ZN5Catch8LazyStatINS_9GroupInfoEEaSERKS1_:
        1: 5637:        LazyStat& operator=( T const& _value ) {
        1: 5638:            Option<T>::operator=( _value );
        1: 5639:            used = false;
        1: 5640:            return *this;
        -: 5641:        }
------------------
_ZN5Catch8LazyStatINS_11TestRunInfoEEaSERKS1_:
        1: 5637:        LazyStat& operator=( T const& _value ) {
        1: 5638:            Option<T>::operator=( _value );
        1: 5639:            used = false;
        1: 5640:            return *this;
        -: 5641:        }
------------------
        5: 5642:        void reset() {
        5: 5643:            Option<T>::reset();
        5: 5644:            used = false;
        5: 5645:        }
------------------
_ZN5Catch8LazyStatINS_11TestRunInfoEE5resetEv:
        1: 5642:        void reset() {
        1: 5643:            Option<T>::reset();
        1: 5644:            used = false;
        1: 5645:        }
------------------
_ZN5Catch8LazyStatINS_9GroupInfoEE5resetEv:
        2: 5642:        void reset() {
        2: 5643:            Option<T>::reset();
        2: 5644:            used = false;
        2: 5645:        }
------------------
_ZN5Catch8LazyStatINS_12TestCaseInfoEE5resetEv:
        2: 5642:        void reset() {
        2: 5643:            Option<T>::reset();
        2: 5644:            used = false;
        2: 5645:        }
------------------
        -: 5646:        bool used;
        -: 5647:    };
        -: 5648:
        -: 5649:    struct TestRunInfo {
        1: 5650:        TestRunInfo( std::string const& _name ) : name( _name ) {}
        -: 5651:        std::string name;
        -: 5652:    };
        -: 5653:    struct GroupInfo {
        2: 5654:        GroupInfo(  std::string const& _name,
        -: 5655:                    std::size_t _groupIndex,
        -: 5656:                    std::size_t _groupsCount )
        2: 5657:        :   name( _name ),
        -: 5658:            groupIndex( _groupIndex ),
        2: 5659:            groupsCounts( _groupsCount )
        2: 5660:        {}
        -: 5661:
        -: 5662:        std::string name;
        -: 5663:        std::size_t groupIndex;
        -: 5664:        std::size_t groupsCounts;
        -: 5665:    };
        -: 5666:
        -: 5667:    struct AssertionStats {
    #####: 5668:        AssertionStats( AssertionResult const& _assertionResult,
        -: 5669:                        std::vector<MessageInfo> const& _infoMessages,
        -: 5670:                        Totals const& _totals )
    #####: 5671:        :   assertionResult( _assertionResult ),
        -: 5672:            infoMessages( _infoMessages ),
    #####: 5673:            totals( _totals )
        -: 5674:        {
    #####: 5675:            if( assertionResult.hasMessage() ) {
        -: 5676:                // Copy message into messages list.
        -: 5677:                // !TBD This should have been done earlier, somewhere
    #####: 5678:                MessageBuilder builder( assertionResult.getTestMacroName(), assertionResult.getSourceInfo(), assertionResult.getResultType() );
    #####: 5679:                builder << assertionResult.getMessage();
    #####: 5680:                builder.m_info.message = builder.m_stream.str();
        -: 5681:
    #####: 5682:                infoMessages.push_back( builder.m_info );
        -: 5683:            }
    #####: 5684:        }
        -: 5685:        virtual ~AssertionStats();
        -: 5686:
        -: 5687:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5688:        AssertionStats( AssertionStats const& )              = default;
    #####: 5689:        AssertionStats( AssertionStats && )                  = default;
        -: 5690:        AssertionStats& operator = ( AssertionStats const& ) = default;
        -: 5691:        AssertionStats& operator = ( AssertionStats && )     = default;
        -: 5692:#  endif
        -: 5693:
        -: 5694:        AssertionResult assertionResult;
        -: 5695:        std::vector<MessageInfo> infoMessages;
        -: 5696:        Totals totals;
        -: 5697:    };
        -: 5698:
    #####: 5699:    struct SectionStats {
       12: 5700:        SectionStats(   SectionInfo const& _sectionInfo,
        -: 5701:                        Counts const& _assertions,
        -: 5702:                        double _durationInSeconds,
        -: 5703:                        bool _missingAssertions )
       12: 5704:        :   sectionInfo( _sectionInfo ),
        -: 5705:            assertions( _assertions ),
        -: 5706:            durationInSeconds( _durationInSeconds ),
       12: 5707:            missingAssertions( _missingAssertions )
       12: 5708:        {}
        -: 5709:        virtual ~SectionStats();
        -: 5710:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5711:        SectionStats( SectionStats const& )              = default;
        -: 5712:        SectionStats( SectionStats && )                  = default;
        -: 5713:        SectionStats& operator = ( SectionStats const& ) = default;
        -: 5714:        SectionStats& operator = ( SectionStats && )     = default;
        -: 5715:#  endif
        -: 5716:
        -: 5717:        SectionInfo sectionInfo;
        -: 5718:        Counts assertions;
        -: 5719:        double durationInSeconds;
        -: 5720:        bool missingAssertions;
        -: 5721:    };
        -: 5722:
        -: 5723:    struct TestCaseStats {
        1: 5724:        TestCaseStats(  TestCaseInfo const& _testInfo,
        -: 5725:                        Totals const& _totals,
        -: 5726:                        std::string const& _stdOut,
        -: 5727:                        std::string const& _stdErr,
        -: 5728:                        bool _aborting )
        1: 5729:        : testInfo( _testInfo ),
        -: 5730:            totals( _totals ),
        -: 5731:            stdOut( _stdOut ),
        -: 5732:            stdErr( _stdErr ),
        1: 5733:            aborting( _aborting )
        1: 5734:        {}
        -: 5735:        virtual ~TestCaseStats();
        -: 5736:
        -: 5737:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5738:        TestCaseStats( TestCaseStats const& )              = default;
        -: 5739:        TestCaseStats( TestCaseStats && )                  = default;
        -: 5740:        TestCaseStats& operator = ( TestCaseStats const& ) = default;
        -: 5741:        TestCaseStats& operator = ( TestCaseStats && )     = default;
        -: 5742:#  endif
        -: 5743:
        -: 5744:        TestCaseInfo testInfo;
        -: 5745:        Totals totals;
        -: 5746:        std::string stdOut;
        -: 5747:        std::string stdErr;
        -: 5748:        bool aborting;
        -: 5749:    };
        -: 5750:
        -: 5751:    struct TestGroupStats {
        1: 5752:        TestGroupStats( GroupInfo const& _groupInfo,
        -: 5753:                        Totals const& _totals,
        -: 5754:                        bool _aborting )
        1: 5755:        :   groupInfo( _groupInfo ),
        -: 5756:            totals( _totals ),
        1: 5757:            aborting( _aborting )
        1: 5758:        {}
        -: 5759:        TestGroupStats( GroupInfo const& _groupInfo )
        -: 5760:        :   groupInfo( _groupInfo ),
        -: 5761:            aborting( false )
        -: 5762:        {}
        -: 5763:        virtual ~TestGroupStats();
        -: 5764:
        -: 5765:#  ifdef CATCH_CONFIG_CPP11_GENERATED_METHODS
    #####: 5766:        TestGroupStats( TestGroupStats const& )              = default;
        -: 5767:        TestGroupStats( TestGroupStats && )                  = default;
        -: 5768:        TestGroupStats& operator = ( TestGroupStats const& ) = default;
        -: 5769:        TestGroupStats& operator = ( TestGroupStats && )     = default;
        -: 5770:#  endif
        -: 5771:
        -: 5772:        GroupInfo groupInfo;
        -: 5773:        Totals totals;
        -: 5774:        bool aborting;
        -: 5775:    };
        -: 5776:
        -: 5777:    struct TestRunStats {
        1: 5778:        TestRunStats(   TestRunInfo const& _runInfo,
        -: 5779:                        Totals const& _totals,
        -: 5780:                        bool _aborting )
        1: 5781:        :   runInfo( _runInfo ),
        -: 5782:            totals( _totals ),
        1: 5783:            aborting( _aborting )
        1: 5784:        {}
        -: 5785:        virtual ~TestRunStats();
        -: 5786:
        -: 5787:#  ifndef CATCH_CONFIG_CPP11_GENERATED_METHODS
        -: 5788:        TestRunStats( TestRunStats const& _other )
        -: 5789:        :   runInfo( _other.runInfo ),
        -: 5790:            totals( _other.totals ),
        -: 5791:            aborting( _other.aborting )
        -: 5792:        {}
        -: 5793:#  else
    #####: 5794:        TestRunStats( TestRunStats const& )              = default;
        -: 5795:        TestRunStats( TestRunStats && )                  = default;
        -: 5796:        TestRunStats& operator = ( TestRunStats const& ) = default;
        -: 5797:        TestRunStats& operator = ( TestRunStats && )     = default;
        -: 5798:#  endif
        -: 5799:
        -: 5800:        TestRunInfo runInfo;
        -: 5801:        Totals totals;
        -: 5802:        bool aborting;
        -: 5803:    };
        -: 5804:
        -: 5805:    class MultipleReporters;
        -: 5806:
        -: 5807:    struct IStreamingReporter : IShared {
        -: 5808:        virtual ~IStreamingReporter();
        -: 5809:
        -: 5810:        // Implementing class must also provide the following static method:
        -: 5811:        // static std::string getDescription();
        -: 5812:
        -: 5813:        virtual ReporterPreferences getPreferences() const = 0;
        -: 5814:
        -: 5815:        virtual void noMatchingTestCases( std::string const& spec ) = 0;
        -: 5816:
        -: 5817:        virtual void testRunStarting( TestRunInfo const& testRunInfo ) = 0;
        -: 5818:        virtual void testGroupStarting( GroupInfo const& groupInfo ) = 0;
        -: 5819:
        -: 5820:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) = 0;
        -: 5821:        virtual void sectionStarting( SectionInfo const& sectionInfo ) = 0;
        -: 5822:
        -: 5823:        virtual void assertionStarting( AssertionInfo const& assertionInfo ) = 0;
        -: 5824:
        -: 5825:        // The return value indicates if the messages buffer should be cleared:
        -: 5826:        virtual bool assertionEnded( AssertionStats const& assertionStats ) = 0;
        -: 5827:
        -: 5828:        virtual void sectionEnded( SectionStats const& sectionStats ) = 0;
        -: 5829:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) = 0;
        -: 5830:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) = 0;
        -: 5831:        virtual void testRunEnded( TestRunStats const& testRunStats ) = 0;
        -: 5832:
        -: 5833:        virtual void skipTest( TestCaseInfo const& testInfo ) = 0;
        -: 5834:
    #####: 5835:        virtual MultipleReporters* tryAsMulti() { return CATCH_NULL; }
        -: 5836:    };
        -: 5837:
        -: 5838:    struct IReporterFactory : IShared {
        -: 5839:        virtual ~IReporterFactory();
        -: 5840:        virtual IStreamingReporter* create( ReporterConfig const& config ) const = 0;
        -: 5841:        virtual std::string getDescription() const = 0;
        -: 5842:    };
        -: 5843:
        -: 5844:    struct IReporterRegistry {
        -: 5845:        typedef std::map<std::string, Ptr<IReporterFactory> > FactoryMap;
        -: 5846:        typedef std::vector<Ptr<IReporterFactory> > Listeners;
        -: 5847:
        -: 5848:        virtual ~IReporterRegistry();
        -: 5849:        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig const> const& config ) const = 0;
        -: 5850:        virtual FactoryMap const& getFactories() const = 0;
        -: 5851:        virtual Listeners const& getListeners() const = 0;
        -: 5852:    };
        -: 5853:
        -: 5854:    Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter );
        -: 5855:
        -: 5856:}
        -: 5857:
        -: 5858:#include <limits>
        -: 5859:#include <algorithm>
        -: 5860:
        -: 5861:namespace Catch {
        -: 5862:
    #####: 5863:    inline std::size_t listTests( Config const& config ) {
        -: 5864:
    #####: 5865:        TestSpec testSpec = config.testSpec();
    #####: 5866:        if( config.testSpec().hasFilters() )
    #####: 5867:            Catch::cout() << "Matching test cases:\n";
        -: 5868:        else {
    #####: 5869:            Catch::cout() << "All available test cases:\n";
    #####: 5870:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
        -: 5871:        }
        -: 5872:
    #####: 5873:        std::size_t matchedTests = 0;
    #####: 5874:        TextAttributes nameAttr, descAttr, tagsAttr;
    #####: 5875:        nameAttr.setInitialIndent( 2 ).setIndent( 4 );
    #####: 5876:        descAttr.setIndent( 4 );
    #####: 5877:        tagsAttr.setIndent( 6 );
        -: 5878:
    #####: 5879:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 5880:        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
    #####: 5881:                it != itEnd;
    #####: 5882:                ++it ) {
    #####: 5883:            matchedTests++;
    #####: 5884:            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
    #####: 5885:            Colour::Code colour = testCaseInfo.isHidden()
    #####: 5886:                ? Colour::SecondaryText
    #####: 5887:                : Colour::None;
    #####: 5888:            Colour colourGuard( colour );
        -: 5889:
    #####: 5890:            Catch::cout() << Text( testCaseInfo.name, nameAttr ) << std::endl;
    #####: 5891:            if( config.listExtraInfo() ) {
    #####: 5892:                Catch::cout() << "    " << testCaseInfo.lineInfo << std::endl;
    #####: 5893:                std::string description = testCaseInfo.description;
    #####: 5894:                if( description.empty() )
    #####: 5895:                    description = "(NO DESCRIPTION)";
    #####: 5896:                Catch::cout() << Text( description, descAttr ) << std::endl;
        -: 5897:            }
    #####: 5898:            if( !testCaseInfo.tags.empty() )
    #####: 5899:                Catch::cout() << Text( testCaseInfo.tagsAsString, tagsAttr ) << std::endl;
        -: 5900:        }
        -: 5901:
    #####: 5902:        if( !config.testSpec().hasFilters() )
    #####: 5903:            Catch::cout() << pluralise( matchedTests, "test case" ) << '\n' << std::endl;
        -: 5904:        else
    #####: 5905:            Catch::cout() << pluralise( matchedTests, "matching test case" ) << '\n' << std::endl;
    #####: 5906:        return matchedTests;
        -: 5907:    }
        -: 5908:
    #####: 5909:    inline std::size_t listTestsNamesOnly( Config const& config ) {
    #####: 5910:        TestSpec testSpec = config.testSpec();
    #####: 5911:        if( !config.testSpec().hasFilters() )
    #####: 5912:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
    #####: 5913:        std::size_t matchedTests = 0;
    #####: 5914:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 5915:        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
    #####: 5916:                it != itEnd;
    #####: 5917:                ++it ) {
    #####: 5918:            matchedTests++;
    #####: 5919:            TestCaseInfo const& testCaseInfo = it->getTestCaseInfo();
    #####: 5920:            if( startsWith( testCaseInfo.name, '#' ) )
    #####: 5921:               Catch::cout() << '"' << testCaseInfo.name << '"';
        -: 5922:            else
    #####: 5923:               Catch::cout() << testCaseInfo.name;
    #####: 5924:            if ( config.listExtraInfo() )
    #####: 5925:                Catch::cout() << "\t@" << testCaseInfo.lineInfo;
    #####: 5926:            Catch::cout() << std::endl;
        -: 5927:        }
    #####: 5928:        return matchedTests;
        -: 5929:    }
        -: 5930:
        -: 5931:    struct TagInfo {
    #####: 5932:        TagInfo() : count ( 0 ) {}
    #####: 5933:        void add( std::string const& spelling ) {
    #####: 5934:            ++count;
    #####: 5935:            spellings.insert( spelling );
    #####: 5936:        }
    #####: 5937:        std::string all() const {
    #####: 5938:            std::string out;
    #####: 5939:            for( std::set<std::string>::const_iterator it = spellings.begin(), itEnd = spellings.end();
    #####: 5940:                        it != itEnd;
    #####: 5941:                        ++it )
    #####: 5942:                out += "[" + *it + "]";
    #####: 5943:            return out;
        -: 5944:        }
        -: 5945:        std::set<std::string> spellings;
        -: 5946:        std::size_t count;
        -: 5947:    };
        -: 5948:
    #####: 5949:    inline std::size_t listTags( Config const& config ) {
    #####: 5950:        TestSpec testSpec = config.testSpec();
    #####: 5951:        if( config.testSpec().hasFilters() )
    #####: 5952:            Catch::cout() << "Tags for matching test cases:\n";
        -: 5953:        else {
    #####: 5954:            Catch::cout() << "All available tags:\n";
    #####: 5955:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "*" ).testSpec();
        -: 5956:        }
        -: 5957:
    #####: 5958:        std::map<std::string, TagInfo> tagCounts;
        -: 5959:
    #####: 5960:        std::vector<TestCase> matchedTestCases = filterTests( getAllTestCasesSorted( config ), testSpec, config );
    #####: 5961:        for( std::vector<TestCase>::const_iterator it = matchedTestCases.begin(), itEnd = matchedTestCases.end();
    #####: 5962:                it != itEnd;
    #####: 5963:                ++it ) {
    #####: 5964:            for( std::set<std::string>::const_iterator  tagIt = it->getTestCaseInfo().tags.begin(),
    #####: 5965:                                                        tagItEnd = it->getTestCaseInfo().tags.end();
    #####: 5966:                    tagIt != tagItEnd;
    #####: 5967:                    ++tagIt ) {
    #####: 5968:                std::string tagName = *tagIt;
    #####: 5969:                std::string lcaseTagName = toLower( tagName );
    #####: 5970:                std::map<std::string, TagInfo>::iterator countIt = tagCounts.find( lcaseTagName );
    #####: 5971:                if( countIt == tagCounts.end() )
    #####: 5972:                    countIt = tagCounts.insert( std::make_pair( lcaseTagName, TagInfo() ) ).first;
    #####: 5973:                countIt->second.add( tagName );
        -: 5974:            }
        -: 5975:        }
        -: 5976:
    #####: 5977:        for( std::map<std::string, TagInfo>::const_iterator countIt = tagCounts.begin(),
    #####: 5978:                                                            countItEnd = tagCounts.end();
    #####: 5979:                countIt != countItEnd;
    #####: 5980:                ++countIt ) {
    #####: 5981:            std::ostringstream oss;
    #####: 5982:            oss << "  " << std::setw(2) << countIt->second.count << "  ";
    #####: 5983:            Text wrapper( countIt->second.all(), TextAttributes()
    #####: 5984:                                                    .setInitialIndent( 0 )
    #####: 5985:                                                    .setIndent( oss.str().size() )
    #####: 5986:                                                    .setWidth( CATCH_CONFIG_CONSOLE_WIDTH-10 ) );
    #####: 5987:            Catch::cout() << oss.str() << wrapper << '\n';
        -: 5988:        }
    #####: 5989:        Catch::cout() << pluralise( tagCounts.size(), "tag" ) << '\n' << std::endl;
    #####: 5990:        return tagCounts.size();
        -: 5991:    }
        -: 5992:
    #####: 5993:    inline std::size_t listReporters( Config const& /*config*/ ) {
    #####: 5994:        Catch::cout() << "Available reporters:\n";
    #####: 5995:        IReporterRegistry::FactoryMap const& factories = getRegistryHub().getReporterRegistry().getFactories();
    #####: 5996:        IReporterRegistry::FactoryMap::const_iterator itBegin = factories.begin(), itEnd = factories.end(), it;
    #####: 5997:        std::size_t maxNameLen = 0;
    #####: 5998:        for(it = itBegin; it != itEnd; ++it )
    #####: 5999:            maxNameLen = (std::max)( maxNameLen, it->first.size() );
        -: 6000:
    #####: 6001:        for(it = itBegin; it != itEnd; ++it ) {
    #####: 6002:            Text wrapper( it->second->getDescription(), TextAttributes()
    #####: 6003:                                                        .setInitialIndent( 0 )
    #####: 6004:                                                        .setIndent( 7+maxNameLen )
    #####: 6005:                                                        .setWidth( CATCH_CONFIG_CONSOLE_WIDTH - maxNameLen-8 ) );
    #####: 6006:            Catch::cout() << "  "
    #####: 6007:                    << it->first
        -: 6008:                    << ':'
    #####: 6009:                    << std::string( maxNameLen - it->first.size() + 2, ' ' )
    #####: 6010:                    << wrapper << '\n';
        -: 6011:        }
    #####: 6012:        Catch::cout() << std::endl;
    #####: 6013:        return factories.size();
        -: 6014:    }
        -: 6015:
        1: 6016:    inline Option<std::size_t> list( Config const& config ) {
        1: 6017:        Option<std::size_t> listedCount;
       1*: 6018:        if( config.listTests() || ( config.listExtraInfo() && !config.listTestNamesOnly() ) )
    #####: 6019:            listedCount = listedCount.valueOr(0) + listTests( config );
        1: 6020:        if( config.listTestNamesOnly() )
    #####: 6021:            listedCount = listedCount.valueOr(0) + listTestsNamesOnly( config );
        1: 6022:        if( config.listTags() )
    #####: 6023:            listedCount = listedCount.valueOr(0) + listTags( config );
        1: 6024:        if( config.listReporters() )
    #####: 6025:            listedCount = listedCount.valueOr(0) + listReporters( config );
        1: 6026:        return listedCount;
        -: 6027:    }
        -: 6028:
        -: 6029:} // end namespace Catch
        -: 6030:
        -: 6031:// #included from: internal/catch_run_context.hpp
        -: 6032:#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED
        -: 6033:
        -: 6034:// #included from: catch_test_case_tracker.hpp
        -: 6035:#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED
        -: 6036:
        -: 6037:#include <algorithm>
        -: 6038:#include <string>
        -: 6039:#include <assert.h>
        -: 6040:#include <vector>
        -: 6041:#include <stdexcept>
        -: 6042:
        -: 6043:CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS
        -: 6044:
        -: 6045:namespace Catch {
        -: 6046:namespace TestCaseTracking {
        -: 6047:
        -: 6048:    struct NameAndLocation {
        -: 6049:        std::string name;
        -: 6050:        SourceLineInfo location;
        -: 6051:
       43: 6052:        NameAndLocation( std::string const& _name, SourceLineInfo const& _location )
       43: 6053:        :   name( _name ),
       43: 6054:            location( _location )
       43: 6055:        {}
        -: 6056:    };
        -: 6057:
        -: 6058:    struct ITracker : SharedImpl<> {
        -: 6059:        virtual ~ITracker();
        -: 6060:
        -: 6061:        // static queries
        -: 6062:        virtual NameAndLocation const& nameAndLocation() const = 0;
        -: 6063:
        -: 6064:        // dynamic queries
        -: 6065:        virtual bool isComplete() const = 0; // Successfully completed or failed
        -: 6066:        virtual bool isSuccessfullyCompleted() const = 0;
        -: 6067:        virtual bool isOpen() const = 0; // Started but not complete
        -: 6068:        virtual bool hasChildren() const = 0;
        -: 6069:
        -: 6070:        virtual ITracker& parent() = 0;
        -: 6071:
        -: 6072:        // actions
        -: 6073:        virtual void close() = 0; // Successfully complete
        -: 6074:        virtual void fail() = 0;
        -: 6075:        virtual void markAsNeedingAnotherRun() = 0;
        -: 6076:
        -: 6077:        virtual void addChild( Ptr<ITracker> const& child ) = 0;
        -: 6078:        virtual ITracker* findChild( NameAndLocation const& nameAndLocation ) = 0;
        -: 6079:        virtual void openChild() = 0;
        -: 6080:
        -: 6081:        // Debug/ checking
        -: 6082:        virtual bool isSectionTracker() const = 0;
        -: 6083:        virtual bool isIndexTracker() const = 0;
        -: 6084:    };
        -: 6085:
        -: 6086:    class  TrackerContext {
        -: 6087:
        -: 6088:        enum RunState {
        -: 6089:            NotStarted,
        -: 6090:            Executing,
        -: 6091:            CompletedCycle
        -: 6092:        };
        -: 6093:
        -: 6094:        Ptr<ITracker> m_rootTracker;
        -: 6095:        ITracker* m_currentTracker;
        -: 6096:        RunState m_runState;
        -: 6097:
        -: 6098:    public:
        -: 6099:
        -: 6100:        static TrackerContext& instance() {
        -: 6101:            static TrackerContext s_instance;
        -: 6102:            return s_instance;
        -: 6103:        }
        -: 6104:
        1: 6105:        TrackerContext()
        1: 6106:        :   m_currentTracker( CATCH_NULL ),
        1: 6107:            m_runState( NotStarted )
        1: 6108:        {}
        -: 6109:
        -: 6110:        ITracker& startRun();
        -: 6111:
        -: 6112:        void endRun() {
        -: 6113:            m_rootTracker.reset();
        -: 6114:            m_currentTracker = CATCH_NULL;
        -: 6115:            m_runState = NotStarted;
        -: 6116:        }
        -: 6117:
        6: 6118:        void startCycle() {
        6: 6119:            m_currentTracker = m_rootTracker.get();
        6: 6120:            m_runState = Executing;
        6: 6121:        }
       12: 6122:        void completeCycle() {
       12: 6123:            m_runState = CompletedCycle;
       12: 6124:        }
        -: 6125:
       42: 6126:        bool completedCycle() const {
       42: 6127:            return m_runState == CompletedCycle;
        -: 6128:        }
       54: 6129:        ITracker& currentTracker() {
       54: 6130:            return *m_currentTracker;
        -: 6131:        }
       24: 6132:        void setCurrentTracker( ITracker* tracker ) {
       24: 6133:            m_currentTracker = tracker;
       24: 6134:        }
        -: 6135:    };
        -: 6136:
        -: 6137:    class TrackerBase : public ITracker {
        -: 6138:    protected:
        -: 6139:        enum CycleState {
        -: 6140:            NotStarted,
        -: 6141:            Executing,
        -: 6142:            ExecutingChildren,
        -: 6143:            NeedsAnotherRun,
        -: 6144:            CompletedSuccessfully,
        -: 6145:            Failed
        -: 6146:        };
        -: 6147:        class TrackerHasName {
        -: 6148:            NameAndLocation m_nameAndLocation;
        -: 6149:        public:
       42: 6150:            TrackerHasName( NameAndLocation const& nameAndLocation ) : m_nameAndLocation( nameAndLocation ) {}
      125: 6151:            bool operator ()( Ptr<ITracker> const& tracker ) {
        -: 6152:                return
      160: 6153:                    tracker->nameAndLocation().name == m_nameAndLocation.name &&
      160: 6154:                    tracker->nameAndLocation().location == m_nameAndLocation.location;
        -: 6155:            }
        -: 6156:        };
        -: 6157:        typedef std::vector<Ptr<ITracker> > Children;
        -: 6158:        NameAndLocation m_nameAndLocation;
        -: 6159:        TrackerContext& m_ctx;
        -: 6160:        ITracker* m_parent;
        -: 6161:        Children m_children;
        -: 6162:        CycleState m_runState;
        -: 6163:    public:
        8: 6164:        TrackerBase( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
        8: 6165:        :   m_nameAndLocation( nameAndLocation ),
        -: 6166:            m_ctx( ctx ),
        -: 6167:            m_parent( parent ),
        8: 6168:            m_runState( NotStarted )
        8: 6169:        {}
        -: 6170:        virtual ~TrackerBase();
        -: 6171:
      160: 6172:        virtual NameAndLocation const& nameAndLocation() const CATCH_OVERRIDE {
      160: 6173:            return m_nameAndLocation;
        -: 6174:        }
       54: 6175:        virtual bool isComplete() const CATCH_OVERRIDE {
       54: 6176:            return m_runState == CompletedSuccessfully || m_runState == Failed;
        -: 6177:        }
        6: 6178:        virtual bool isSuccessfullyCompleted() const CATCH_OVERRIDE {
        6: 6179:            return m_runState == CompletedSuccessfully;
        -: 6180:        }
       36: 6181:        virtual bool isOpen() const CATCH_OVERRIDE {
       36: 6182:            return m_runState != NotStarted && !isComplete();
        -: 6183:        }
    #####: 6184:        virtual bool hasChildren() const CATCH_OVERRIDE {
    #####: 6185:            return !m_children.empty();
        -: 6186:        }
        -: 6187:
        7: 6188:        virtual void addChild( Ptr<ITracker> const& child ) CATCH_OVERRIDE {
        7: 6189:            m_children.push_back( child );
        7: 6190:        }
        -: 6191:
       42: 6192:        virtual ITracker* findChild( NameAndLocation const& nameAndLocation ) CATCH_OVERRIDE {
       42: 6193:            Children::const_iterator it = std::find_if( m_children.begin(), m_children.end(), TrackerHasName( nameAndLocation ) );
       42: 6194:            return( it != m_children.end() )
       42: 6195:                ? it->get()
       42: 6196:                : CATCH_NULL;
        -: 6197:        }
    #####: 6198:        virtual ITracker& parent() CATCH_OVERRIDE {
    #####: 6199:            assert( m_parent ); // Should always be non-null except for root
    #####: 6200:            return *m_parent;
        -: 6201:        }
        -: 6202:
       18: 6203:        virtual void openChild() CATCH_OVERRIDE {
       18: 6204:            if( m_runState != ExecutingChildren ) {
        7: 6205:                m_runState = ExecutingChildren;
        7: 6206:                if( m_parent )
        6: 6207:                    m_parent->openChild();
        -: 6208:            }
       18: 6209:        }
        -: 6210:
    #####: 6211:        virtual bool isSectionTracker() const CATCH_OVERRIDE { return false; }
    #####: 6212:        virtual bool isIndexTracker() const CATCH_OVERRIDE { return false; }
        -: 6213:
       12: 6214:        void open() {
       12: 6215:            m_runState = Executing;
       12: 6216:            moveToThis();
       12: 6217:            if( m_parent )
       12: 6218:                m_parent->openChild();
       12: 6219:        }
        -: 6220:
       12: 6221:        virtual void close() CATCH_OVERRIDE {
        -: 6222:
        -: 6223:            // Close any still open children (e.g. generators)
      12*: 6224:            while( &m_ctx.currentTracker() != this )
    #####: 6225:                m_ctx.currentTracker().close();
        -: 6226:
       12: 6227:            switch( m_runState ) {
    #####: 6228:                case NotStarted:
        -: 6229:                case CompletedSuccessfully:
        -: 6230:                case Failed:
    #####: 6231:                    throw std::logic_error( "Illogical state" );
        -: 6232:
    #####: 6233:                case NeedsAnotherRun:
    #####: 6234:                    break;;
        -: 6235:
        6: 6236:                case Executing:
        6: 6237:                    m_runState = CompletedSuccessfully;
        6: 6238:                    break;
        6: 6239:                case ExecutingChildren:
        6: 6240:                    if( m_children.empty() || m_children.back()->isComplete() )
        1: 6241:                        m_runState = CompletedSuccessfully;
        6: 6242:                    break;
        -: 6243:
    #####: 6244:                default:
    #####: 6245:                    throw std::logic_error( "Unexpected state" );
        -: 6246:            }
       12: 6247:            moveToParent();
       12: 6248:            m_ctx.completeCycle();
       12: 6249:        }
    #####: 6250:        virtual void fail() CATCH_OVERRIDE {
    #####: 6251:            m_runState = Failed;
    #####: 6252:            if( m_parent )
    #####: 6253:                m_parent->markAsNeedingAnotherRun();
    #####: 6254:            moveToParent();
    #####: 6255:            m_ctx.completeCycle();
    #####: 6256:        }
    #####: 6257:        virtual void markAsNeedingAnotherRun() CATCH_OVERRIDE {
    #####: 6258:            m_runState = NeedsAnotherRun;
    #####: 6259:        }
        -: 6260:    private:
       12: 6261:        void moveToParent() {
      12*: 6262:            assert( m_parent );
       12: 6263:            m_ctx.setCurrentTracker( m_parent );
       12: 6264:        }
       12: 6265:        void moveToThis() {
       12: 6266:            m_ctx.setCurrentTracker( this );
       12: 6267:        }
        -: 6268:    };
        -: 6269:
        -: 6270:    class SectionTracker : public TrackerBase {
        -: 6271:        std::vector<std::string> m_filters;
        -: 6272:    public:
        8: 6273:        SectionTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent )
        8: 6274:        :   TrackerBase( nameAndLocation, ctx, parent )
        -: 6275:        {
        8: 6276:            if( parent ) {
       7*: 6277:                while( !parent->isSectionTracker() )
    #####: 6278:                    parent = &parent->parent();
        -: 6279:
        7: 6280:                SectionTracker& parentSection = static_cast<SectionTracker&>( *parent );
        7: 6281:                addNextFilters( parentSection.m_filters );
        -: 6282:            }
        8: 6283:        }
        -: 6284:        virtual ~SectionTracker();
        -: 6285:
       43: 6286:        virtual bool isSectionTracker() const CATCH_OVERRIDE { return true; }
        -: 6287:
       42: 6288:        static SectionTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation ) {
       42: 6289:            SectionTracker* section = CATCH_NULL;
        -: 6290:
       42: 6291:            ITracker& currentTracker = ctx.currentTracker();
       42: 6292:            if( ITracker* childTracker = currentTracker.findChild( nameAndLocation ) ) {
      35*: 6293:                assert( childTracker );
      35*: 6294:                assert( childTracker->isSectionTracker() );
       35: 6295:                section = static_cast<SectionTracker*>( childTracker );
        -: 6296:            }
        -: 6297:            else {
        7: 6298:                section = new SectionTracker( nameAndLocation, ctx, &currentTracker );
        7: 6299:                currentTracker.addChild( section );
        -: 6300:            }
       42: 6301:            if( !ctx.completedCycle() )
       27: 6302:                section->tryOpen();
       42: 6303:            return *section;
        -: 6304:        }
        -: 6305:
       27: 6306:        void tryOpen() {
      27*: 6307:            if( !isComplete() && (m_filters.empty() || m_filters[0].empty() ||  m_filters[0] == m_nameAndLocation.name ) )
       12: 6308:                open();
       27: 6309:        }
        -: 6310:
        1: 6311:        void addInitialFilters( std::vector<std::string> const& filters ) {
        1: 6312:            if( !filters.empty() ) {
    #####: 6313:                m_filters.push_back(""); // Root - should never be consulted
    #####: 6314:                m_filters.push_back(""); // Test Case - not a section filter
    #####: 6315:                m_filters.insert( m_filters.end(), filters.begin(), filters.end() );
        -: 6316:            }
        1: 6317:        }
        7: 6318:        void addNextFilters( std::vector<std::string> const& filters ) {
        7: 6319:            if( filters.size() > 1 )
    #####: 6320:                m_filters.insert( m_filters.end(), ++filters.begin(), filters.end() );
        7: 6321:        }
        -: 6322:    };
        -: 6323:
        -: 6324:    class IndexTracker : public TrackerBase {
        -: 6325:        int m_size;
        -: 6326:        int m_index;
        -: 6327:    public:
        -: 6328:        IndexTracker( NameAndLocation const& nameAndLocation, TrackerContext& ctx, ITracker* parent, int size )
        -: 6329:        :   TrackerBase( nameAndLocation, ctx, parent ),
        -: 6330:            m_size( size ),
        -: 6331:            m_index( -1 )
        -: 6332:        {}
        -: 6333:        virtual ~IndexTracker();
        -: 6334:
    #####: 6335:        virtual bool isIndexTracker() const CATCH_OVERRIDE { return true; }
        -: 6336:
        -: 6337:        static IndexTracker& acquire( TrackerContext& ctx, NameAndLocation const& nameAndLocation, int size ) {
        -: 6338:            IndexTracker* tracker = CATCH_NULL;
        -: 6339:
        -: 6340:            ITracker& currentTracker = ctx.currentTracker();
        -: 6341:            if( ITracker* childTracker = currentTracker.findChild( nameAndLocation ) ) {
        -: 6342:                assert( childTracker );
        -: 6343:                assert( childTracker->isIndexTracker() );
        -: 6344:                tracker = static_cast<IndexTracker*>( childTracker );
        -: 6345:            }
        -: 6346:            else {
        -: 6347:                tracker = new IndexTracker( nameAndLocation, ctx, &currentTracker, size );
        -: 6348:                currentTracker.addChild( tracker );
        -: 6349:            }
        -: 6350:
        -: 6351:            if( !ctx.completedCycle() && !tracker->isComplete() ) {
        -: 6352:                if( tracker->m_runState != ExecutingChildren && tracker->m_runState != NeedsAnotherRun )
        -: 6353:                    tracker->moveNext();
        -: 6354:                tracker->open();
        -: 6355:            }
        -: 6356:
        -: 6357:            return *tracker;
        -: 6358:        }
        -: 6359:
        -: 6360:        int index() const { return m_index; }
        -: 6361:
        -: 6362:        void moveNext() {
        -: 6363:            m_index++;
        -: 6364:            m_children.clear();
        -: 6365:        }
        -: 6366:
    #####: 6367:        virtual void close() CATCH_OVERRIDE {
    #####: 6368:            TrackerBase::close();
    #####: 6369:            if( m_runState == CompletedSuccessfully && m_index < m_size-1 )
    #####: 6370:                m_runState = Executing;
    #####: 6371:        }
        -: 6372:    };
        -: 6373:
        1: 6374:    inline ITracker& TrackerContext::startRun() {
        1: 6375:        m_rootTracker = new SectionTracker( NameAndLocation( "{root}", CATCH_INTERNAL_LINEINFO ), *this, CATCH_NULL );
        1: 6376:        m_currentTracker = CATCH_NULL;
        1: 6377:        m_runState = Executing;
        1: 6378:        return *m_rootTracker;
        -: 6379:    }
        -: 6380:
        -: 6381:} // namespace TestCaseTracking
        -: 6382:
        -: 6383:using TestCaseTracking::ITracker;
        -: 6384:using TestCaseTracking::TrackerContext;
        -: 6385:using TestCaseTracking::SectionTracker;
        -: 6386:using TestCaseTracking::IndexTracker;
        -: 6387:
        -: 6388:} // namespace Catch
        -: 6389:
        -: 6390:CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS
        -: 6391:
        -: 6392:// #included from: catch_fatal_condition.hpp
        -: 6393:#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED
        -: 6394:
        -: 6395:namespace Catch {
        -: 6396:
        -: 6397:    // Report the error condition
    #####: 6398:    inline void reportFatal( std::string const& message ) {
    #####: 6399:        IContext& context = Catch::getCurrentContext();
    #####: 6400:        IResultCapture* resultCapture = context.getResultCapture();
    #####: 6401:        resultCapture->handleFatalErrorCondition( message );
    #####: 6402:    }
        -: 6403:
        -: 6404:} // namespace Catch
        -: 6405:
        -: 6406:#if defined ( CATCH_PLATFORM_WINDOWS ) /////////////////////////////////////////
        -: 6407:// #included from: catch_windows_h_proxy.h
        -: 6408:
        -: 6409:#define TWOBLUECUBES_CATCH_WINDOWS_H_PROXY_H_INCLUDED
        -: 6410:
        -: 6411:#ifdef CATCH_DEFINES_NOMINMAX
        -: 6412:#  define NOMINMAX
        -: 6413:#endif
        -: 6414:#ifdef CATCH_DEFINES_WIN32_LEAN_AND_MEAN
        -: 6415:#  define WIN32_LEAN_AND_MEAN
        -: 6416:#endif
        -: 6417:
        -: 6418:#ifdef __AFXDLL
        -: 6419:#include <AfxWin.h>
        -: 6420:#else
        -: 6421:#include <windows.h>
        -: 6422:#endif
        -: 6423:
        -: 6424:#ifdef CATCH_DEFINES_NOMINMAX
        -: 6425:#  undef NOMINMAX
        -: 6426:#endif
        -: 6427:#ifdef CATCH_DEFINES_WIN32_LEAN_AND_MEAN
        -: 6428:#  undef WIN32_LEAN_AND_MEAN
        -: 6429:#endif
        -: 6430:
        -: 6431:
        -: 6432:#  if !defined ( CATCH_CONFIG_WINDOWS_SEH )
        -: 6433:
        -: 6434:namespace Catch {
        -: 6435:    struct FatalConditionHandler {
        -: 6436:        void reset() {}
        -: 6437:    };
        -: 6438:}
        -: 6439:
        -: 6440:#  else // CATCH_CONFIG_WINDOWS_SEH is defined
        -: 6441:
        -: 6442:namespace Catch {
        -: 6443:
        -: 6444:    struct SignalDefs { DWORD id; const char* name; };
        -: 6445:    extern SignalDefs signalDefs[];
        -: 6446:    // There is no 1-1 mapping between signals and windows exceptions.
        -: 6447:    // Windows can easily distinguish between SO and SigSegV,
        -: 6448:    // but SigInt, SigTerm, etc are handled differently.
        -: 6449:    SignalDefs signalDefs[] = {
        -: 6450:        { EXCEPTION_ILLEGAL_INSTRUCTION,  "SIGILL - Illegal instruction signal" },
        -: 6451:        { EXCEPTION_STACK_OVERFLOW, "SIGSEGV - Stack overflow" },
        -: 6452:        { EXCEPTION_ACCESS_VIOLATION, "SIGSEGV - Segmentation violation signal" },
        -: 6453:        { EXCEPTION_INT_DIVIDE_BY_ZERO, "Divide by zero error" },
        -: 6454:    };
        -: 6455:
        -: 6456:    struct FatalConditionHandler {
        -: 6457:
        -: 6458:        static LONG CALLBACK handleVectoredException(PEXCEPTION_POINTERS ExceptionInfo) {
        -: 6459:            for (int i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
        -: 6460:                if (ExceptionInfo->ExceptionRecord->ExceptionCode == signalDefs[i].id) {
        -: 6461:                    reportFatal(signalDefs[i].name);
        -: 6462:                }
        -: 6463:            }
        -: 6464:            // If its not an exception we care about, pass it along.
        -: 6465:            // This stops us from eating debugger breaks etc.
        -: 6466:            return EXCEPTION_CONTINUE_SEARCH;
        -: 6467:        }
        -: 6468:
        -: 6469:        FatalConditionHandler() {
        -: 6470:            isSet = true;
        -: 6471:            // 32k seems enough for Catch to handle stack overflow,
        -: 6472:            // but the value was found experimentally, so there is no strong guarantee
        -: 6473:            guaranteeSize = 32 * 1024;
        -: 6474:            exceptionHandlerHandle = CATCH_NULL;
        -: 6475:            // Register as first handler in current chain
        -: 6476:            exceptionHandlerHandle = AddVectoredExceptionHandler(1, handleVectoredException);
        -: 6477:            // Pass in guarantee size to be filled
        -: 6478:            SetThreadStackGuarantee(&guaranteeSize);
        -: 6479:        }
        -: 6480:
        -: 6481:        static void reset() {
        -: 6482:            if (isSet) {
        -: 6483:                // Unregister handler and restore the old guarantee
        -: 6484:                RemoveVectoredExceptionHandler(exceptionHandlerHandle);
        -: 6485:                SetThreadStackGuarantee(&guaranteeSize);
        -: 6486:                exceptionHandlerHandle = CATCH_NULL;
        -: 6487:                isSet = false;
        -: 6488:            }
        -: 6489:        }
        -: 6490:
        -: 6491:        ~FatalConditionHandler() {
        -: 6492:            reset();
        -: 6493:        }
        -: 6494:    private:
        -: 6495:        static bool isSet;
        -: 6496:        static ULONG guaranteeSize;
        -: 6497:        static PVOID exceptionHandlerHandle;
        -: 6498:    };
        -: 6499:
        -: 6500:    bool FatalConditionHandler::isSet = false;
        -: 6501:    ULONG FatalConditionHandler::guaranteeSize = 0;
        -: 6502:    PVOID FatalConditionHandler::exceptionHandlerHandle = CATCH_NULL;
        -: 6503:
        -: 6504:} // namespace Catch
        -: 6505:
        -: 6506:#  endif // CATCH_CONFIG_WINDOWS_SEH
        -: 6507:
        -: 6508:#else // Not Windows - assumed to be POSIX compatible //////////////////////////
        -: 6509:
        -: 6510:#  if !defined(CATCH_CONFIG_POSIX_SIGNALS)
        -: 6511:
        -: 6512:namespace Catch {
        -: 6513:    struct FatalConditionHandler {
        -: 6514:        void reset() {}
        -: 6515:    };
        -: 6516:}
        -: 6517:
        -: 6518:#  else // CATCH_CONFIG_POSIX_SIGNALS is defined
        -: 6519:
        -: 6520:#include <signal.h>
        -: 6521:
        -: 6522:namespace Catch {
        -: 6523:
        -: 6524:    struct SignalDefs {
        -: 6525:        int id;
        -: 6526:        const char* name;
        -: 6527:    };
        -: 6528:    extern SignalDefs signalDefs[];
        -: 6529:    SignalDefs signalDefs[] = {
        -: 6530:            { SIGINT,  "SIGINT - Terminal interrupt signal" },
        -: 6531:            { SIGILL,  "SIGILL - Illegal instruction signal" },
        -: 6532:            { SIGFPE,  "SIGFPE - Floating point error signal" },
        -: 6533:            { SIGSEGV, "SIGSEGV - Segmentation violation signal" },
        -: 6534:            { SIGTERM, "SIGTERM - Termination request signal" },
        -: 6535:            { SIGABRT, "SIGABRT - Abort (abnormal termination) signal" }
        -: 6536:    };
        -: 6537:
        -: 6538:    struct FatalConditionHandler {
        -: 6539:
        -: 6540:        static bool isSet;
        -: 6541:        static struct sigaction oldSigActions [sizeof(signalDefs)/sizeof(SignalDefs)];
        -: 6542:        static stack_t oldSigStack;
        -: 6543:        static char altStackMem[SIGSTKSZ];
        -: 6544:
    #####: 6545:        static void handleSignal( int sig ) {
    #####: 6546:            std::string name = "<unknown signal>";
    #####: 6547:            for (std::size_t i = 0; i < sizeof(signalDefs) / sizeof(SignalDefs); ++i) {
    #####: 6548:                SignalDefs &def = signalDefs[i];
    #####: 6549:                if (sig == def.id) {
    #####: 6550:                    name = def.name;
    #####: 6551:                    break;
        -: 6552:                }
        -: 6553:            }
    #####: 6554:            reset();
    #####: 6555:            reportFatal(name);
    #####: 6556:            raise( sig );
    #####: 6557:        }
        -: 6558:
        6: 6559:        FatalConditionHandler() {
        6: 6560:            isSet = true;
        -: 6561:            stack_t sigStack;
        6: 6562:            sigStack.ss_sp = altStackMem;
        6: 6563:            sigStack.ss_size = SIGSTKSZ;
        6: 6564:            sigStack.ss_flags = 0;
        6: 6565:            sigaltstack(&sigStack, &oldSigStack);
        6: 6566:            struct sigaction sa = { 0 };
        -: 6567:
        6: 6568:            sa.sa_handler = handleSignal;
        6: 6569:            sa.sa_flags = SA_ONSTACK;
       42: 6570:            for (std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i) {
       36: 6571:                sigaction(signalDefs[i].id, &sa, &oldSigActions[i]);
        -: 6572:            }
        6: 6573:        }
        -: 6574:
        6: 6575:        ~FatalConditionHandler() {
        6: 6576:            reset();
        6: 6577:        }
       12: 6578:        static void reset() {
       12: 6579:            if( isSet ) {
        -: 6580:                // Set signals back to previous values -- hopefully nobody overwrote them in the meantime
       42: 6581:                for( std::size_t i = 0; i < sizeof(signalDefs)/sizeof(SignalDefs); ++i ) {
       36: 6582:                    sigaction(signalDefs[i].id, &oldSigActions[i], CATCH_NULL);
        -: 6583:                }
        -: 6584:                // Return the old stack
        6: 6585:                sigaltstack(&oldSigStack, CATCH_NULL);
        6: 6586:                isSet = false;
        -: 6587:            }
       12: 6588:        }
        -: 6589:    };
        -: 6590:
        -: 6591:    bool FatalConditionHandler::isSet = false;
        -: 6592:    struct sigaction FatalConditionHandler::oldSigActions[sizeof(signalDefs)/sizeof(SignalDefs)] = {};
        -: 6593:    stack_t FatalConditionHandler::oldSigStack = {};
        -: 6594:    char FatalConditionHandler::altStackMem[SIGSTKSZ] = {};
        -: 6595:
        -: 6596:} // namespace Catch
        -: 6597:
        -: 6598:#  endif // CATCH_CONFIG_POSIX_SIGNALS
        -: 6599:
        -: 6600:#endif // not Windows
        -: 6601:
        -: 6602:#include <set>
        -: 6603:#include <string>
        -: 6604:
        -: 6605:namespace Catch {
        -: 6606:
        -: 6607:    class StreamRedirect {
        -: 6608:
        -: 6609:    public:
    #####: 6610:        StreamRedirect( std::ostream& stream, std::string& targetString )
    #####: 6611:        :   m_stream( stream ),
    #####: 6612:            m_prevBuf( stream.rdbuf() ),
    #####: 6613:            m_targetString( targetString )
        -: 6614:        {
    #####: 6615:            stream.rdbuf( m_oss.rdbuf() );
    #####: 6616:        }
        -: 6617:
    #####: 6618:        ~StreamRedirect() {
    #####: 6619:            m_targetString += m_oss.str();
    #####: 6620:            m_stream.rdbuf( m_prevBuf );
    #####: 6621:        }
        -: 6622:
        -: 6623:    private:
        -: 6624:        std::ostream& m_stream;
        -: 6625:        std::streambuf* m_prevBuf;
        -: 6626:        std::ostringstream m_oss;
        -: 6627:        std::string& m_targetString;
        -: 6628:    };
        -: 6629:
        -: 6630:    // StdErr has two constituent streams in C++, std::cerr and std::clog
        -: 6631:    // This means that we need to redirect 2 streams into 1 to keep proper
        -: 6632:    // order of writes and cannot use StreamRedirect on its own
        -: 6633:    class StdErrRedirect {
        -: 6634:    public:
    #####: 6635:        StdErrRedirect(std::string& targetString)
    #####: 6636:        :m_cerrBuf( cerr().rdbuf() ), m_clogBuf(clog().rdbuf()),
    #####: 6637:        m_targetString(targetString){
    #####: 6638:            cerr().rdbuf(m_oss.rdbuf());
    #####: 6639:            clog().rdbuf(m_oss.rdbuf());
    #####: 6640:        }
    #####: 6641:        ~StdErrRedirect() {
    #####: 6642:            m_targetString += m_oss.str();
    #####: 6643:            cerr().rdbuf(m_cerrBuf);
    #####: 6644:            clog().rdbuf(m_clogBuf);
    #####: 6645:        }
        -: 6646:    private:
        -: 6647:        std::streambuf* m_cerrBuf;
        -: 6648:        std::streambuf* m_clogBuf;
        -: 6649:        std::ostringstream m_oss;
        -: 6650:        std::string& m_targetString;
        -: 6651:    };
        -: 6652:
        -: 6653:    ///////////////////////////////////////////////////////////////////////////
        -: 6654:
        -: 6655:    class RunContext : public IResultCapture, public IRunner {
        -: 6656:
        -: 6657:        RunContext( RunContext const& );
        -: 6658:        void operator =( RunContext const& );
        -: 6659:
        -: 6660:    public:
        -: 6661:
        1: 6662:        explicit RunContext( Ptr<IConfig const> const& _config, Ptr<IStreamingReporter> const& reporter )
        2: 6663:        :   m_runInfo( _config->name() ),
        1: 6664:            m_context( getCurrentMutableContext() ),
        -: 6665:            m_activeTestCase( CATCH_NULL ),
        -: 6666:            m_config( _config ),
        -: 6667:            m_reporter( reporter ),
        3: 6668:            m_shouldReportUnexpected ( true )
        -: 6669:        {
        1: 6670:            m_context.setRunner( this );
        1: 6671:            m_context.setConfig( m_config );
        1: 6672:            m_context.setResultCapture( this );
        1: 6673:            m_reporter->testRunStarting( m_runInfo );
        1: 6674:        }
        -: 6675:
       1*: 6676:        virtual ~RunContext() {
        1: 6677:            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );
       1*: 6678:        }
------------------
_ZN5Catch10RunContextD0Ev:
    #####: 6676:        virtual ~RunContext() {
        -: 6677:            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );
    #####: 6678:        }
------------------
_ZN5Catch10RunContextD2Ev:
        1: 6676:        virtual ~RunContext() {
        1: 6677:            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, aborting() ) );
        1: 6678:        }
------------------
        -: 6679:
        1: 6680:        void testGroupStarting( std::string const& testSpec, std::size_t groupIndex, std::size_t groupsCount ) {
        1: 6681:            m_reporter->testGroupStarting( GroupInfo( testSpec, groupIndex, groupsCount ) );
        1: 6682:        }
        1: 6683:        void testGroupEnded( std::string const& testSpec, Totals const& totals, std::size_t groupIndex, std::size_t groupsCount ) {
        1: 6684:            m_reporter->testGroupEnded( TestGroupStats( GroupInfo( testSpec, groupIndex, groupsCount ), totals, aborting() ) );
        1: 6685:        }
        -: 6686:
        1: 6687:        Totals runTest( TestCase const& testCase ) {
        1: 6688:            Totals prevTotals = m_totals;
        -: 6689:
        2: 6690:            std::string redirectedCout;
        2: 6691:            std::string redirectedCerr;
        -: 6692:
        2: 6693:            TestCaseInfo testInfo = testCase.getTestCaseInfo();
        -: 6694:
        1: 6695:            m_reporter->testCaseStarting( testInfo );
        -: 6696:
        1: 6697:            m_activeTestCase = &testCase;
        -: 6698:
    #####: 6699:            do {
        1: 6700:                ITracker& rootTracker = m_trackerContext.startRun();
       1*: 6701:                assert( rootTracker.isSectionTracker() );
        1: 6702:                static_cast<SectionTracker&>( rootTracker ).addInitialFilters( m_config->getSectionsToRun() );
        5: 6703:                do {
        6: 6704:                    m_trackerContext.startCycle();
        6: 6705:                    m_testCaseTracker = &SectionTracker::acquire( m_trackerContext, TestCaseTracking::NameAndLocation( testInfo.name, testInfo.lineInfo ) );
        6: 6706:                    runCurrentTest( redirectedCout, redirectedCerr );
        -: 6707:                }
        6: 6708:                while( !m_testCaseTracker->isSuccessfullyCompleted() && !aborting() );
        -: 6709:            }
        -: 6710:            // !TBD: deprecated - this will be replaced by indexed trackers
       1*: 6711:            while( getCurrentContext().advanceGeneratorsForCurrentTest() && !aborting() );
        -: 6712:
        1: 6713:            Totals deltaTotals = m_totals.delta( prevTotals );
       1*: 6714:            if( testInfo.expectedToFail() && deltaTotals.testCases.passed > 0 ) {
    #####: 6715:                deltaTotals.assertions.failed++;
    #####: 6716:                deltaTotals.testCases.passed--;
    #####: 6717:                deltaTotals.testCases.failed++;
        -: 6718:            }
        1: 6719:            m_totals.testCases += deltaTotals.testCases;
        2: 6720:            m_reporter->testCaseEnded( TestCaseStats(   testInfo,
        -: 6721:                                                        deltaTotals,
        -: 6722:                                                        redirectedCout,
        -: 6723:                                                        redirectedCerr,
        1: 6724:                                                        aborting() ) );
        -: 6725:
        1: 6726:            m_activeTestCase = CATCH_NULL;
        1: 6727:            m_testCaseTracker = CATCH_NULL;
        -: 6728:
        2: 6729:            return deltaTotals;
        -: 6730:        }
        -: 6731:
        -: 6732:        Ptr<IConfig const> config() const {
        -: 6733:            return m_config;
        -: 6734:        }
        -: 6735:
        -: 6736:    private: // IResultCapture
        -: 6737:
    #####: 6738:        virtual void assertionEnded( AssertionResult const& result ) {
    #####: 6739:            if( result.getResultType() == ResultWas::Ok ) {
    #####: 6740:                m_totals.assertions.passed++;
        -: 6741:            }
    #####: 6742:            else if( !result.isOk() ) {
    #####: 6743:                if( m_activeTestCase->getTestCaseInfo().okToFail() )
    #####: 6744:                    m_totals.assertions.failedButOk++;
        -: 6745:                else
    #####: 6746:                    m_totals.assertions.failed++;
        -: 6747:            }
        -: 6748:
        -: 6749:            // We have no use for the return value (whether messages should be cleared), because messages were made scoped
        -: 6750:            // and should be let to clear themselves out.
    #####: 6751:            static_cast<void>(m_reporter->assertionEnded(AssertionStats(result, m_messages, m_totals)));
        -: 6752:
        -: 6753:            // Reset working state
    #####: 6754:            m_lastAssertionInfo = AssertionInfo( "", m_lastAssertionInfo.lineInfo, "{Unknown expression after the reported line}" , m_lastAssertionInfo.resultDisposition );
    #####: 6755:            m_lastResult = result;
    #####: 6756:        }
        -: 6757:
    #####: 6758:        virtual bool lastAssertionPassed()
        -: 6759:        {
    #####: 6760:            return m_totals.assertions.passed == (m_prevPassed + 1);
        -: 6761:        }
        -: 6762:
        6: 6763:        virtual void assertionPassed()
        -: 6764:        {
        6: 6765:            m_totals.assertions.passed++;
        6: 6766:            m_lastAssertionInfo.capturedExpression = "{Unknown expression after the reported line}";
        6: 6767:            m_lastAssertionInfo.macroName = "";
        6: 6768:        }
        -: 6769:
        6: 6770:        virtual void assertionRun()
        -: 6771:        {
        6: 6772:            m_prevPassed = m_totals.assertions.passed;
        6: 6773:        }
        -: 6774:
       36: 6775:        virtual bool sectionStarted (
        -: 6776:            SectionInfo const& sectionInfo,
        -: 6777:            Counts& assertions
        -: 6778:        )
        -: 6779:        {
       36: 6780:            ITracker& sectionTracker = SectionTracker::acquire( m_trackerContext, TestCaseTracking::NameAndLocation( sectionInfo.name, sectionInfo.lineInfo ) );
       36: 6781:            if( !sectionTracker.isOpen() )
       30: 6782:                return false;
        6: 6783:            m_activeSections.push_back( &sectionTracker );
        -: 6784:
        6: 6785:            m_lastAssertionInfo.lineInfo = sectionInfo.lineInfo;
        -: 6786:
        6: 6787:            m_reporter->sectionStarting( sectionInfo );
        -: 6788:
        6: 6789:            assertions = m_totals.assertions;
        -: 6790:
        6: 6791:            return true;
        -: 6792:        }
       12: 6793:        bool testForMissingAssertions( Counts& assertions ) {
       12: 6794:            if( assertions.total() != 0 )
       12: 6795:                return false;
    #####: 6796:            if( !m_config->warnAboutMissingAssertions() )
    #####: 6797:                return false;
    #####: 6798:            if( m_trackerContext.currentTracker().hasChildren() )
    #####: 6799:                return false;
    #####: 6800:            m_totals.assertions.failed++;
    #####: 6801:            assertions.failed++;
    #####: 6802:            return true;
        -: 6803:        }
        -: 6804:
        6: 6805:        virtual void sectionEnded( SectionEndInfo const& endInfo ) {
        6: 6806:            Counts assertions = m_totals.assertions - endInfo.prevAssertions;
        6: 6807:            bool missingAssertions = testForMissingAssertions( assertions );
        -: 6808:
        6: 6809:            if( !m_activeSections.empty() ) {
        6: 6810:                m_activeSections.back()->close();
        6: 6811:                m_activeSections.pop_back();
        -: 6812:            }
        -: 6813:
        6: 6814:            m_reporter->sectionEnded( SectionStats( endInfo.sectionInfo, assertions, endInfo.durationInSeconds, missingAssertions ) );
        6: 6815:            m_messages.clear();
        6: 6816:        }
        -: 6817:
    #####: 6818:        virtual void sectionEndedEarly( SectionEndInfo const& endInfo ) {
    #####: 6819:            if( m_unfinishedSections.empty() )
    #####: 6820:                m_activeSections.back()->fail();
        -: 6821:            else
    #####: 6822:                m_activeSections.back()->close();
    #####: 6823:            m_activeSections.pop_back();
        -: 6824:
    #####: 6825:            m_unfinishedSections.push_back( endInfo );
    #####: 6826:        }
        -: 6827:
    #####: 6828:        virtual void pushScopedMessage( MessageInfo const& message ) {
    #####: 6829:            m_messages.push_back( message );
    #####: 6830:        }
        -: 6831:
    #####: 6832:        virtual void popScopedMessage( MessageInfo const& message ) {
    #####: 6833:            m_messages.erase( std::remove( m_messages.begin(), m_messages.end(), message ), m_messages.end() );
    #####: 6834:        }
        -: 6835:
        1: 6836:        virtual std::string getCurrentTestName() const {
        1: 6837:            return m_activeTestCase
        1: 6838:                ? m_activeTestCase->getTestCaseInfo().name
       2*: 6839:                : std::string();
        -: 6840:        }
        -: 6841:
    #####: 6842:        virtual const AssertionResult* getLastResult() const {
    #####: 6843:            return &m_lastResult;
        -: 6844:        }
        -: 6845:
    #####: 6846:        virtual void exceptionEarlyReported() {
    #####: 6847:            m_shouldReportUnexpected = false;
    #####: 6848:        }
        -: 6849:
    #####: 6850:        virtual void handleFatalErrorCondition( std::string const& message ) {
        -: 6851:            // Don't rebuild the result -- the stringification itself can cause more fatal errors
        -: 6852:            // Instead, fake a result data.
    #####: 6853:            AssertionResultData tempResult;
    #####: 6854:            tempResult.resultType = ResultWas::FatalErrorCondition;
    #####: 6855:            tempResult.message = message;
    #####: 6856:            AssertionResult result(m_lastAssertionInfo, tempResult);
        -: 6857:
    #####: 6858:            getResultCapture().assertionEnded(result);
        -: 6859:
    #####: 6860:            handleUnfinishedSections();
        -: 6861:
        -: 6862:            // Recreate section for test case (as we will lose the one that was in scope)
    #####: 6863:            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
    #####: 6864:            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );
        -: 6865:
    #####: 6866:            Counts assertions;
    #####: 6867:            assertions.failed = 1;
    #####: 6868:            SectionStats testCaseSectionStats( testCaseSection, assertions, 0, false );
    #####: 6869:            m_reporter->sectionEnded( testCaseSectionStats );
        -: 6870:
    #####: 6871:            TestCaseInfo testInfo = m_activeTestCase->getTestCaseInfo();
        -: 6872:
    #####: 6873:            Totals deltaTotals;
    #####: 6874:            deltaTotals.testCases.failed = 1;
    #####: 6875:            deltaTotals.assertions.failed = 1;
    #####: 6876:            m_reporter->testCaseEnded( TestCaseStats(   testInfo,
        -: 6877:                                                        deltaTotals,
    #####: 6878:                                                        std::string(),
    #####: 6879:                                                        std::string(),
    #####: 6880:                                                        false ) );
    #####: 6881:            m_totals.testCases.failed++;
    #####: 6882:            testGroupEnded( std::string(), m_totals, 1, 1 );
    #####: 6883:            m_reporter->testRunEnded( TestRunStats( m_runInfo, m_totals, false ) );
    #####: 6884:        }
        -: 6885:
        -: 6886:    public:
        -: 6887:        // !TBD We need to do this another way!
        9: 6888:        bool aborting() const {
        9: 6889:            return m_totals.assertions.failed == static_cast<std::size_t>( m_config->abortAfter() );
        -: 6890:        }
        -: 6891:
        -: 6892:    private:
        -: 6893:
        6: 6894:        void runCurrentTest( std::string& redirectedCout, std::string& redirectedCerr ) {
        6: 6895:            TestCaseInfo const& testCaseInfo = m_activeTestCase->getTestCaseInfo();
       12: 6896:            SectionInfo testCaseSection( testCaseInfo.lineInfo, testCaseInfo.name, testCaseInfo.description );
        6: 6897:            m_reporter->sectionStarting( testCaseSection );
        6: 6898:            Counts prevAssertions = m_totals.assertions;
        6: 6899:            double duration = 0;
        6: 6900:            m_shouldReportUnexpected = true;
        -: 6901:            try {
        6: 6902:                m_lastAssertionInfo = AssertionInfo( "TEST_CASE", testCaseInfo.lineInfo, "", ResultDisposition::Normal );
        -: 6903:
        6: 6904:                seedRng( *m_config );
        -: 6905:
        6: 6906:                Timer timer;
        6: 6907:                timer.start();
        6: 6908:                if( m_reporter->getPreferences().shouldRedirectStdOut ) {
    #####: 6909:                    StreamRedirect coutRedir( Catch::cout(), redirectedCout );
    #####: 6910:                    StdErrRedirect errRedir( redirectedCerr );
    #####: 6911:                    invokeActiveTestCase();
        -: 6912:                }
        -: 6913:                else {
        6: 6914:                    invokeActiveTestCase();
        -: 6915:                }
        6: 6916:                duration = timer.getElapsedSeconds();
        -: 6917:            }
    =====: 6918:            catch( TestFailureException& ) {
        -: 6919:                // This just means the test was aborted due to failure
        -: 6920:            }
    =====: 6921:            catch(...) {
        -: 6922:                // Under CATCH_CONFIG_FAST_COMPILE, unexpected exceptions under REQUIRE assertions
        -: 6923:                // are reported without translation at the point of origin.
    =====: 6924:                if (m_shouldReportUnexpected) {
    =====: 6925:                    makeUnexpectedResultBuilder().useActiveException();
        -: 6926:                }
        -: 6927:            }
        6: 6928:            m_testCaseTracker->close();
        6: 6929:            handleUnfinishedSections();
        6: 6930:            m_messages.clear();
        -: 6931:
        6: 6932:            Counts assertions = m_totals.assertions - prevAssertions;
        6: 6933:            bool missingAssertions = testForMissingAssertions( assertions );
        -: 6934:
       12: 6935:            SectionStats testCaseSectionStats( testCaseSection, assertions, duration, missingAssertions );
        6: 6936:            m_reporter->sectionEnded( testCaseSectionStats );
        6: 6937:        }
        -: 6938:
        6: 6939:        void invokeActiveTestCase() {
       12: 6940:            FatalConditionHandler fatalConditionHandler; // Handle signals
        6: 6941:            m_activeTestCase->invoke();
        6: 6942:            fatalConditionHandler.reset();
        6: 6943:        }
        -: 6944:
        -: 6945:    private:
        -: 6946:
    #####: 6947:        ResultBuilder makeUnexpectedResultBuilder() const {
    #####: 6948:            return ResultBuilder(   m_lastAssertionInfo.macroName,
    #####: 6949:                                    m_lastAssertionInfo.lineInfo,
    #####: 6950:                                    m_lastAssertionInfo.capturedExpression,
    #####: 6951:                                    m_lastAssertionInfo.resultDisposition );
        -: 6952:        }
        -: 6953:
        6: 6954:        void handleUnfinishedSections() {
        -: 6955:            // If sections ended prematurely due to an exception we stored their
        -: 6956:            // infos here so we can tear them down outside the unwind process.
       6*: 6957:            for( std::vector<SectionEndInfo>::const_reverse_iterator it = m_unfinishedSections.rbegin(),
        6: 6958:                        itEnd = m_unfinishedSections.rend();
        6: 6959:                    it != itEnd;
    #####: 6960:                    ++it )
    #####: 6961:                sectionEnded( *it );
        6: 6962:            m_unfinishedSections.clear();
        6: 6963:        }
        -: 6964:
        -: 6965:        TestRunInfo m_runInfo;
        -: 6966:        IMutableContext& m_context;
        -: 6967:        TestCase const* m_activeTestCase;
        -: 6968:        ITracker* m_testCaseTracker;
        -: 6969:        ITracker* m_currentSectionTracker;
        -: 6970:        AssertionResult m_lastResult;
        -: 6971:
        -: 6972:        Ptr<IConfig const> m_config;
        -: 6973:        Totals m_totals;
        -: 6974:        Ptr<IStreamingReporter> m_reporter;
        -: 6975:        std::vector<MessageInfo> m_messages;
        -: 6976:        AssertionInfo m_lastAssertionInfo;
        -: 6977:        std::vector<SectionEndInfo> m_unfinishedSections;
        -: 6978:        std::vector<ITracker*> m_activeSections;
        -: 6979:        TrackerContext m_trackerContext;
        -: 6980:        size_t m_prevPassed;
        -: 6981:        bool m_shouldReportUnexpected;
        -: 6982:    };
        -: 6983:
       54: 6984:    IResultCapture& getResultCapture() {
       54: 6985:        if( IResultCapture* capture = getCurrentContext().getResultCapture() )
       54: 6986:            return *capture;
        -: 6987:        else
    #####: 6988:            throw std::logic_error( "No result capture instance" );
        -: 6989:    }
        -: 6990:
        -: 6991:} // end namespace Catch
        -: 6992:
        -: 6993:// #included from: internal/catch_version.h
        -: 6994:#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED
        -: 6995:
        -: 6996:namespace Catch {
        -: 6997:
        -: 6998:    // Versioning information
        -: 6999:    struct Version {
        -: 7000:        Version(    unsigned int _majorVersion,
        -: 7001:                    unsigned int _minorVersion,
        -: 7002:                    unsigned int _patchNumber,
        -: 7003:                    char const * const _branchName,
        -: 7004:                    unsigned int _buildNumber );
        -: 7005:
        -: 7006:        unsigned int const majorVersion;
        -: 7007:        unsigned int const minorVersion;
        -: 7008:        unsigned int const patchNumber;
        -: 7009:
        -: 7010:        // buildNumber is only used if branchName is not null
        -: 7011:        char const * const branchName;
        -: 7012:        unsigned int const buildNumber;
        -: 7013:
        -: 7014:        friend std::ostream& operator << ( std::ostream& os, Version const& version );
        -: 7015:
        -: 7016:    private:
        -: 7017:        void operator=( Version const& );
        -: 7018:    };
        -: 7019:
        -: 7020:    inline Version libraryVersion();
        -: 7021:}
        -: 7022:
        -: 7023:#include <fstream>
        -: 7024:#include <stdlib.h>
        -: 7025:#include <limits>
        -: 7026:
        -: 7027:namespace Catch {
        -: 7028:
        1: 7029:    Ptr<IStreamingReporter> createReporter( std::string const& reporterName, Ptr<Config> const& config ) {
        1: 7030:        Ptr<IStreamingReporter> reporter = getRegistryHub().getReporterRegistry().create( reporterName, config.get() );
        1: 7031:        if( !reporter ) {
    #####: 7032:            std::ostringstream oss;
    #####: 7033:            oss << "No reporter registered with name: '" << reporterName << "'";
    #####: 7034:            throw std::domain_error( oss.str() );
        -: 7035:        }
        1: 7036:        return reporter;
        -: 7037:    }
        -: 7038:
        -: 7039:#if !defined(CATCH_CONFIG_DEFAULT_REPORTER)
        -: 7040:#define CATCH_CONFIG_DEFAULT_REPORTER "console"
        -: 7041:#endif
        -: 7042:
        1: 7043:    Ptr<IStreamingReporter> makeReporter( Ptr<Config> const& config ) {
        2: 7044:        std::vector<std::string> reporters = config->getReporterNames();
        1: 7045:        if( reporters.empty() )
        1: 7046:            reporters.push_back( CATCH_CONFIG_DEFAULT_REPORTER );
        -: 7047:
        1: 7048:        Ptr<IStreamingReporter> reporter;
        2: 7049:        for( std::vector<std::string>::const_iterator it = reporters.begin(), itEnd = reporters.end();
        2: 7050:                it != itEnd;
        1: 7051:                ++it )
        1: 7052:            reporter = addReporter( reporter, createReporter( *it, config ) );
        2: 7053:        return reporter;
        -: 7054:    }
        1: 7055:    Ptr<IStreamingReporter> addListeners( Ptr<IConfig const> const& config, Ptr<IStreamingReporter> reporters ) {
        2: 7056:        IReporterRegistry::Listeners listeners = getRegistryHub().getReporterRegistry().getListeners();
       1*: 7057:        for( IReporterRegistry::Listeners::const_iterator it = listeners.begin(), itEnd = listeners.end();
        1: 7058:                it != itEnd;
    #####: 7059:                ++it )
    #####: 7060:            reporters = addReporter(reporters, (*it)->create( ReporterConfig( config ) ) );
        2: 7061:        return reporters;
        -: 7062:    }
        -: 7063:
        1: 7064:    Totals runTests( Ptr<Config> const& config ) {
        -: 7065:
        2: 7066:        Ptr<IConfig const> iconfig = config.get();
        -: 7067:
        2: 7068:        Ptr<IStreamingReporter> reporter = makeReporter( config );
        1: 7069:        reporter = addListeners( iconfig, reporter );
        -: 7070:
        2: 7071:        RunContext context( iconfig, reporter );
        -: 7072:
        1: 7073:        Totals totals;
        -: 7074:
        1: 7075:        context.testGroupStarting( config->name(), 1, 1 );
        -: 7076:
        2: 7077:        TestSpec testSpec = config->testSpec();
        1: 7078:        if( !testSpec.hasFilters() )
        1: 7079:            testSpec = TestSpecParser( ITagAliasRegistry::get() ).parse( "~[.]" ).testSpec(); // All not hidden tests
        -: 7080:
        1: 7081:        std::vector<TestCase> const& allTestCases = getAllTestCasesSorted( *iconfig );
        2: 7082:        for( std::vector<TestCase>::const_iterator it = allTestCases.begin(), itEnd = allTestCases.end();
        2: 7083:                it != itEnd;
        1: 7084:                ++it ) {
       1*: 7085:            if( !context.aborting() && matchTest( *it, testSpec, *iconfig ) )
        1: 7086:                totals += context.runTest( *it );
        -: 7087:            else
    #####: 7088:                reporter->skipTest( *it );
        -: 7089:        }
        -: 7090:
        1: 7091:        context.testGroupEnded( iconfig->name(), totals, 1, 1 );
        2: 7092:        return totals;
        -: 7093:    }
        -: 7094:
    #####: 7095:    void applyFilenamesAsTags( IConfig const& config ) {
    #####: 7096:        std::vector<TestCase> const& tests = getAllTestCasesSorted( config );
    #####: 7097:        for(std::size_t i = 0; i < tests.size(); ++i ) {
    #####: 7098:            TestCase& test = const_cast<TestCase&>( tests[i] );
    #####: 7099:            std::set<std::string> tags = test.tags;
        -: 7100:
    #####: 7101:            std::string filename = test.lineInfo.file;
    #####: 7102:            std::string::size_type lastSlash = filename.find_last_of( "\\/" );
    #####: 7103:            if( lastSlash != std::string::npos )
    #####: 7104:                filename = filename.substr( lastSlash+1 );
        -: 7105:
    #####: 7106:            std::string::size_type lastDot = filename.find_last_of( '.' );
    #####: 7107:            if( lastDot != std::string::npos )
    #####: 7108:                filename = filename.substr( 0, lastDot );
        -: 7109:
    #####: 7110:            tags.insert( '#' + filename );
    #####: 7111:            setTags( test, tags );
        -: 7112:        }
    #####: 7113:    }
        -: 7114:
        -: 7115:    class Session : NonCopyable {
        -: 7116:        static bool alreadyInstantiated;
        -: 7117:
        -: 7118:    public:
        -: 7119:
        -: 7120:        struct OnUnusedOptions { enum DoWhat { Ignore, Fail }; };
        -: 7121:
        1: 7122:        Session()
        1: 7123:        : m_cli( makeCommandLineParser() ) {
        1: 7124:            if( alreadyInstantiated ) {
    #####: 7125:                std::string msg = "Only one instance of Catch::Session can ever be used";
    #####: 7126:                Catch::cerr() << msg << std::endl;
    #####: 7127:                throw std::logic_error( msg );
        -: 7128:            }
        1: 7129:            alreadyInstantiated = true;
        1: 7130:        }
       1*: 7131:        ~Session() {
        1: 7132:            Catch::cleanUp();
       1*: 7133:        }
------------------
_ZN5Catch7SessionD0Ev:
    #####: 7131:        ~Session() {
        -: 7132:            Catch::cleanUp();
    #####: 7133:        }
------------------
_ZN5Catch7SessionD2Ev:
        1: 7131:        ~Session() {
        1: 7132:            Catch::cleanUp();
        1: 7133:        }
------------------
        -: 7134:
    #####: 7135:        void showHelp( std::string const& processName ) {
    #####: 7136:            Catch::cout() << "\nCatch v" << libraryVersion() << "\n";
        -: 7137:
    #####: 7138:            m_cli.usage( Catch::cout(), processName );
    #####: 7139:            Catch::cout() << "For more detail usage please see the project docs\n" << std::endl;
    #####: 7140:        }
    #####: 7141:        void libIdentify() {
    #####: 7142:            Catch::cout()
    #####: 7143:                    << std::left << std::setw(16) << "description: " << "A Catch test executable\n"
    #####: 7144:                    << std::left << std::setw(16) << "category: " << "testframework\n"
    #####: 7145:                    << std::left << std::setw(16) << "framework: " << "Catch Test\n"
    #####: 7146:                    << std::left << std::setw(16) << "version: " << libraryVersion() << std::endl;
    #####: 7147:        }
        -: 7148:
        1: 7149:        int applyCommandLine( int argc, char const* const* const argv, OnUnusedOptions::DoWhat unusedOptionBehaviour = OnUnusedOptions::Fail ) {
        -: 7150:            try {
        1: 7151:                m_cli.setThrowOnUnrecognisedTokens( unusedOptionBehaviour == OnUnusedOptions::Fail );
        1: 7152:                m_unusedTokens = m_cli.parseInto( Clara::argsToVector( argc, argv ), m_configData );
        1: 7153:                if( m_configData.showHelp )
    #####: 7154:                    showHelp( m_configData.processName );
        1: 7155:                if( m_configData.libIdentify )
    #####: 7156:                    libIdentify();
        1: 7157:                m_config.reset();
        -: 7158:            }
    =====: 7159:            catch( std::exception& ex ) {
        -: 7160:                {
    =====: 7161:                    Colour colourGuard( Colour::Red );
    =====: 7162:                    Catch::cerr()
    =====: 7163:                        << "\nError(s) in input:\n"
    =====: 7164:                        << Text( ex.what(), TextAttributes().setIndent(2) )
    =====: 7165:                        << "\n\n";
        -: 7166:                }
    =====: 7167:                m_cli.usage( Catch::cout(), m_configData.processName );
    =====: 7168:                return (std::numeric_limits<int>::max)();
        -: 7169:            }
        1: 7170:            return 0;
        -: 7171:        }
        -: 7172:
        -: 7173:        void useConfigData( ConfigData const& _configData ) {
        -: 7174:            m_configData = _configData;
        -: 7175:            m_config.reset();
        -: 7176:        }
        -: 7177:
        1: 7178:        int run( int argc, char const* const* const argv ) {
        -: 7179:
        1: 7180:            int returnCode = applyCommandLine( argc, argv );
        1: 7181:            if( returnCode == 0 )
        1: 7182:                returnCode = run();
        1: 7183:            return returnCode;
        -: 7184:        }
        -: 7185:
        -: 7186:    #if defined(WIN32) && defined(UNICODE)
        -: 7187:        int run( int argc, wchar_t const* const* const argv ) {
        -: 7188:
        -: 7189:            char **utf8Argv = new char *[ argc ];
        -: 7190:
        -: 7191:            for ( int i = 0; i < argc; ++i ) {
        -: 7192:                int bufSize = WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, NULL, 0, NULL, NULL );
        -: 7193:
        -: 7194:                utf8Argv[ i ] = new char[ bufSize ];
        -: 7195:
        -: 7196:                WideCharToMultiByte( CP_UTF8, 0, argv[i], -1, utf8Argv[i], bufSize, NULL, NULL );
        -: 7197:            }
        -: 7198:
        -: 7199:            int returnCode = applyCommandLine( argc, utf8Argv );
        -: 7200:            if( returnCode == 0 )
        -: 7201:                returnCode = run();
        -: 7202:
        -: 7203:            for ( int i = 0; i < argc; ++i )
        -: 7204:                delete [] utf8Argv[ i ];
        -: 7205:
        -: 7206:            delete [] utf8Argv;
        -: 7207:
        -: 7208:            return returnCode;
        -: 7209:        }
        -: 7210:    #endif
        -: 7211:
        1: 7212:        int run() {
        1: 7213:            if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeStart ) != 0 ) {
    #####: 7214:                Catch::cout() << "...waiting for enter/ return before starting" << std::endl;
    #####: 7215:                static_cast<void>(std::getchar());
        -: 7216:            }
        1: 7217:            int exitCode = runInternal();
        1: 7218:            if( ( m_configData.waitForKeypress & WaitForKeypress::BeforeExit ) != 0 ) {
    #####: 7219:                Catch::cout() << "...waiting for enter/ return before exiting, with code: " << exitCode << std::endl;
    #####: 7220:                static_cast<void>(std::getchar());
        -: 7221:            }
        1: 7222:            return exitCode;
        -: 7223:        }
        -: 7224:
        -: 7225:        Clara::CommandLine<ConfigData> const& cli() const {
        -: 7226:            return m_cli;
        -: 7227:        }
        -: 7228:        std::vector<Clara::Parser::Token> const& unusedTokens() const {
        -: 7229:            return m_unusedTokens;
        -: 7230:        }
        -: 7231:        ConfigData& configData() {
        -: 7232:            return m_configData;
        -: 7233:        }
        2: 7234:        Config& config() {
        2: 7235:            if( !m_config )
        1: 7236:                m_config = new Config( m_configData );
        2: 7237:            return *m_config;
        -: 7238:        }
        -: 7239:    private:
        -: 7240:
        1: 7241:        int runInternal() {
        1: 7242:            if( m_configData.showHelp || m_configData.libIdentify )
    #####: 7243:                return 0;
        -: 7244:
        -: 7245:            try
        -: 7246:            {
        1: 7247:                config(); // Force config to be constructed
        -: 7248:
        1: 7249:                seedRng( *m_config );
        -: 7250:
        1: 7251:                if( m_configData.filenamesAsTags )
    #####: 7252:                    applyFilenamesAsTags( *m_config );
        -: 7253:
        -: 7254:                // Handle list request
        1: 7255:                if( Option<std::size_t> listed = list( config() ) )
    #####: 7256:                    return static_cast<int>( *listed );
        -: 7257:
        1: 7258:                return static_cast<int>( runTests( m_config ).assertions.failed );
        -: 7259:            }
    =====: 7260:            catch( std::exception& ex ) {
    =====: 7261:                Catch::cerr() << ex.what() << std::endl;
    =====: 7262:                return (std::numeric_limits<int>::max)();
        -: 7263:            }
        -: 7264:        }
        -: 7265:
        -: 7266:        Clara::CommandLine<ConfigData> m_cli;
        -: 7267:        std::vector<Clara::Parser::Token> m_unusedTokens;
        -: 7268:        ConfigData m_configData;
        -: 7269:        Ptr<Config> m_config;
        -: 7270:    };
        -: 7271:
        -: 7272:    bool Session::alreadyInstantiated = false;
        -: 7273:
        -: 7274:} // end namespace Catch
        -: 7275:
        -: 7276:// #included from: catch_registry_hub.hpp
        -: 7277:#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED
        -: 7278:
        -: 7279:// #included from: catch_test_case_registry_impl.hpp
        -: 7280:#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED
        -: 7281:
        -: 7282:#include <vector>
        -: 7283:#include <set>
        -: 7284:#include <sstream>
        -: 7285:#include <algorithm>
        -: 7286:
        -: 7287:namespace Catch {
        -: 7288:
        -: 7289:    struct RandomNumberGenerator {
        -: 7290:        typedef unsigned int result_type;
        -: 7291:
        -: 7292:        result_type operator()( result_type n ) const { return std::rand() % n; }
        -: 7293:
        -: 7294:#ifdef CATCH_CONFIG_CPP11_SHUFFLE
        -: 7295:        static constexpr result_type (min)() { return 0; }
    #####: 7296:        static constexpr result_type (max)() { return 1000000; }
    #####: 7297:        result_type operator()() const { return std::rand() % (max)(); }
        -: 7298:#endif
        -: 7299:        template<typename V>
    #####: 7300:        static void shuffle( V& vector ) {
        -: 7301:            RandomNumberGenerator rng;
        -: 7302:#ifdef CATCH_CONFIG_CPP11_SHUFFLE
    #####: 7303:            std::shuffle( vector.begin(), vector.end(), rng );
        -: 7304:#else
        -: 7305:            std::random_shuffle( vector.begin(), vector.end(), rng );
        -: 7306:#endif
    #####: 7307:        }
        -: 7308:    };
        -: 7309:
        1: 7310:    inline std::vector<TestCase> sortTests( IConfig const& config, std::vector<TestCase> const& unsortedTestCases ) {
        -: 7311:
        1: 7312:        std::vector<TestCase> sorted = unsortedTestCases;
        -: 7313:
        1: 7314:        switch( config.runOrder() ) {
    #####: 7315:            case RunTests::InLexicographicalOrder:
    #####: 7316:                std::sort( sorted.begin(), sorted.end() );
    #####: 7317:                break;
    #####: 7318:            case RunTests::InRandomOrder:
        -: 7319:                {
    #####: 7320:                    seedRng( config );
    #####: 7321:                    RandomNumberGenerator::shuffle( sorted );
        -: 7322:                }
    #####: 7323:                break;
        1: 7324:            case RunTests::InDeclarationOrder:
        -: 7325:                // already in declaration order
        1: 7326:                break;
        -: 7327:        }
        1: 7328:        return sorted;
        -: 7329:    }
        1: 7330:    bool matchTest( TestCase const& testCase, TestSpec const& testSpec, IConfig const& config ) {
       1*: 7331:        return testSpec.matches( testCase ) && ( config.allowThrows() || !testCase.throws() );
        -: 7332:    }
        -: 7333:
        1: 7334:    void enforceNoDuplicateTestCases( std::vector<TestCase> const& functions ) {
        2: 7335:        std::set<TestCase> seenFunctions;
        2: 7336:        for( std::vector<TestCase>::const_iterator it = functions.begin(), itEnd = functions.end();
        2: 7337:            it != itEnd;
        1: 7338:            ++it ) {
        1: 7339:            std::pair<std::set<TestCase>::const_iterator, bool> prev = seenFunctions.insert( *it );
        1: 7340:            if( !prev.second ) {
    #####: 7341:                std::ostringstream ss;
        -: 7342:
    #####: 7343:                ss  << Colour( Colour::Red )
    #####: 7344:                    << "error: TEST_CASE( \"" << it->name << "\" ) already defined.\n"
    #####: 7345:                    << "\tFirst seen at " << prev.first->getTestCaseInfo().lineInfo << '\n'
    #####: 7346:                    << "\tRedefined at " << it->getTestCaseInfo().lineInfo << std::endl;
        -: 7347:
    #####: 7348:                throw std::runtime_error(ss.str());
        -: 7349:            }
        -: 7350:        }
        1: 7351:    }
        -: 7352:
    #####: 7353:    std::vector<TestCase> filterTests( std::vector<TestCase> const& testCases, TestSpec const& testSpec, IConfig const& config ) {
    #####: 7354:        std::vector<TestCase> filtered;
    #####: 7355:        filtered.reserve( testCases.size() );
    #####: 7356:        for( std::vector<TestCase>::const_iterator it = testCases.begin(), itEnd = testCases.end();
    #####: 7357:                it != itEnd;
    #####: 7358:                ++it )
    #####: 7359:            if( matchTest( *it, testSpec, config ) )
    #####: 7360:                filtered.push_back( *it );
    #####: 7361:        return filtered;
        -: 7362:    }
        1: 7363:    std::vector<TestCase> const& getAllTestCasesSorted( IConfig const& config ) {
        1: 7364:        return getRegistryHub().getTestCaseRegistry().getAllTestsSorted( config );
        -: 7365:    }
        -: 7366:
        -: 7367:    class TestRegistry : public ITestCaseRegistry {
        -: 7368:    public:
        1: 7369:        TestRegistry()
        1: 7370:        :   m_currentSortOrder( RunTests::InDeclarationOrder ),
        1: 7371:            m_unnamedCount( 0 )
        1: 7372:        {}
        -: 7373:        virtual ~TestRegistry();
        -: 7374:
        1: 7375:        virtual void registerTest( TestCase const& testCase ) {
        1: 7376:            std::string name = testCase.getTestCaseInfo().name;
        1: 7377:            if( name.empty() ) {
    #####: 7378:                std::ostringstream oss;
    #####: 7379:                oss << "Anonymous test case " << ++m_unnamedCount;
    #####: 7380:                return registerTest( testCase.withName( oss.str() ) );
        -: 7381:            }
        1: 7382:            m_functions.push_back( testCase );
        -: 7383:        }
        -: 7384:
    #####: 7385:        virtual std::vector<TestCase> const& getAllTests() const {
    #####: 7386:            return m_functions;
        -: 7387:        }
        1: 7388:        virtual std::vector<TestCase> const& getAllTestsSorted( IConfig const& config ) const {
        1: 7389:            if( m_sortedFunctions.empty() )
        1: 7390:                enforceNoDuplicateTestCases( m_functions );
        -: 7391:
       1*: 7392:            if(  m_currentSortOrder != config.runOrder() || m_sortedFunctions.empty() ) {
        1: 7393:                m_sortedFunctions = sortTests( config, m_functions );
        1: 7394:                m_currentSortOrder = config.runOrder();
        -: 7395:            }
        1: 7396:            return m_sortedFunctions;
        -: 7397:        }
        -: 7398:
        -: 7399:    private:
        -: 7400:        std::vector<TestCase> m_functions;
        -: 7401:        mutable RunTests::InWhatOrder m_currentSortOrder;
        -: 7402:        mutable std::vector<TestCase> m_sortedFunctions;
        -: 7403:        size_t m_unnamedCount;
        -: 7404:        std::ios_base::Init m_ostreamInit; // Forces cout/ cerr to be initialised
        -: 7405:    };
        -: 7406:
        -: 7407:    ///////////////////////////////////////////////////////////////////////////
        -: 7408:
        -: 7409:    class FreeFunctionTestCase : public SharedImpl<ITestCase> {
        -: 7410:    public:
        -: 7411:
        1: 7412:        FreeFunctionTestCase( TestFunction fun ) : m_fun( fun ) {}
        -: 7413:
        6: 7414:        virtual void invoke() const {
        6: 7415:            m_fun();
        6: 7416:        }
        -: 7417:
        -: 7418:    private:
        -: 7419:        virtual ~FreeFunctionTestCase();
        -: 7420:
        -: 7421:        TestFunction m_fun;
        -: 7422:    };
        -: 7423:
        1: 7424:    inline std::string extractClassName( std::string const& classOrQualifiedMethodName ) {
        1: 7425:        std::string className = classOrQualifiedMethodName;
        1: 7426:        if( startsWith( className, '&' ) )
        -: 7427:        {
    #####: 7428:            std::size_t lastColons = className.rfind( "::" );
    #####: 7429:            std::size_t penultimateColons = className.rfind( "::", lastColons-1 );
    #####: 7430:            if( penultimateColons == std::string::npos )
    #####: 7431:                penultimateColons = 1;
    #####: 7432:            className = className.substr( penultimateColons, lastColons-penultimateColons );
        -: 7433:        }
        1: 7434:        return className;
        -: 7435:    }
        -: 7436:
        1: 7437:    void registerTestCase
        -: 7438:        (   ITestCase* testCase,
        -: 7439:            char const* classOrQualifiedMethodName,
        -: 7440:            NameAndDesc const& nameAndDesc,
        -: 7441:            SourceLineInfo const& lineInfo ) {
        -: 7442:
        1: 7443:        getMutableRegistryHub().registerTest
        1: 7444:            ( makeTestCase
        4: 7445:                (   testCase,
        2: 7446:                    extractClassName( classOrQualifiedMethodName ),
        1: 7447:                    nameAndDesc.name,
        1: 7448:                    nameAndDesc.description,
        1: 7449:                    lineInfo ) );
        1: 7450:    }
        1: 7451:    void registerTestCaseFunction
        -: 7452:        (   TestFunction function,
        -: 7453:            SourceLineInfo const& lineInfo,
        -: 7454:            NameAndDesc const& nameAndDesc ) {
        1: 7455:        registerTestCase( new FreeFunctionTestCase( function ), "", nameAndDesc, lineInfo );
        1: 7456:    }
        -: 7457:
        -: 7458:    ///////////////////////////////////////////////////////////////////////////
        -: 7459:
        1: 7460:    AutoReg::AutoReg
        -: 7461:        (   TestFunction function,
        -: 7462:            SourceLineInfo const& lineInfo,
        -: 7463:            NameAndDesc const& nameAndDesc ) {
        1: 7464:        registerTestCaseFunction( function, lineInfo, nameAndDesc );
        1: 7465:    }
        -: 7466:
        1: 7467:    AutoReg::~AutoReg() {}
        -: 7468:
        -: 7469:} // end namespace Catch
        -: 7470:
        -: 7471:// #included from: catch_reporter_registry.hpp
        -: 7472:#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED
        -: 7473:
        -: 7474:#include <map>
        -: 7475:
        -: 7476:namespace Catch {
        -: 7477:
        -: 7478:    class ReporterRegistry : public IReporterRegistry {
        -: 7479:
        -: 7480:    public:
        -: 7481:
       1*: 7482:        virtual ~ReporterRegistry() CATCH_OVERRIDE {}
------------------
_ZN5Catch16ReporterRegistryD0Ev:
    #####: 7482:        virtual ~ReporterRegistry() CATCH_OVERRIDE {}
------------------
_ZN5Catch16ReporterRegistryD2Ev:
        1: 7482:        virtual ~ReporterRegistry() CATCH_OVERRIDE {}
------------------
        -: 7483:
        1: 7484:        virtual IStreamingReporter* create( std::string const& name, Ptr<IConfig const> const& config ) const CATCH_OVERRIDE {
        1: 7485:            FactoryMap::const_iterator it =  m_factories.find( name );
        1: 7486:            if( it == m_factories.end() )
    #####: 7487:                return CATCH_NULL;
        1: 7488:            return it->second->create( ReporterConfig( config ) );
        -: 7489:        }
        -: 7490:
        4: 7491:        void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) {
        4: 7492:            m_factories.insert( std::make_pair( name, factory ) );
        4: 7493:        }
    #####: 7494:        void registerListener( Ptr<IReporterFactory> const& factory ) {
    #####: 7495:            m_listeners.push_back( factory );
    #####: 7496:        }
        -: 7497:
    #####: 7498:        virtual FactoryMap const& getFactories() const CATCH_OVERRIDE {
    #####: 7499:            return m_factories;
        -: 7500:        }
        1: 7501:        virtual Listeners const& getListeners() const CATCH_OVERRIDE {
        1: 7502:            return m_listeners;
        -: 7503:        }
        -: 7504:
        -: 7505:    private:
        -: 7506:        FactoryMap m_factories;
        -: 7507:        Listeners m_listeners;
        -: 7508:    };
        -: 7509:}
        -: 7510:
        -: 7511:// #included from: catch_exception_translator_registry.hpp
        -: 7512:#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED
        -: 7513:
        -: 7514:#ifdef __OBJC__
        -: 7515:#import "Foundation/Foundation.h"
        -: 7516:#endif
        -: 7517:
        -: 7518:namespace Catch {
        -: 7519:
        -: 7520:    class ExceptionTranslatorRegistry : public IExceptionTranslatorRegistry {
        -: 7521:    public:
       1*: 7522:        ~ExceptionTranslatorRegistry() {
        1: 7523:            deleteAll( m_translators );
       1*: 7524:        }
------------------
_ZN5Catch27ExceptionTranslatorRegistryD0Ev:
    #####: 7522:        ~ExceptionTranslatorRegistry() {
        -: 7523:            deleteAll( m_translators );
    #####: 7524:        }
------------------
_ZN5Catch27ExceptionTranslatorRegistryD2Ev:
        1: 7522:        ~ExceptionTranslatorRegistry() {
        1: 7523:            deleteAll( m_translators );
        1: 7524:        }
------------------
        -: 7525:
    #####: 7526:        virtual void registerTranslator( const IExceptionTranslator* translator ) {
    #####: 7527:            m_translators.push_back( translator );
    #####: 7528:        }
        -: 7529:
    #####: 7530:        virtual std::string translateActiveException() const {
        -: 7531:            try {
        -: 7532:#ifdef __OBJC__
        -: 7533:                // In Objective-C try objective-c exceptions first
        -: 7534:                @try {
        -: 7535:                    return tryTranslators();
        -: 7536:                }
        -: 7537:                @catch (NSException *exception) {
        -: 7538:                    return Catch::toString( [exception description] );
        -: 7539:                }
        -: 7540:#else
    #####: 7541:                return tryTranslators();
        -: 7542:#endif
        -: 7543:            }
    =====: 7544:            catch( TestFailureException& ) {
    =====: 7545:                throw;
        -: 7546:            }
    =====: 7547:            catch( std::exception& ex ) {
    =====: 7548:                return ex.what();
        -: 7549:            }
    =====: 7550:            catch( std::string& msg ) {
    =====: 7551:                return msg;
        -: 7552:            }
    =====: 7553:            catch( const char* msg ) {
    =====: 7554:                return msg;
        -: 7555:            }
    =====: 7556:            catch(...) {
    =====: 7557:                return "Unknown exception";
        -: 7558:            }
        -: 7559:        }
        -: 7560:
    #####: 7561:        std::string tryTranslators() const {
    #####: 7562:            if( m_translators.empty() )
    #####: 7563:                throw;
        -: 7564:            else
    #####: 7565:                return m_translators[0]->translate( m_translators.begin()+1, m_translators.end() );
        -: 7566:        }
        -: 7567:
        -: 7568:    private:
        -: 7569:        std::vector<const IExceptionTranslator*> m_translators;
        -: 7570:    };
        -: 7571:}
        -: 7572:
        -: 7573:// #included from: catch_tag_alias_registry.h
        -: 7574:#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED
        -: 7575:
        -: 7576:#include <map>
        -: 7577:
        -: 7578:namespace Catch {
        -: 7579:
        -: 7580:    class TagAliasRegistry : public ITagAliasRegistry {
        -: 7581:    public:
        -: 7582:        virtual ~TagAliasRegistry();
        -: 7583:        virtual Option<TagAlias> find( std::string const& alias ) const;
        -: 7584:        virtual std::string expandAliases( std::string const& unexpandedTestSpec ) const;
        -: 7585:        void add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo );
        -: 7586:
        -: 7587:    private:
        -: 7588:        std::map<std::string, TagAlias> m_registry;
        -: 7589:    };
        -: 7590:
        -: 7591:} // end namespace Catch
        -: 7592:
        -: 7593:namespace Catch {
        -: 7594:
        -: 7595:    namespace {
        -: 7596:
        -: 7597:        class RegistryHub : public IRegistryHub, public IMutableRegistryHub {
        -: 7598:
        -: 7599:            RegistryHub( RegistryHub const& );
        -: 7600:            void operator=( RegistryHub const& );
        -: 7601:
        -: 7602:        public: // IRegistryHub
        1: 7603:            RegistryHub() {
        1: 7604:            }
        2: 7605:            virtual IReporterRegistry const& getReporterRegistry() const CATCH_OVERRIDE {
        2: 7606:                return m_reporterRegistry;
        -: 7607:            }
        1: 7608:            virtual ITestCaseRegistry const& getTestCaseRegistry() const CATCH_OVERRIDE {
        1: 7609:                return m_testCaseRegistry;
        -: 7610:            }
    #####: 7611:            virtual IExceptionTranslatorRegistry& getExceptionTranslatorRegistry() CATCH_OVERRIDE {
    #####: 7612:                return m_exceptionTranslatorRegistry;
        -: 7613:            }
        1: 7614:            virtual ITagAliasRegistry const& getTagAliasRegistry() const CATCH_OVERRIDE {
        1: 7615:                return m_tagAliasRegistry;
        -: 7616:            }
        -: 7617:
        -: 7618:        public: // IMutableRegistryHub
        4: 7619:            virtual void registerReporter( std::string const& name, Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE {
        4: 7620:                m_reporterRegistry.registerReporter( name, factory );
        4: 7621:            }
    #####: 7622:            virtual void registerListener( Ptr<IReporterFactory> const& factory ) CATCH_OVERRIDE {
    #####: 7623:                m_reporterRegistry.registerListener( factory );
    #####: 7624:            }
        1: 7625:            virtual void registerTest( TestCase const& testInfo ) CATCH_OVERRIDE {
        1: 7626:                m_testCaseRegistry.registerTest( testInfo );
        1: 7627:            }
    #####: 7628:            virtual void registerTranslator( const IExceptionTranslator* translator ) CATCH_OVERRIDE {
    #####: 7629:                m_exceptionTranslatorRegistry.registerTranslator( translator );
    #####: 7630:            }
    #####: 7631:            virtual void registerTagAlias( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) CATCH_OVERRIDE {
    #####: 7632:                m_tagAliasRegistry.add( alias, tag, lineInfo );
    #####: 7633:            }
        -: 7634:
        -: 7635:        private:
        -: 7636:            TestRegistry m_testCaseRegistry;
        -: 7637:            ReporterRegistry m_reporterRegistry;
        -: 7638:            ExceptionTranslatorRegistry m_exceptionTranslatorRegistry;
        -: 7639:            TagAliasRegistry m_tagAliasRegistry;
        -: 7640:        };
        -: 7641:
        -: 7642:        // Single, global, instance
       11: 7643:        inline RegistryHub*& getTheRegistryHub() {
        -: 7644:            static RegistryHub* theRegistryHub = CATCH_NULL;
       11: 7645:            if( !theRegistryHub )
        1: 7646:                theRegistryHub = new RegistryHub();
       11: 7647:            return theRegistryHub;
        -: 7648:        }
        -: 7649:    }
        -: 7650:
        4: 7651:    IRegistryHub& getRegistryHub() {
        4: 7652:        return *getTheRegistryHub();
        -: 7653:    }
        5: 7654:    IMutableRegistryHub& getMutableRegistryHub() {
        5: 7655:        return *getTheRegistryHub();
        -: 7656:    }
        1: 7657:    void cleanUp() {
        1: 7658:        delete getTheRegistryHub();
        1: 7659:        getTheRegistryHub() = CATCH_NULL;
        1: 7660:        cleanUpContext();
        1: 7661:    }
    #####: 7662:    std::string translateActiveException() {
    #####: 7663:        return getRegistryHub().getExceptionTranslatorRegistry().translateActiveException();
        -: 7664:    }
        -: 7665:
        -: 7666:} // end namespace Catch
        -: 7667:
        -: 7668:// #included from: catch_notimplemented_exception.hpp
        -: 7669:#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED
        -: 7670:
        -: 7671:#include <sstream>
        -: 7672:
        -: 7673:namespace Catch {
        -: 7674:
    #####: 7675:    NotImplementedException::NotImplementedException( SourceLineInfo const& lineInfo )
    #####: 7676:    :   m_lineInfo( lineInfo ) {
    #####: 7677:        std::ostringstream oss;
    #####: 7678:        oss << lineInfo << ": function ";
    #####: 7679:        oss << "not implemented";
    #####: 7680:        m_what = oss.str();
    #####: 7681:    }
        -: 7682:
    #####: 7683:    const char* NotImplementedException::what() const CATCH_NOEXCEPT {
    #####: 7684:        return m_what.c_str();
        -: 7685:    }
        -: 7686:
        -: 7687:} // end namespace Catch
        -: 7688:
        -: 7689:// #included from: catch_context_impl.hpp
        -: 7690:#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED
        -: 7691:
        -: 7692:// #included from: catch_stream.hpp
        -: 7693:#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED
        -: 7694:
        -: 7695:#include <stdexcept>
        -: 7696:#include <cstdio>
        -: 7697:#include <iostream>
        -: 7698:
        -: 7699:namespace Catch {
        -: 7700:
        -: 7701:    template<typename WriterF, size_t bufferSize=256>
        -: 7702:    class StreamBufImpl : public StreamBufBase {
        -: 7703:        char data[bufferSize];
        -: 7704:        WriterF m_writer;
        -: 7705:
        -: 7706:    public:
    #####: 7707:        StreamBufImpl() {
    #####: 7708:            setp( data, data + sizeof(data) );
    #####: 7709:        }
        -: 7710:
    #####: 7711:        ~StreamBufImpl() CATCH_NOEXCEPT {
    #####: 7712:            sync();
    #####: 7713:        }
------------------
_ZN5Catch13StreamBufImplINS_17OutputDebugWriterELm256EED0Ev:
    #####: 7711:        ~StreamBufImpl() CATCH_NOEXCEPT {
        -: 7712:            sync();
    #####: 7713:        }
------------------
_ZN5Catch13StreamBufImplINS_17OutputDebugWriterELm256EED2Ev:
    #####: 7711:        ~StreamBufImpl() CATCH_NOEXCEPT {
    #####: 7712:            sync();
    #####: 7713:        }
------------------
        -: 7714:
        -: 7715:    private:
    #####: 7716:        int overflow( int c ) {
    #####: 7717:            sync();
        -: 7718:
    #####: 7719:            if( c != EOF ) {
    #####: 7720:                if( pbase() == epptr() )
    #####: 7721:                    m_writer( std::string( 1, static_cast<char>( c ) ) );
        -: 7722:                else
    #####: 7723:                    sputc( static_cast<char>( c ) );
        -: 7724:            }
    #####: 7725:            return 0;
        -: 7726:        }
        -: 7727:
    #####: 7728:        int sync() {
    #####: 7729:            if( pbase() != pptr() ) {
    #####: 7730:                m_writer( std::string( pbase(), static_cast<std::string::size_type>( pptr() - pbase() ) ) );
    #####: 7731:                setp( pbase(), epptr() );
        -: 7732:            }
    #####: 7733:            return 0;
        -: 7734:        }
        -: 7735:    };
        -: 7736:
        -: 7737:    ///////////////////////////////////////////////////////////////////////////
        -: 7738:
    #####: 7739:    FileStream::FileStream( std::string const& filename ) {
    #####: 7740:        m_ofs.open( filename.c_str() );
    #####: 7741:        if( m_ofs.fail() ) {
    #####: 7742:            std::ostringstream oss;
    #####: 7743:            oss << "Unable to open file: '" << filename << '\'';
    #####: 7744:            throw std::domain_error( oss.str() );
        -: 7745:        }
    #####: 7746:    }
        -: 7747:
    #####: 7748:    std::ostream& FileStream::stream() const {
    #####: 7749:        return m_ofs;
        -: 7750:    }
        -: 7751:
        -: 7752:    struct OutputDebugWriter {
        -: 7753:
    #####: 7754:        void operator()( std::string const&str ) {
    #####: 7755:            writeToDebugConsole( str );
    #####: 7756:        }
        -: 7757:    };
        -: 7758:
    #####: 7759:    DebugOutStream::DebugOutStream()
    #####: 7760:    :   m_streamBuf( new StreamBufImpl<OutputDebugWriter>() ),
    #####: 7761:        m_os( m_streamBuf.get() )
    #####: 7762:    {}
        -: 7763:
    #####: 7764:    std::ostream& DebugOutStream::stream() const {
    #####: 7765:        return m_os;
        -: 7766:    }
        -: 7767:
        -: 7768:    // Store the streambuf from cout up-front because
        -: 7769:    // cout may get redirected when running tests
        1: 7770:    CoutStream::CoutStream()
        1: 7771:    :   m_os( Catch::cout().rdbuf() )
        1: 7772:    {}
        -: 7773:
        1: 7774:    std::ostream& CoutStream::stream() const {
        1: 7775:        return m_os;
        -: 7776:    }
        -: 7777:
        -: 7778:#ifndef CATCH_CONFIG_NOSTDOUT // If you #define this you must implement these functions
        9: 7779:    std::ostream& cout() {
        9: 7780:        return std::cout;
        -: 7781:    }
    #####: 7782:    std::ostream& cerr() {
    #####: 7783:        return std::cerr;
        -: 7784:    }
    #####: 7785:    std::ostream& clog() {
    #####: 7786:        return std::clog;
        -: 7787:    }
        -: 7788:#endif
        -: 7789:}
        -: 7790:
        -: 7791:namespace Catch {
        -: 7792:
        -: 7793:    class Context : public IMutableContext {
        -: 7794:
        1: 7795:        Context() : m_config( CATCH_NULL ), m_runner( CATCH_NULL ), m_resultCapture( CATCH_NULL ) {}
        -: 7796:        Context( Context const& );
        -: 7797:        void operator=( Context const& );
        -: 7798:
        -: 7799:    public:
        2: 7800:        virtual ~Context() {
        1: 7801:            deleteAllValues( m_generatorsByTestName );
        2: 7802:        }
------------------
_ZN5Catch7ContextD0Ev:
        1: 7800:        virtual ~Context() {
        -: 7801:            deleteAllValues( m_generatorsByTestName );
        1: 7802:        }
------------------
_ZN5Catch7ContextD2Ev:
        1: 7800:        virtual ~Context() {
        1: 7801:            deleteAllValues( m_generatorsByTestName );
        1: 7802:        }
------------------
        -: 7803:
        -: 7804:    public: // IContext
       55: 7805:        virtual IResultCapture* getResultCapture() {
       55: 7806:            return m_resultCapture;
        -: 7807:        }
    #####: 7808:        virtual IRunner* getRunner() {
    #####: 7809:            return m_runner;
        -: 7810:        }
    #####: 7811:        virtual size_t getGeneratorIndex( std::string const& fileInfo, size_t totalSize ) {
    #####: 7812:            return getGeneratorsForCurrentTest()
    #####: 7813:            .getGeneratorInfo( fileInfo, totalSize )
    #####: 7814:            .getCurrentIndex();
        -: 7815:        }
        1: 7816:        virtual bool advanceGeneratorsForCurrentTest() {
        1: 7817:            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
       1*: 7818:            return generators && generators->moveNext();
        -: 7819:        }
        -: 7820:
        7: 7821:        virtual Ptr<IConfig const> getConfig() const {
        7: 7822:            return m_config;
        -: 7823:        }
        -: 7824:
        -: 7825:    public: // IMutableContext
        1: 7826:        virtual void setResultCapture( IResultCapture* resultCapture ) {
        1: 7827:            m_resultCapture = resultCapture;
        1: 7828:        }
        1: 7829:        virtual void setRunner( IRunner* runner ) {
        1: 7830:            m_runner = runner;
        1: 7831:        }
        1: 7832:        virtual void setConfig( Ptr<IConfig const> const& config ) {
        1: 7833:            m_config = config;
        1: 7834:        }
        -: 7835:
        -: 7836:        friend IMutableContext& getCurrentMutableContext();
        -: 7837:
        -: 7838:    private:
        1: 7839:        IGeneratorsForTest* findGeneratorsForCurrentTest() {
        1: 7840:            std::string testName = getResultCapture()->getCurrentTestName();
        -: 7841:
        -: 7842:            std::map<std::string, IGeneratorsForTest*>::const_iterator it =
        1: 7843:                m_generatorsByTestName.find( testName );
        1: 7844:            return it != m_generatorsByTestName.end()
       1*: 7845:                ? it->second
        2: 7846:                : CATCH_NULL;
        -: 7847:        }
        -: 7848:
    #####: 7849:        IGeneratorsForTest& getGeneratorsForCurrentTest() {
    #####: 7850:            IGeneratorsForTest* generators = findGeneratorsForCurrentTest();
    #####: 7851:            if( !generators ) {
    #####: 7852:                std::string testName = getResultCapture()->getCurrentTestName();
    #####: 7853:                generators = createGeneratorsForTest();
    #####: 7854:                m_generatorsByTestName.insert( std::make_pair( testName, generators ) );
        -: 7855:            }
    #####: 7856:            return *generators;
        -: 7857:        }
        -: 7858:
        -: 7859:    private:
        -: 7860:        Ptr<IConfig const> m_config;
        -: 7861:        IRunner* m_runner;
        -: 7862:        IResultCapture* m_resultCapture;
        -: 7863:        std::map<std::string, IGeneratorsForTest*> m_generatorsByTestName;
        -: 7864:    };
        -: 7865:
        -: 7866:    namespace {
        -: 7867:        Context* currentContext = CATCH_NULL;
        -: 7868:    }
       63: 7869:    IMutableContext& getCurrentMutableContext() {
       63: 7870:        if( !currentContext )
        1: 7871:            currentContext = new Context();
       63: 7872:        return *currentContext;
        -: 7873:    }
       62: 7874:    IContext& getCurrentContext() {
       62: 7875:        return getCurrentMutableContext();
        -: 7876:    }
        -: 7877:
        1: 7878:    void cleanUpContext() {
        1: 7879:        delete currentContext;
        1: 7880:        currentContext = CATCH_NULL;
        1: 7881:    }
        -: 7882:}
        -: 7883:
        -: 7884:// #included from: catch_console_colour_impl.hpp
        -: 7885:#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED
        -: 7886:
        -: 7887:// #included from: catch_errno_guard.hpp
        -: 7888:#define TWOBLUECUBES_CATCH_ERRNO_GUARD_HPP_INCLUDED
        -: 7889:
        -: 7890:#include <cerrno>
        -: 7891:
        -: 7892:namespace Catch {
        -: 7893:
        -: 7894:    class ErrnoGuard {
        -: 7895:    public:
        2: 7896:        ErrnoGuard():m_oldErrno(errno){}
        2: 7897:        ~ErrnoGuard() { errno = m_oldErrno; }
        -: 7898:    private:
        -: 7899:        int m_oldErrno;
        -: 7900:    };
        -: 7901:
        -: 7902:}
        -: 7903:
        -: 7904:namespace Catch {
        -: 7905:    namespace {
        -: 7906:
        -: 7907:        struct IColourImpl {
        1: 7908:            virtual ~IColourImpl() {}
        -: 7909:            virtual void use( Colour::Code _colourCode ) = 0;
        -: 7910:        };
        -: 7911:
        -: 7912:        struct NoColourImpl : IColourImpl {
    #####: 7913:            void use( Colour::Code ) {}
        -: 7914:
    #####: 7915:            static IColourImpl* instance() {
    #####: 7916:                static NoColourImpl s_instance;
    #####: 7917:                return &s_instance;
        -: 7918:            }
        -: 7919:        };
        -: 7920:
        -: 7921:    } // anon namespace
        -: 7922:} // namespace Catch
        -: 7923:
        -: 7924:#if !defined( CATCH_CONFIG_COLOUR_NONE ) && !defined( CATCH_CONFIG_COLOUR_WINDOWS ) && !defined( CATCH_CONFIG_COLOUR_ANSI )
        -: 7925:#   ifdef CATCH_PLATFORM_WINDOWS
        -: 7926:#       define CATCH_CONFIG_COLOUR_WINDOWS
        -: 7927:#   else
        -: 7928:#       define CATCH_CONFIG_COLOUR_ANSI
        -: 7929:#   endif
        -: 7930:#endif
        -: 7931:
        -: 7932:#if defined ( CATCH_CONFIG_COLOUR_WINDOWS ) /////////////////////////////////////////
        -: 7933:
        -: 7934:namespace Catch {
        -: 7935:namespace {
        -: 7936:
        -: 7937:    class Win32ColourImpl : public IColourImpl {
        -: 7938:    public:
        -: 7939:        Win32ColourImpl() : stdoutHandle( GetStdHandle(STD_OUTPUT_HANDLE) )
        -: 7940:        {
        -: 7941:            CONSOLE_SCREEN_BUFFER_INFO csbiInfo;
        -: 7942:            GetConsoleScreenBufferInfo( stdoutHandle, &csbiInfo );
        -: 7943:            originalForegroundAttributes = csbiInfo.wAttributes & ~( BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_BLUE | BACKGROUND_INTENSITY );
        -: 7944:            originalBackgroundAttributes = csbiInfo.wAttributes & ~( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_INTENSITY );
        -: 7945:        }
        -: 7946:
        -: 7947:        virtual void use( Colour::Code _colourCode ) {
        -: 7948:            switch( _colourCode ) {
        -: 7949:                case Colour::None:      return setTextAttribute( originalForegroundAttributes );
        -: 7950:                case Colour::White:     return setTextAttribute( FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 7951:                case Colour::Red:       return setTextAttribute( FOREGROUND_RED );
        -: 7952:                case Colour::Green:     return setTextAttribute( FOREGROUND_GREEN );
        -: 7953:                case Colour::Blue:      return setTextAttribute( FOREGROUND_BLUE );
        -: 7954:                case Colour::Cyan:      return setTextAttribute( FOREGROUND_BLUE | FOREGROUND_GREEN );
        -: 7955:                case Colour::Yellow:    return setTextAttribute( FOREGROUND_RED | FOREGROUND_GREEN );
        -: 7956:                case Colour::Grey:      return setTextAttribute( 0 );
        -: 7957:
        -: 7958:                case Colour::LightGrey:     return setTextAttribute( FOREGROUND_INTENSITY );
        -: 7959:                case Colour::BrightRed:     return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_RED );
        -: 7960:                case Colour::BrightGreen:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN );
        -: 7961:                case Colour::BrightWhite:   return setTextAttribute( FOREGROUND_INTENSITY | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE );
        -: 7962:
        -: 7963:                case Colour::Bright: throw std::logic_error( "not a colour" );
        -: 7964:            }
        -: 7965:        }
        -: 7966:
        -: 7967:    private:
        -: 7968:        void setTextAttribute( WORD _textAttribute ) {
        -: 7969:            SetConsoleTextAttribute( stdoutHandle, _textAttribute | originalBackgroundAttributes );
        -: 7970:        }
        -: 7971:        HANDLE stdoutHandle;
        -: 7972:        WORD originalForegroundAttributes;
        -: 7973:        WORD originalBackgroundAttributes;
        -: 7974:    };
        -: 7975:
        -: 7976:    IColourImpl* platformColourInstance() {
        -: 7977:        static Win32ColourImpl s_instance;
        -: 7978:
        -: 7979:        Ptr<IConfig const> config = getCurrentContext().getConfig();
        -: 7980:        UseColour::YesOrNo colourMode = config
        -: 7981:            ? config->useColour()
        -: 7982:            : UseColour::Auto;
        -: 7983:        if( colourMode == UseColour::Auto )
        -: 7984:            colourMode = !isDebuggerActive()
        -: 7985:                ? UseColour::Yes
        -: 7986:                : UseColour::No;
        -: 7987:        return colourMode == UseColour::Yes
        -: 7988:            ? &s_instance
        -: 7989:            : NoColourImpl::instance();
        -: 7990:    }
        -: 7991:
        -: 7992:} // end anon namespace
        -: 7993:} // end namespace Catch
        -: 7994:
        -: 7995:#elif defined( CATCH_CONFIG_COLOUR_ANSI ) //////////////////////////////////////
        -: 7996:
        -: 7997:#include <unistd.h>
        -: 7998:
        -: 7999:namespace Catch {
        -: 8000:namespace {
        -: 8001:
        -: 8002:    // use POSIX/ ANSI console terminal codes
        -: 8003:    // Thanks to Adam Strzelecki for original contribution
        -: 8004:    // (http://github.com/nanoant)
        -: 8005:    // https://github.com/philsquared/Catch/pull/131
        -: 8006:    class PosixColourImpl : public IColourImpl {
        -: 8007:    public:
        8: 8008:        virtual void use( Colour::Code _colourCode ) {
        8: 8009:            switch( _colourCode ) {
        4: 8010:                case Colour::None:
        4: 8011:                case Colour::White:     return setColour( "[0m" );
    #####: 8012:                case Colour::Red:       return setColour( "[0;31m" );
    #####: 8013:                case Colour::Green:     return setColour( "[0;32m" );
    #####: 8014:                case Colour::Blue:      return setColour( "[0;34m" );
    #####: 8015:                case Colour::Cyan:      return setColour( "[0;36m" );
        1: 8016:                case Colour::Yellow:    return setColour( "[0;33m" );
    #####: 8017:                case Colour::Grey:      return setColour( "[1;30m" );
        -: 8018:
    #####: 8019:                case Colour::LightGrey:     return setColour( "[0;37m" );
        1: 8020:                case Colour::BrightRed:     return setColour( "[1;31m" );
        2: 8021:                case Colour::BrightGreen:   return setColour( "[1;32m" );
    #####: 8022:                case Colour::BrightWhite:   return setColour( "[1;37m" );
        -: 8023:
    #####: 8024:                case Colour::Bright: throw std::logic_error( "not a colour" );
        -: 8025:            }
        -: 8026:        }
        1: 8027:        static IColourImpl* instance() {
        1: 8028:            static PosixColourImpl s_instance;
        1: 8029:            return &s_instance;
        -: 8030:        }
        -: 8031:
        -: 8032:    private:
        8: 8033:        void setColour( const char* _escapeCode ) {
        8: 8034:            Catch::cout() << '\033' << _escapeCode;
        8: 8035:        }
        -: 8036:    };
        -: 8037:
        1: 8038:    IColourImpl* platformColourInstance() {
        2: 8039:        ErrnoGuard guard;
        1: 8040:        Ptr<IConfig const> config = getCurrentContext().getConfig();
        -: 8041:        UseColour::YesOrNo colourMode = config
       1*: 8042:            ? config->useColour()
        1: 8043:            : UseColour::Auto;
        1: 8044:        if( colourMode == UseColour::Auto )
        3: 8045:            colourMode = (!isDebuggerActive() && isatty(STDOUT_FILENO) )
       2*: 8046:                ? UseColour::Yes
        -: 8047:                : UseColour::No;
        -: 8048:        return colourMode == UseColour::Yes
        1: 8049:            ? PosixColourImpl::instance()
       2*: 8050:            : NoColourImpl::instance();
        -: 8051:    }
        -: 8052:
        -: 8053:} // end anon namespace
        -: 8054:} // end namespace Catch
        -: 8055:
        -: 8056:#else  // not Windows or ANSI ///////////////////////////////////////////////
        -: 8057:
        -: 8058:namespace Catch {
        -: 8059:
        -: 8060:    static IColourImpl* platformColourInstance() { return NoColourImpl::instance(); }
        -: 8061:
        -: 8062:} // end namespace Catch
        -: 8063:
        -: 8064:#endif // Windows/ ANSI/ None
        -: 8065:
        -: 8066:namespace Catch {
        -: 8067:
        4: 8068:    Colour::Colour( Code _colourCode ) : m_moved( false ) { use( _colourCode ); }
    #####: 8069:    Colour::Colour( Colour const& _other ) : m_moved( false ) { const_cast<Colour&>( _other ).m_moved = true; }
        4: 8070:    Colour::~Colour(){ if( !m_moved ) use( None ); }
        -: 8071:
        8: 8072:    void Colour::use( Code _colourCode ) {
        8: 8073:        static IColourImpl* impl = platformColourInstance();
        8: 8074:        impl->use( _colourCode );
        8: 8075:    }
        -: 8076:
        -: 8077:} // end namespace Catch
        -: 8078:
        -: 8079:// #included from: catch_generators_impl.hpp
        -: 8080:#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED
        -: 8081:
        -: 8082:#include <vector>
        -: 8083:#include <string>
        -: 8084:#include <map>
        -: 8085:
        -: 8086:namespace Catch {
        -: 8087:
        -: 8088:    struct GeneratorInfo : IGeneratorInfo {
        -: 8089:
    #####: 8090:        GeneratorInfo( std::size_t size )
    #####: 8091:        :   m_size( size ),
    #####: 8092:            m_currentIndex( 0 )
    #####: 8093:        {}
        -: 8094:
    #####: 8095:        bool moveNext() {
    #####: 8096:            if( ++m_currentIndex == m_size ) {
    #####: 8097:                m_currentIndex = 0;
    #####: 8098:                return false;
        -: 8099:            }
    #####: 8100:            return true;
        -: 8101:        }
        -: 8102:
    #####: 8103:        std::size_t getCurrentIndex() const {
    #####: 8104:            return m_currentIndex;
        -: 8105:        }
        -: 8106:
        -: 8107:        std::size_t m_size;
        -: 8108:        std::size_t m_currentIndex;
        -: 8109:    };
        -: 8110:
        -: 8111:    ///////////////////////////////////////////////////////////////////////////
        -: 8112:
        -: 8113:    class GeneratorsForTest : public IGeneratorsForTest {
        -: 8114:
        -: 8115:    public:
    #####: 8116:        ~GeneratorsForTest() {
    #####: 8117:            deleteAll( m_generatorsInOrder );
    #####: 8118:        }
------------------
_ZN5Catch17GeneratorsForTestD0Ev:
    #####: 8116:        ~GeneratorsForTest() {
        -: 8117:            deleteAll( m_generatorsInOrder );
    #####: 8118:        }
------------------
_ZN5Catch17GeneratorsForTestD2Ev:
    #####: 8116:        ~GeneratorsForTest() {
    #####: 8117:            deleteAll( m_generatorsInOrder );
    #####: 8118:        }
------------------
        -: 8119:
    #####: 8120:        IGeneratorInfo& getGeneratorInfo( std::string const& fileInfo, std::size_t size ) {
    #####: 8121:            std::map<std::string, IGeneratorInfo*>::const_iterator it = m_generatorsByName.find( fileInfo );
    #####: 8122:            if( it == m_generatorsByName.end() ) {
    #####: 8123:                IGeneratorInfo* info = new GeneratorInfo( size );
    #####: 8124:                m_generatorsByName.insert( std::make_pair( fileInfo, info ) );
    #####: 8125:                m_generatorsInOrder.push_back( info );
    #####: 8126:                return *info;
        -: 8127:            }
    #####: 8128:            return *it->second;
        -: 8129:        }
        -: 8130:
    #####: 8131:        bool moveNext() {
    #####: 8132:            std::vector<IGeneratorInfo*>::const_iterator it = m_generatorsInOrder.begin();
    #####: 8133:            std::vector<IGeneratorInfo*>::const_iterator itEnd = m_generatorsInOrder.end();
    #####: 8134:            for(; it != itEnd; ++it ) {
    #####: 8135:                if( (*it)->moveNext() )
    #####: 8136:                    return true;
        -: 8137:            }
    #####: 8138:            return false;
        -: 8139:        }
        -: 8140:
        -: 8141:    private:
        -: 8142:        std::map<std::string, IGeneratorInfo*> m_generatorsByName;
        -: 8143:        std::vector<IGeneratorInfo*> m_generatorsInOrder;
        -: 8144:    };
        -: 8145:
    #####: 8146:    IGeneratorsForTest* createGeneratorsForTest()
        -: 8147:    {
    #####: 8148:        return new GeneratorsForTest();
        -: 8149:    }
        -: 8150:
        -: 8151:} // end namespace Catch
        -: 8152:
        -: 8153:// #included from: catch_assertionresult.hpp
        -: 8154:#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED
        -: 8155:
        -: 8156:namespace Catch {
        -: 8157:
        2: 8158:    AssertionInfo::AssertionInfo():macroName(""), capturedExpression(""), resultDisposition(ResultDisposition::Normal), secondArg(""){}
        -: 8159:
       12: 8160:    AssertionInfo::AssertionInfo(   char const * _macroName,
        -: 8161:                                    SourceLineInfo const& _lineInfo,
        -: 8162:                                    char const * _capturedExpression,
        -: 8163:                                    ResultDisposition::Flags _resultDisposition,
       12: 8164:                                    char const * _secondArg)
        -: 8165:    :   macroName( _macroName ),
        -: 8166:        lineInfo( _lineInfo ),
        -: 8167:        capturedExpression( _capturedExpression ),
        -: 8168:        resultDisposition( _resultDisposition ),
       12: 8169:        secondArg( _secondArg )
       12: 8170:    {}
        -: 8171:
        1: 8172:    AssertionResult::AssertionResult() {}
        -: 8173:
    #####: 8174:    AssertionResult::AssertionResult( AssertionInfo const& info, AssertionResultData const& data )
        -: 8175:    :   m_info( info ),
    #####: 8176:        m_resultData( data )
    #####: 8177:    {}
        -: 8178:
        1: 8179:    AssertionResult::~AssertionResult() {}
        -: 8180:
        -: 8181:    // Result was a success
    #####: 8182:    bool AssertionResult::succeeded() const {
    #####: 8183:        return Catch::isOk( m_resultData.resultType );
        -: 8184:    }
        -: 8185:
        -: 8186:    // Result was a success, or failure is suppressed
    #####: 8187:    bool AssertionResult::isOk() const {
    #####: 8188:        return Catch::isOk( m_resultData.resultType ) || shouldSuppressFailure( m_info.resultDisposition );
        -: 8189:    }
        -: 8190:
    #####: 8191:    ResultWas::OfType AssertionResult::getResultType() const {
    #####: 8192:        return m_resultData.resultType;
        -: 8193:    }
        -: 8194:
    #####: 8195:    bool AssertionResult::hasExpression() const {
    #####: 8196:        return m_info.capturedExpression[0] != 0;
        -: 8197:    }
        -: 8198:
    #####: 8199:    bool AssertionResult::hasMessage() const {
    #####: 8200:        return !m_resultData.message.empty();
        -: 8201:    }
        -: 8202:
    #####: 8203:    std::string capturedExpressionWithSecondArgument( char const * capturedExpression, char const * secondArg ) {
    #####: 8204:        return (secondArg[0] == 0 || secondArg[0] == '"' && secondArg[1] == '"')
    #####: 8205:            ? capturedExpression
    #####: 8206:            : std::string(capturedExpression) + ", " + secondArg;
        -: 8207:    }
        -: 8208:
    #####: 8209:    std::string AssertionResult::getExpression() const {
    #####: 8210:        if( isFalseTest( m_info.resultDisposition ) )
    #####: 8211:            return "!(" + capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg) + ")";
        -: 8212:        else
    #####: 8213:            return capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg);
        -: 8214:    }
    #####: 8215:    std::string AssertionResult::getExpressionInMacro() const {
    #####: 8216:        if( m_info.macroName[0] == 0 )
    #####: 8217:            return capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg);
        -: 8218:        else
    #####: 8219:            return std::string(m_info.macroName) + "( " + capturedExpressionWithSecondArgument(m_info.capturedExpression, m_info.secondArg) + " )";
        -: 8220:    }
        -: 8221:
    #####: 8222:    bool AssertionResult::hasExpandedExpression() const {
    #####: 8223:        return hasExpression() && getExpandedExpression() != getExpression();
        -: 8224:    }
        -: 8225:
    #####: 8226:    std::string AssertionResult::getExpandedExpression() const {
    #####: 8227:        return m_resultData.reconstructExpression();
        -: 8228:    }
        -: 8229:
    #####: 8230:    std::string AssertionResult::getMessage() const {
    #####: 8231:        return m_resultData.message;
        -: 8232:    }
    #####: 8233:    SourceLineInfo AssertionResult::getSourceInfo() const {
    #####: 8234:        return m_info.lineInfo;
        -: 8235:    }
        -: 8236:
    #####: 8237:    std::string AssertionResult::getTestMacroName() const {
    #####: 8238:        return m_info.macroName;
        -: 8239:    }
        -: 8240:
    #####: 8241:    void AssertionResult::discardDecomposedExpression() const {
    #####: 8242:        m_resultData.decomposedExpression = CATCH_NULL;
    #####: 8243:    }
        -: 8244:
    #####: 8245:    void AssertionResult::expandDecomposedExpression() const {
    #####: 8246:        m_resultData.reconstructExpression();
    #####: 8247:    }
        -: 8248:
        -: 8249:} // end namespace Catch
        -: 8250:
        -: 8251:// #included from: catch_test_case_info.hpp
        -: 8252:#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED
        -: 8253:
        -: 8254:#include <cctype>
        -: 8255:
        -: 8256:namespace Catch {
        -: 8257:
        3: 8258:    inline TestCaseInfo::SpecialProperties parseSpecialTag( std::string const& tag ) {
        6: 8259:        if( startsWith( tag, '.' ) ||
       6*: 8260:            tag == "hide" ||
        3: 8261:            tag == "!hide" )
    #####: 8262:            return TestCaseInfo::IsHidden;
        3: 8263:        else if( tag == "!throws" )
    #####: 8264:            return TestCaseInfo::Throws;
        3: 8265:        else if( tag == "!shouldfail" )
    #####: 8266:            return TestCaseInfo::ShouldFail;
        3: 8267:        else if( tag == "!mayfail" )
    #####: 8268:            return TestCaseInfo::MayFail;
        3: 8269:        else if( tag == "!nonportable" )
    #####: 8270:            return TestCaseInfo::NonPortable;
        -: 8271:        else
        3: 8272:            return TestCaseInfo::None;
        -: 8273:    }
        1: 8274:    inline bool isReservedTag( std::string const& tag ) {
       1*: 8275:        return parseSpecialTag( tag ) == TestCaseInfo::None && tag.size() > 0 && !std::isalnum( tag[0] );
        -: 8276:    }
        1: 8277:    inline void enforceNotReservedTag( std::string const& tag, SourceLineInfo const& _lineInfo ) {
        1: 8278:        if( isReservedTag( tag ) ) {
    #####: 8279:            std::ostringstream ss;
    #####: 8280:            ss << Colour(Colour::Red)
        -: 8281:               << "Tag name [" << tag << "] not allowed.\n"
    #####: 8282:               << "Tag names starting with non alpha-numeric characters are reserved\n"
    #####: 8283:               << Colour(Colour::FileName)
    #####: 8284:               << _lineInfo << '\n';
    #####: 8285:            throw std::runtime_error(ss.str());
        -: 8286:        }
        1: 8287:    }
        -: 8288:
        1: 8289:    TestCase makeTestCase(  ITestCase* _testCase,
        -: 8290:                            std::string const& _className,
        -: 8291:                            std::string const& _name,
        -: 8292:                            std::string const& _descOrTags,
        -: 8293:                            SourceLineInfo const& _lineInfo )
        -: 8294:    {
        1: 8295:        bool isHidden( startsWith( _name, "./" ) ); // Legacy support
        -: 8296:
        -: 8297:        // Parse out tags
        2: 8298:        std::set<std::string> tags;
        2: 8299:        std::string desc, tag;
        1: 8300:        bool inTag = false;
       14: 8301:        for( std::size_t i = 0; i < _descOrTags.size(); ++i ) {
       13: 8302:            char c = _descOrTags[i];
       13: 8303:            if( !inTag ) {
        1: 8304:                if( c == '[' )
        1: 8305:                    inTag = true;
        -: 8306:                else
    #####: 8307:                    desc += c;
        -: 8308:            }
        -: 8309:            else {
       12: 8310:                if( c == ']' ) {
        1: 8311:                    TestCaseInfo::SpecialProperties prop = parseSpecialTag( tag );
        1: 8312:                    if( prop == TestCaseInfo::IsHidden )
    #####: 8313:                        isHidden = true;
        1: 8314:                    else if( prop == TestCaseInfo::None )
        1: 8315:                        enforceNotReservedTag( tag, _lineInfo );
        -: 8316:
        1: 8317:                    tags.insert( tag );
        1: 8318:                    tag.clear();
        1: 8319:                    inTag = false;
        -: 8320:                }
        -: 8321:                else
       11: 8322:                    tag += c;
        -: 8323:            }
        -: 8324:        }
        1: 8325:        if( isHidden ) {
    #####: 8326:            tags.insert( "hide" );
    #####: 8327:            tags.insert( "." );
        -: 8328:        }
        -: 8329:
        2: 8330:        TestCaseInfo info( _name, _className, desc, tags, _lineInfo );
        2: 8331:        return TestCase( _testCase, info );
        -: 8332:    }
        -: 8333:
        1: 8334:    void setTags( TestCaseInfo& testCaseInfo, std::set<std::string> const& tags )
        -: 8335:    {
        1: 8336:        testCaseInfo.tags = tags;
        1: 8337:        testCaseInfo.lcaseTags.clear();
        -: 8338:
        1: 8339:        std::ostringstream oss;
        2: 8340:        for( std::set<std::string>::const_iterator it = tags.begin(), itEnd = tags.end(); it != itEnd; ++it ) {
        1: 8341:            oss << '[' << *it << ']';
        2: 8342:            std::string lcaseTag = toLower( *it );
        1: 8343:            testCaseInfo.properties = static_cast<TestCaseInfo::SpecialProperties>( testCaseInfo.properties | parseSpecialTag( lcaseTag ) );
        1: 8344:            testCaseInfo.lcaseTags.insert( lcaseTag );
        -: 8345:        }
        1: 8346:        testCaseInfo.tagsAsString = oss.str();
        1: 8347:    }
        -: 8348:
        1: 8349:    TestCaseInfo::TestCaseInfo( std::string const& _name,
        -: 8350:                                std::string const& _className,
        -: 8351:                                std::string const& _description,
        -: 8352:                                std::set<std::string> const& _tags,
        1: 8353:                                SourceLineInfo const& _lineInfo )
        -: 8354:    :   name( _name ),
        -: 8355:        className( _className ),
        -: 8356:        description( _description ),
        -: 8357:        lineInfo( _lineInfo ),
        1: 8358:        properties( None )
        -: 8359:    {
        1: 8360:        setTags( *this, _tags );
        1: 8361:    }
        -: 8362:
        7: 8363:    TestCaseInfo::TestCaseInfo( TestCaseInfo const& other )
        7: 8364:    :   name( other.name ),
        7: 8365:        className( other.className ),
        7: 8366:        description( other.description ),
        7: 8367:        tags( other.tags ),
        7: 8368:        lcaseTags( other.lcaseTags ),
        7: 8369:        tagsAsString( other.tagsAsString ),
        -: 8370:        lineInfo( other.lineInfo ),
        7: 8371:        properties( other.properties )
        7: 8372:    {}
        -: 8373:
    #####: 8374:    bool TestCaseInfo::isHidden() const {
    #####: 8375:        return ( properties & IsHidden ) != 0;
        -: 8376:    }
    #####: 8377:    bool TestCaseInfo::throws() const {
    #####: 8378:        return ( properties & Throws ) != 0;
        -: 8379:    }
    #####: 8380:    bool TestCaseInfo::okToFail() const {
    #####: 8381:        return ( properties & (ShouldFail | MayFail ) ) != 0;
        -: 8382:    }
        1: 8383:    bool TestCaseInfo::expectedToFail() const {
        1: 8384:        return ( properties & (ShouldFail ) ) != 0;
        -: 8385:    }
        -: 8386:
        1: 8387:    TestCase::TestCase( ITestCase* testCase, TestCaseInfo const& info ) : TestCaseInfo( info ), test( testCase ) {}
        -: 8388:
        3: 8389:    TestCase::TestCase( TestCase const& other )
        -: 8390:    :   TestCaseInfo( other ),
        3: 8391:        test( other.test )
        3: 8392:    {}
        -: 8393:
    #####: 8394:    TestCase TestCase::withName( std::string const& _newName ) const {
    #####: 8395:        TestCase other( *this );
    #####: 8396:        other.name = _newName;
    #####: 8397:        return other;
        -: 8398:    }
        -: 8399:
    #####: 8400:    void TestCase::swap( TestCase& other ) {
    #####: 8401:        test.swap( other.test );
    #####: 8402:        name.swap( other.name );
    #####: 8403:        className.swap( other.className );
    #####: 8404:        description.swap( other.description );
    #####: 8405:        tags.swap( other.tags );
    #####: 8406:        lcaseTags.swap( other.lcaseTags );
    #####: 8407:        tagsAsString.swap( other.tagsAsString );
    #####: 8408:        std::swap( TestCaseInfo::properties, static_cast<TestCaseInfo&>( other ).properties );
    #####: 8409:        std::swap( lineInfo, other.lineInfo );
    #####: 8410:    }
        -: 8411:
        6: 8412:    void TestCase::invoke() const {
        6: 8413:        test->invoke();
        6: 8414:    }
        -: 8415:
    #####: 8416:    bool TestCase::operator == ( TestCase const& other ) const {
    #####: 8417:        return  test.get() == other.test.get() &&
    #####: 8418:                name == other.name &&
    #####: 8419:                className == other.className;
        -: 8420:    }
        -: 8421:
    #####: 8422:    bool TestCase::operator < ( TestCase const& other ) const {
    #####: 8423:        return name < other.name;
        -: 8424:    }
    #####: 8425:    TestCase& TestCase::operator = ( TestCase const& other ) {
    #####: 8426:        TestCase temp( other );
    #####: 8427:        swap( temp );
    #####: 8428:        return *this;
        -: 8429:    }
        -: 8430:
        9: 8431:    TestCaseInfo const& TestCase::getTestCaseInfo() const
        -: 8432:    {
        9: 8433:        return *this;
        -: 8434:    }
        -: 8435:
        -: 8436:} // end namespace Catch
        -: 8437:
        -: 8438:// #included from: catch_version.hpp
        -: 8439:#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED
        -: 8440:
        -: 8441:namespace Catch {
        -: 8442:
    #####: 8443:    Version::Version
        -: 8444:        (   unsigned int _majorVersion,
        -: 8445:            unsigned int _minorVersion,
        -: 8446:            unsigned int _patchNumber,
        -: 8447:            char const * const _branchName,
    #####: 8448:            unsigned int _buildNumber )
        -: 8449:    :   majorVersion( _majorVersion ),
        -: 8450:        minorVersion( _minorVersion ),
        -: 8451:        patchNumber( _patchNumber ),
        -: 8452:        branchName( _branchName ),
    #####: 8453:        buildNumber( _buildNumber )
    #####: 8454:    {}
        -: 8455:
    #####: 8456:    std::ostream& operator << ( std::ostream& os, Version const& version ) {
    #####: 8457:        os  << version.majorVersion << '.'
    #####: 8458:            << version.minorVersion << '.'
    #####: 8459:            << version.patchNumber;
        -: 8460:        // branchName is never null -> 0th char is \0 if it is empty
    #####: 8461:        if (version.branchName[0]) {
    #####: 8462:            os << '-' << version.branchName
    #####: 8463:               << '.' << version.buildNumber;
        -: 8464:        }
    #####: 8465:        return os;
        -: 8466:    }
        -: 8467:
    #####: 8468:    inline Version libraryVersion() {
    #####: 8469:        static Version version( 1, 12, 1, "", 0 );
    #####: 8470:        return version;
        -: 8471:    }
        -: 8472:
        -: 8473:}
        -: 8474:
        -: 8475:// #included from: catch_message.hpp
        -: 8476:#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED
        -: 8477:
        -: 8478:namespace Catch {
        -: 8479:
    #####: 8480:    MessageInfo::MessageInfo(   std::string const& _macroName,
        -: 8481:                                SourceLineInfo const& _lineInfo,
    #####: 8482:                                ResultWas::OfType _type )
        -: 8483:    :   macroName( _macroName ),
        -: 8484:        lineInfo( _lineInfo ),
        -: 8485:        type( _type ),
    #####: 8486:        sequence( ++globalCount )
    #####: 8487:    {}
        -: 8488:
        -: 8489:    // This may need protecting if threading support is added
        -: 8490:    unsigned int MessageInfo::globalCount = 0;
        -: 8491:
        -: 8492:    ////////////////////////////////////////////////////////////////////////////
        -: 8493:
    #####: 8494:    ScopedMessage::ScopedMessage( MessageBuilder const& builder )
    #####: 8495:    : m_info( builder.m_info )
        -: 8496:    {
    #####: 8497:        m_info.message = builder.m_stream.str();
    #####: 8498:        getResultCapture().pushScopedMessage( m_info );
    #####: 8499:    }
    #####: 8500:    ScopedMessage::ScopedMessage( ScopedMessage const& other )
    #####: 8501:    : m_info( other.m_info )
    #####: 8502:    {}
        -: 8503:
        -: 8504:#if defined(_MSC_VER)
        -: 8505:#pragma warning(push)
        -: 8506:#pragma warning(disable:4996) // std::uncaught_exception is deprecated in C++17
        -: 8507:#endif
    #####: 8508:    ScopedMessage::~ScopedMessage() {
    #####: 8509:        if ( !std::uncaught_exception() ){
    #####: 8510:            getResultCapture().popScopedMessage(m_info);
        -: 8511:        }
    #####: 8512:    }
        -: 8513:#if defined(_MSC_VER)
        -: 8514:#pragma warning(pop)
        -: 8515:#endif
        -: 8516:
        -: 8517:} // end namespace Catch
        -: 8518:
        -: 8519:// #included from: catch_legacy_reporter_adapter.hpp
        -: 8520:#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED
        -: 8521:
        -: 8522:// #included from: catch_legacy_reporter_adapter.h
        -: 8523:#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED
        -: 8524:
        -: 8525:namespace Catch
        -: 8526:{
        -: 8527:    // Deprecated
        -: 8528:    struct IReporter : IShared {
        -: 8529:        virtual ~IReporter();
        -: 8530:
        -: 8531:        virtual bool shouldRedirectStdout() const = 0;
        -: 8532:
        -: 8533:        virtual void StartTesting() = 0;
        -: 8534:        virtual void EndTesting( Totals const& totals ) = 0;
        -: 8535:        virtual void StartGroup( std::string const& groupName ) = 0;
        -: 8536:        virtual void EndGroup( std::string const& groupName, Totals const& totals ) = 0;
        -: 8537:        virtual void StartTestCase( TestCaseInfo const& testInfo ) = 0;
        -: 8538:        virtual void EndTestCase( TestCaseInfo const& testInfo, Totals const& totals, std::string const& stdOut, std::string const& stdErr ) = 0;
        -: 8539:        virtual void StartSection( std::string const& sectionName, std::string const& description ) = 0;
        -: 8540:        virtual void EndSection( std::string const& sectionName, Counts const& assertions ) = 0;
        -: 8541:        virtual void NoAssertionsInSection( std::string const& sectionName ) = 0;
        -: 8542:        virtual void NoAssertionsInTestCase( std::string const& testName ) = 0;
        -: 8543:        virtual void Aborted() = 0;
        -: 8544:        virtual void Result( AssertionResult const& result ) = 0;
        -: 8545:    };
        -: 8546:
        -: 8547:    class LegacyReporterAdapter : public SharedImpl<IStreamingReporter>
        -: 8548:    {
        -: 8549:    public:
        -: 8550:        LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter );
        -: 8551:        virtual ~LegacyReporterAdapter();
        -: 8552:
        -: 8553:        virtual ReporterPreferences getPreferences() const;
        -: 8554:        virtual void noMatchingTestCases( std::string const& );
        -: 8555:        virtual void testRunStarting( TestRunInfo const& );
        -: 8556:        virtual void testGroupStarting( GroupInfo const& groupInfo );
        -: 8557:        virtual void testCaseStarting( TestCaseInfo const& testInfo );
        -: 8558:        virtual void sectionStarting( SectionInfo const& sectionInfo );
        -: 8559:        virtual void assertionStarting( AssertionInfo const& );
        -: 8560:        virtual bool assertionEnded( AssertionStats const& assertionStats );
        -: 8561:        virtual void sectionEnded( SectionStats const& sectionStats );
        -: 8562:        virtual void testCaseEnded( TestCaseStats const& testCaseStats );
        -: 8563:        virtual void testGroupEnded( TestGroupStats const& testGroupStats );
        -: 8564:        virtual void testRunEnded( TestRunStats const& testRunStats );
        -: 8565:        virtual void skipTest( TestCaseInfo const& );
        -: 8566:
        -: 8567:    private:
        -: 8568:        Ptr<IReporter> m_legacyReporter;
        -: 8569:    };
        -: 8570:}
        -: 8571:
        -: 8572:namespace Catch
        -: 8573:{
    #####: 8574:    LegacyReporterAdapter::LegacyReporterAdapter( Ptr<IReporter> const& legacyReporter )
    #####: 8575:    :   m_legacyReporter( legacyReporter )
    #####: 8576:    {}
    #####: 8577:    LegacyReporterAdapter::~LegacyReporterAdapter() {}
------------------
_ZN5Catch21LegacyReporterAdapterD0Ev:
    #####: 8577:    LegacyReporterAdapter::~LegacyReporterAdapter() {}
------------------
_ZN5Catch21LegacyReporterAdapterD2Ev:
    #####: 8577:    LegacyReporterAdapter::~LegacyReporterAdapter() {}
------------------
        -: 8578:
    #####: 8579:    ReporterPreferences LegacyReporterAdapter::getPreferences() const {
    #####: 8580:        ReporterPreferences prefs;
    #####: 8581:        prefs.shouldRedirectStdOut = m_legacyReporter->shouldRedirectStdout();
    #####: 8582:        return prefs;
        -: 8583:    }
        -: 8584:
    #####: 8585:    void LegacyReporterAdapter::noMatchingTestCases( std::string const& ) {}
    #####: 8586:    void LegacyReporterAdapter::testRunStarting( TestRunInfo const& ) {
    #####: 8587:        m_legacyReporter->StartTesting();
    #####: 8588:    }
    #####: 8589:    void LegacyReporterAdapter::testGroupStarting( GroupInfo const& groupInfo ) {
    #####: 8590:        m_legacyReporter->StartGroup( groupInfo.name );
    #####: 8591:    }
    #####: 8592:    void LegacyReporterAdapter::testCaseStarting( TestCaseInfo const& testInfo ) {
    #####: 8593:        m_legacyReporter->StartTestCase( testInfo );
    #####: 8594:    }
    #####: 8595:    void LegacyReporterAdapter::sectionStarting( SectionInfo const& sectionInfo ) {
    #####: 8596:        m_legacyReporter->StartSection( sectionInfo.name, sectionInfo.description );
    #####: 8597:    }
    #####: 8598:    void LegacyReporterAdapter::assertionStarting( AssertionInfo const& ) {
        -: 8599:        // Not on legacy interface
    #####: 8600:    }
        -: 8601:
    #####: 8602:    bool LegacyReporterAdapter::assertionEnded( AssertionStats const& assertionStats ) {
    #####: 8603:        if( assertionStats.assertionResult.getResultType() != ResultWas::Ok ) {
    #####: 8604:            for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
    #####: 8605:                    it != itEnd;
    #####: 8606:                    ++it ) {
    #####: 8607:                if( it->type == ResultWas::Info ) {
    #####: 8608:                    ResultBuilder rb( it->macroName.c_str(), it->lineInfo, "", ResultDisposition::Normal );
    #####: 8609:                    rb << it->message;
    #####: 8610:                    rb.setResultType( ResultWas::Info );
    #####: 8611:                    AssertionResult result = rb.build();
    #####: 8612:                    m_legacyReporter->Result( result );
        -: 8613:                }
        -: 8614:            }
        -: 8615:        }
    #####: 8616:        m_legacyReporter->Result( assertionStats.assertionResult );
    #####: 8617:        return true;
        -: 8618:    }
    #####: 8619:    void LegacyReporterAdapter::sectionEnded( SectionStats const& sectionStats ) {
    #####: 8620:        if( sectionStats.missingAssertions )
    #####: 8621:            m_legacyReporter->NoAssertionsInSection( sectionStats.sectionInfo.name );
    #####: 8622:        m_legacyReporter->EndSection( sectionStats.sectionInfo.name, sectionStats.assertions );
    #####: 8623:    }
    #####: 8624:    void LegacyReporterAdapter::testCaseEnded( TestCaseStats const& testCaseStats ) {
    #####: 8625:        m_legacyReporter->EndTestCase
    #####: 8626:            (   testCaseStats.testInfo,
    #####: 8627:                testCaseStats.totals,
    #####: 8628:                testCaseStats.stdOut,
    #####: 8629:                testCaseStats.stdErr );
    #####: 8630:    }
    #####: 8631:    void LegacyReporterAdapter::testGroupEnded( TestGroupStats const& testGroupStats ) {
    #####: 8632:        if( testGroupStats.aborting )
    #####: 8633:            m_legacyReporter->Aborted();
    #####: 8634:        m_legacyReporter->EndGroup( testGroupStats.groupInfo.name, testGroupStats.totals );
    #####: 8635:    }
    #####: 8636:    void LegacyReporterAdapter::testRunEnded( TestRunStats const& testRunStats ) {
    #####: 8637:        m_legacyReporter->EndTesting( testRunStats.totals );
    #####: 8638:    }
    #####: 8639:    void LegacyReporterAdapter::skipTest( TestCaseInfo const& ) {
    #####: 8640:    }
        -: 8641:}
        -: 8642:
        -: 8643:// #included from: catch_timer.hpp
        -: 8644:
        -: 8645:#ifdef __clang__
        -: 8646:#pragma clang diagnostic push
        -: 8647:#pragma clang diagnostic ignored "-Wc++11-long-long"
        -: 8648:#endif
        -: 8649:
        -: 8650:#ifdef CATCH_PLATFORM_WINDOWS
        -: 8651:
        -: 8652:#else
        -: 8653:
        -: 8654:#include <sys/time.h>
        -: 8655:
        -: 8656:#endif
        -: 8657:
        -: 8658:namespace Catch {
        -: 8659:
        -: 8660:    namespace {
        -: 8661:#ifdef CATCH_PLATFORM_WINDOWS
        -: 8662:        UInt64 getCurrentTicks() {
        -: 8663:            static UInt64 hz=0, hzo=0;
        -: 8664:            if (!hz) {
        -: 8665:                QueryPerformanceFrequency( reinterpret_cast<LARGE_INTEGER*>( &hz ) );
        -: 8666:                QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &hzo ) );
        -: 8667:            }
        -: 8668:            UInt64 t;
        -: 8669:            QueryPerformanceCounter( reinterpret_cast<LARGE_INTEGER*>( &t ) );
        -: 8670:            return ((t-hzo)*1000000)/hz;
        -: 8671:        }
        -: 8672:#else
       54: 8673:        UInt64 getCurrentTicks() {
        -: 8674:            timeval t;
       54: 8675:            gettimeofday(&t,CATCH_NULL);
       54: 8676:            return static_cast<UInt64>( t.tv_sec ) * 1000000ull + static_cast<UInt64>( t.tv_usec );
        -: 8677:        }
        -: 8678:#endif
        -: 8679:    }
        -: 8680:
       42: 8681:    void Timer::start() {
       42: 8682:        m_ticks = getCurrentTicks();
       42: 8683:    }
       12: 8684:    unsigned int Timer::getElapsedMicroseconds() const {
       12: 8685:        return static_cast<unsigned int>(getCurrentTicks() - m_ticks);
        -: 8686:    }
    #####: 8687:    unsigned int Timer::getElapsedMilliseconds() const {
    #####: 8688:        return static_cast<unsigned int>(getElapsedMicroseconds()/1000);
        -: 8689:    }
       12: 8690:    double Timer::getElapsedSeconds() const {
       12: 8691:        return getElapsedMicroseconds()/1000000.0;
        -: 8692:    }
        -: 8693:
        -: 8694:} // namespace Catch
        -: 8695:
        -: 8696:#ifdef __clang__
        -: 8697:#pragma clang diagnostic pop
        -: 8698:#endif
        -: 8699:// #included from: catch_common.hpp
        -: 8700:#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED
        -: 8701:
        -: 8702:#include <cstring>
        -: 8703:#include <cctype>
        -: 8704:
        -: 8705:namespace Catch {
        -: 8706:
        2: 8707:    bool startsWith( std::string const& s, std::string const& prefix ) {
       2*: 8708:        return s.size() >= prefix.size() && std::equal(prefix.begin(), prefix.end(), s.begin());
        -: 8709:    }
        4: 8710:    bool startsWith( std::string const& s, char prefix ) {
       4*: 8711:        return !s.empty() && s[0] == prefix;
        -: 8712:    }
    #####: 8713:    bool endsWith( std::string const& s, std::string const& suffix ) {
    #####: 8714:        return s.size() >= suffix.size() && std::equal(suffix.rbegin(), suffix.rend(), s.rbegin());
        -: 8715:    }
    #####: 8716:    bool endsWith( std::string const& s, char suffix ) {
    #####: 8717:        return !s.empty() && s[s.size()-1] == suffix;
        -: 8718:    }
    #####: 8719:    bool contains( std::string const& s, std::string const& infix ) {
    #####: 8720:        return s.find( infix ) != std::string::npos;
        -: 8721:    }
       12: 8722:    char toLowerCh(char c) {
       12: 8723:        return static_cast<char>( std::tolower( c ) );
        -: 8724:    }
        2: 8725:    void toLowerInPlace( std::string& s ) {
        2: 8726:        std::transform( s.begin(), s.end(), s.begin(), toLowerCh );
        2: 8727:    }
        2: 8728:    std::string toLower( std::string const& s ) {
        2: 8729:        std::string lc = s;
        2: 8730:        toLowerInPlace( lc );
        2: 8731:        return lc;
        -: 8732:    }
    #####: 8733:    std::string trim( std::string const& str ) {
        -: 8734:        static char const* whitespaceChars = "\n\r\t ";
    #####: 8735:        std::string::size_type start = str.find_first_not_of( whitespaceChars );
    #####: 8736:        std::string::size_type end = str.find_last_not_of( whitespaceChars );
        -: 8737:
    #####: 8738:        return start != std::string::npos ? str.substr( start, 1+end-start ) : std::string();
        -: 8739:    }
        -: 8740:
    #####: 8741:    bool replaceInPlace( std::string& str, std::string const& replaceThis, std::string const& withThis ) {
    #####: 8742:        bool replaced = false;
    #####: 8743:        std::size_t i = str.find( replaceThis );
    #####: 8744:        while( i != std::string::npos ) {
    #####: 8745:            replaced = true;
    #####: 8746:            str = str.substr( 0, i ) + withThis + str.substr( i+replaceThis.size() );
    #####: 8747:            if( i < str.size()-withThis.size() )
    #####: 8748:                i = str.find( replaceThis, i+withThis.size() );
        -: 8749:            else
    #####: 8750:                i = std::string::npos;
        -: 8751:        }
    #####: 8752:        return replaced;
        -: 8753:    }
        -: 8754:
        2: 8755:    pluralise::pluralise( std::size_t count, std::string const& label )
        -: 8756:    :   m_count( count ),
        2: 8757:        m_label( label )
        2: 8758:    {}
        -: 8759:
        2: 8760:    std::ostream& operator << ( std::ostream& os, pluralise const& pluraliser ) {
        2: 8761:        os << pluraliser.m_count << ' ' << pluraliser.m_label;
        2: 8762:        if( pluraliser.m_count != 1 )
        1: 8763:            os << 's';
        2: 8764:        return os;
        -: 8765:    }
        -: 8766:
        2: 8767:    SourceLineInfo::SourceLineInfo() : file(""), line( 0 ){}
       44: 8768:    SourceLineInfo::SourceLineInfo( char const* _file, std::size_t _line )
        -: 8769:    :   file( _file ),
       44: 8770:        line( _line )
       44: 8771:    {}
    #####: 8772:    bool SourceLineInfo::empty() const {
    #####: 8773:        return file[0] == '\0';
        -: 8774:    }
       35: 8775:    bool SourceLineInfo::operator == ( SourceLineInfo const& other ) const {
      35*: 8776:        return line == other.line && (file == other.file || std::strcmp(file, other.file) == 0);
        -: 8777:    }
    #####: 8778:    bool SourceLineInfo::operator < ( SourceLineInfo const& other ) const {
    #####: 8779:        return line < other.line || ( line == other.line && (std::strcmp(file, other.file) < 0));
        -: 8780:    }
        -: 8781:
        7: 8782:    void seedRng( IConfig const& config ) {
        7: 8783:        if( config.rngSeed() != 0 )
    #####: 8784:            std::srand( config.rngSeed() );
        7: 8785:    }
    #####: 8786:    unsigned int rngSeed() {
    #####: 8787:        return getCurrentContext().getConfig()->rngSeed();
        -: 8788:    }
        -: 8789:
    #####: 8790:    std::ostream& operator << ( std::ostream& os, SourceLineInfo const& info ) {
        -: 8791:#ifndef __GNUG__
        -: 8792:        os << info.file << '(' << info.line << ')';
        -: 8793:#else
    #####: 8794:        os << info.file << ':' << info.line;
        -: 8795:#endif
    #####: 8796:        return os;
        -: 8797:    }
        -: 8798:
    #####: 8799:    void throwLogicError( std::string const& message, SourceLineInfo const& locationInfo ) {
    #####: 8800:        std::ostringstream oss;
    #####: 8801:        oss << locationInfo << ": Internal Catch error: '" << message << '\'';
    #####: 8802:        if( alwaysTrue() )
    #####: 8803:            throw std::logic_error( oss.str() );
    #####: 8804:    }
        -: 8805:}
        -: 8806:
        -: 8807:// #included from: catch_section.hpp
        -: 8808:#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED
        -: 8809:
        -: 8810:namespace Catch {
        -: 8811:
       42: 8812:    SectionInfo::SectionInfo
        -: 8813:        (   SourceLineInfo const& _lineInfo,
        -: 8814:            std::string const& _name,
       42: 8815:            std::string const& _description )
        -: 8816:    :   name( _name ),
        -: 8817:        description( _description ),
       42: 8818:        lineInfo( _lineInfo )
       42: 8819:    {}
        -: 8820:
       36: 8821:    Section::Section( SectionInfo const& info )
        -: 8822:    :   m_info( info ),
       36: 8823:        m_sectionIncluded( getResultCapture().sectionStarted( m_info, m_assertions ) )
        -: 8824:    {
       36: 8825:        m_timer.start();
       36: 8826:    }
        -: 8827:
        -: 8828:#if defined(_MSC_VER)
        -: 8829:#pragma warning(push)
        -: 8830:#pragma warning(disable:4996) // std::uncaught_exception is deprecated in C++17
        -: 8831:#endif
      36*: 8832:    Section::~Section() {
       36: 8833:        if( m_sectionIncluded ) {
       12: 8834:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
        6: 8835:            if( std::uncaught_exception() )
    #####: 8836:                getResultCapture().sectionEndedEarly( endInfo );
        -: 8837:            else
        6: 8838:                getResultCapture().sectionEnded( endInfo );
        -: 8839:        }
      36*: 8840:    }
------------------
_ZN5Catch7SectionD0Ev:
    #####: 8832:    Section::~Section() {
        -: 8833:        if( m_sectionIncluded ) {
        -: 8834:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
        -: 8835:            if( std::uncaught_exception() )
        -: 8836:                getResultCapture().sectionEndedEarly( endInfo );
        -: 8837:            else
        -: 8838:                getResultCapture().sectionEnded( endInfo );
        -: 8839:        }
    #####: 8840:    }
------------------
_ZN5Catch7SectionD2Ev:
       36: 8832:    Section::~Section() {
       36: 8833:        if( m_sectionIncluded ) {
       12: 8834:            SectionEndInfo endInfo( m_info, m_assertions, m_timer.getElapsedSeconds() );
        6: 8835:            if( std::uncaught_exception() )
    #####: 8836:                getResultCapture().sectionEndedEarly( endInfo );
        -: 8837:            else
        6: 8838:                getResultCapture().sectionEnded( endInfo );
        -: 8839:        }
       36: 8840:    }
------------------
        -: 8841:#if defined(_MSC_VER)
        -: 8842:#pragma warning(pop)
        -: 8843:#endif
        -: 8844:
        -: 8845:    // This indicates whether the section should be executed or not
       36: 8846:    Section::operator bool() const {
       36: 8847:        return m_sectionIncluded;
        -: 8848:    }
        -: 8849:
        -: 8850:} // end namespace Catch
        -: 8851:
        -: 8852:// #included from: catch_debugger.hpp
        -: 8853:#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED
        -: 8854:
        -: 8855:#ifdef CATCH_PLATFORM_MAC
        -: 8856:
        -: 8857:    #include <assert.h>
        -: 8858:    #include <stdbool.h>
        -: 8859:    #include <sys/types.h>
        -: 8860:    #include <unistd.h>
        -: 8861:    #include <sys/sysctl.h>
        -: 8862:
        -: 8863:    namespace Catch{
        -: 8864:
        -: 8865:        // The following function is taken directly from the following technical note:
        -: 8866:        // http://developer.apple.com/library/mac/#qa/qa2004/qa1361.html
        -: 8867:
        -: 8868:        // Returns true if the current process is being debugged (either
        -: 8869:        // running under the debugger or has a debugger attached post facto).
        -: 8870:        bool isDebuggerActive(){
        -: 8871:
        -: 8872:            int                 mib[4];
        -: 8873:            struct kinfo_proc   info;
        -: 8874:            size_t              size;
        -: 8875:
        -: 8876:            // Initialize the flags so that, if sysctl fails for some bizarre
        -: 8877:            // reason, we get a predictable result.
        -: 8878:
        -: 8879:            info.kp_proc.p_flag = 0;
        -: 8880:
        -: 8881:            // Initialize mib, which tells sysctl the info we want, in this case
        -: 8882:            // we're looking for information about a specific process ID.
        -: 8883:
        -: 8884:            mib[0] = CTL_KERN;
        -: 8885:            mib[1] = KERN_PROC;
        -: 8886:            mib[2] = KERN_PROC_PID;
        -: 8887:            mib[3] = getpid();
        -: 8888:
        -: 8889:            // Call sysctl.
        -: 8890:
        -: 8891:            size = sizeof(info);
        -: 8892:            if( sysctl(mib, sizeof(mib) / sizeof(*mib), &info, &size, CATCH_NULL, 0) != 0 ) {
        -: 8893:                Catch::cerr() << "\n** Call to sysctl failed - unable to determine if debugger is active **\n" << std::endl;
        -: 8894:                return false;
        -: 8895:            }
        -: 8896:
        -: 8897:            // We're being debugged if the P_TRACED flag is set.
        -: 8898:
        -: 8899:            return ( (info.kp_proc.p_flag & P_TRACED) != 0 );
        -: 8900:        }
        -: 8901:    } // namespace Catch
        -: 8902:
        -: 8903:#elif defined(CATCH_PLATFORM_LINUX)
        -: 8904:    #include <fstream>
        -: 8905:    #include <string>
        -: 8906:
        -: 8907:    namespace Catch{
        -: 8908:        // The standard POSIX way of detecting a debugger is to attempt to
        -: 8909:        // ptrace() the process, but this needs to be done from a child and not
        -: 8910:        // this process itself to still allow attaching to this process later
        -: 8911:        // if wanted, so is rather heavy. Under Linux we have the PID of the
        -: 8912:        // "debugger" (which doesn't need to be gdb, of course, it could also
        -: 8913:        // be strace, for example) in /proc/$PID/status, so just get it from
        -: 8914:        // there instead.
        1: 8915:        bool isDebuggerActive(){
        -: 8916:            // Libstdc++ has a bug, where std::ifstream sets errno to 0
        -: 8917:            // This way our users can properly assert over errno values
        2: 8918:            ErrnoGuard guard;
        2: 8919:            std::ifstream in("/proc/self/status");
        8: 8920:            for( std::string line; std::getline(in, line); ) {
        -: 8921:                static const int PREFIX_LEN = 11;
        8: 8922:                if( line.compare(0, PREFIX_LEN, "TracerPid:\t") == 0 ) {
        -: 8923:                    // We're traced if the PID is not 0 and no other PID starts
        -: 8924:                    // with 0 digit, so it's enough to check for just a single
        -: 8925:                    // character.
       1*: 8926:                    return line.length() > PREFIX_LEN && line[PREFIX_LEN] != '0';
        -: 8927:                }
        -: 8928:            }
        -: 8929:
    #####: 8930:            return false;
        -: 8931:        }
        -: 8932:    } // namespace Catch
        -: 8933:#elif defined(_MSC_VER)
        -: 8934:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 8935:    namespace Catch {
        -: 8936:        bool isDebuggerActive() {
        -: 8937:            return IsDebuggerPresent() != 0;
        -: 8938:        }
        -: 8939:    }
        -: 8940:#elif defined(__MINGW32__)
        -: 8941:    extern "C" __declspec(dllimport) int __stdcall IsDebuggerPresent();
        -: 8942:    namespace Catch {
        -: 8943:        bool isDebuggerActive() {
        -: 8944:            return IsDebuggerPresent() != 0;
        -: 8945:        }
        -: 8946:    }
        -: 8947:#else
        -: 8948:    namespace Catch {
        -: 8949:       inline bool isDebuggerActive() { return false; }
        -: 8950:    }
        -: 8951:#endif // Platform
        -: 8952:
        -: 8953:#ifdef CATCH_PLATFORM_WINDOWS
        -: 8954:
        -: 8955:    namespace Catch {
        -: 8956:        void writeToDebugConsole( std::string const& text ) {
        -: 8957:            ::OutputDebugStringA( text.c_str() );
        -: 8958:        }
        -: 8959:    }
        -: 8960:#else
        -: 8961:    namespace Catch {
    #####: 8962:        void writeToDebugConsole( std::string const& text ) {
        -: 8963:            // !TBD: Need a version for Mac/ XCode and other IDEs
    #####: 8964:            Catch::cout() << text;
    #####: 8965:        }
        -: 8966:    }
        -: 8967:#endif // Platform
        -: 8968:
        -: 8969:// #included from: catch_tostring.hpp
        -: 8970:#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED
        -: 8971:
        -: 8972:namespace Catch {
        -: 8973:
        -: 8974:namespace Detail {
        -: 8975:
        -: 8976:    const std::string unprintableString = "{?}";
        -: 8977:
        -: 8978:    namespace {
        -: 8979:        const int hexThreshold = 255;
        -: 8980:
        -: 8981:        struct Endianness {
        -: 8982:            enum Arch { Big, Little };
        -: 8983:
    #####: 8984:            static Arch which() {
        -: 8985:                union _{
        -: 8986:                    int asInt;
        -: 8987:                    char asChar[sizeof (int)];
        -: 8988:                } u;
        -: 8989:
    #####: 8990:                u.asInt = 1;
    #####: 8991:                return ( u.asChar[sizeof(int)-1] == 1 ) ? Big : Little;
        -: 8992:            }
        -: 8993:        };
        -: 8994:    }
        -: 8995:
    #####: 8996:    std::string rawMemoryToString( const void *object, std::size_t size )
        -: 8997:    {
        -: 8998:        // Reverse order for little endian architectures
    #####: 8999:        int i = 0, end = static_cast<int>( size ), inc = 1;
    #####: 9000:        if( Endianness::which() == Endianness::Little ) {
    #####: 9001:            i = end-1;
    #####: 9002:            end = inc = -1;
        -: 9003:        }
        -: 9004:
    #####: 9005:        unsigned char const *bytes = static_cast<unsigned char const *>(object);
    #####: 9006:        std::ostringstream os;
    #####: 9007:        os << "0x" << std::setfill('0') << std::hex;
    #####: 9008:        for( ; i != end; i += inc )
    #####: 9009:             os << std::setw(2) << static_cast<unsigned>(bytes[i]);
    #####: 9010:       return os.str();
        -: 9011:    }
        -: 9012:}
        -: 9013:
    #####: 9014:std::string toString( std::string const& value ) {
    #####: 9015:    std::string s = value;
    #####: 9016:    if( getCurrentContext().getConfig()->showInvisibles() ) {
    #####: 9017:        for(size_t i = 0; i < s.size(); ++i ) {
    #####: 9018:            std::string subs;
    #####: 9019:            switch( s[i] ) {
    #####: 9020:            case '\n': subs = "\\n"; break;
    #####: 9021:            case '\t': subs = "\\t"; break;
    #####: 9022:            default: break;
        -: 9023:            }
    #####: 9024:            if( !subs.empty() ) {
    #####: 9025:                s = s.substr( 0, i ) + subs + s.substr( i+1 );
    #####: 9026:                ++i;
        -: 9027:            }
        -: 9028:        }
        -: 9029:    }
    #####: 9030:    return '"' + s + '"';
        -: 9031:}
    #####: 9032:std::string toString( std::wstring const& value ) {
        -: 9033:
    #####: 9034:    std::string s;
    #####: 9035:    s.reserve( value.size() );
    #####: 9036:    for(size_t i = 0; i < value.size(); ++i )
    #####: 9037:        s += value[i] <= 0xff ? static_cast<char>( value[i] ) : '?';
    #####: 9038:    return Catch::toString( s );
        -: 9039:}
        -: 9040:
    #####: 9041:std::string toString( const char* const value ) {
    #####: 9042:    return value ? Catch::toString( std::string( value ) ) : std::string( "{null string}" );
        -: 9043:}
        -: 9044:
    #####: 9045:std::string toString( char* const value ) {
    #####: 9046:    return Catch::toString( static_cast<const char*>( value ) );
        -: 9047:}
        -: 9048:
    #####: 9049:std::string toString( const wchar_t* const value )
        -: 9050:{
    #####: 9051:    return value ? Catch::toString( std::wstring(value) ) : std::string( "{null string}" );
        -: 9052:}
        -: 9053:
    #####: 9054:std::string toString( wchar_t* const value )
        -: 9055:{
    #####: 9056:    return Catch::toString( static_cast<const wchar_t*>( value ) );
        -: 9057:}
        -: 9058:
    #####: 9059:std::string toString( int value ) {
    #####: 9060:    std::ostringstream oss;
    #####: 9061:    oss << value;
    #####: 9062:    if( value > Detail::hexThreshold )
    #####: 9063:        oss << " (0x" << std::hex << value << ')';
    #####: 9064:    return oss.str();
        -: 9065:}
        -: 9066:
    #####: 9067:std::string toString( unsigned long value ) {
    #####: 9068:    std::ostringstream oss;
    #####: 9069:    oss << value;
    #####: 9070:    if( value > Detail::hexThreshold )
    #####: 9071:        oss << " (0x" << std::hex << value << ')';
    #####: 9072:    return oss.str();
        -: 9073:}
        -: 9074:
    #####: 9075:std::string toString( unsigned int value ) {
    #####: 9076:    return Catch::toString( static_cast<unsigned long>( value ) );
        -: 9077:}
        -: 9078:
        -: 9079:template<typename T>
    #####: 9080:std::string fpToString( T value, int precision ) {
    #####: 9081:    std::ostringstream oss;
    #####: 9082:    oss << std::setprecision( precision )
    #####: 9083:        << std::fixed
    #####: 9084:        << value;
    #####: 9085:    std::string d = oss.str();
    #####: 9086:    std::size_t i = d.find_last_not_of( '0' );
    #####: 9087:    if( i != std::string::npos && i != d.size()-1 ) {
    #####: 9088:        if( d[i] == '.' )
    #####: 9089:            i++;
    #####: 9090:        d = d.substr( 0, i+1 );
        -: 9091:    }
    #####: 9092:    return d;
        -: 9093:}
------------------
_ZN5Catch10fpToStringIfEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEET_i:
    #####: 9080:std::string fpToString( T value, int precision ) {
    #####: 9081:    std::ostringstream oss;
    #####: 9082:    oss << std::setprecision( precision )
    #####: 9083:        << std::fixed
    #####: 9084:        << value;
    #####: 9085:    std::string d = oss.str();
    #####: 9086:    std::size_t i = d.find_last_not_of( '0' );
    #####: 9087:    if( i != std::string::npos && i != d.size()-1 ) {
    #####: 9088:        if( d[i] == '.' )
    #####: 9089:            i++;
    #####: 9090:        d = d.substr( 0, i+1 );
        -: 9091:    }
    #####: 9092:    return d;
        -: 9093:}
------------------
_ZN5Catch10fpToStringIdEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEET_i:
    #####: 9080:std::string fpToString( T value, int precision ) {
    #####: 9081:    std::ostringstream oss;
    #####: 9082:    oss << std::setprecision( precision )
    #####: 9083:        << std::fixed
    #####: 9084:        << value;
    #####: 9085:    std::string d = oss.str();
    #####: 9086:    std::size_t i = d.find_last_not_of( '0' );
    #####: 9087:    if( i != std::string::npos && i != d.size()-1 ) {
    #####: 9088:        if( d[i] == '.' )
    #####: 9089:            i++;
    #####: 9090:        d = d.substr( 0, i+1 );
        -: 9091:    }
    #####: 9092:    return d;
        -: 9093:}
------------------
        -: 9094:
    #####: 9095:std::string toString( const double value ) {
    #####: 9096:    return fpToString( value, 10 );
        -: 9097:}
    #####: 9098:std::string toString( const float value ) {
    #####: 9099:    return fpToString( value, 5 ) + 'f';
        -: 9100:}
        -: 9101:
    #####: 9102:std::string toString( bool value ) {
    #####: 9103:    return value ? "true" : "false";
        -: 9104:}
        -: 9105:
    #####: 9106:std::string toString( char value ) {
    #####: 9107:    if ( value == '\r' )
    #####: 9108:        return "'\\r'";
    #####: 9109:    if ( value == '\f' )
    #####: 9110:        return "'\\f'";
    #####: 9111:    if ( value == '\n' )
    #####: 9112:        return "'\\n'";
    #####: 9113:    if ( value == '\t' )
    #####: 9114:        return "'\\t'";
    #####: 9115:    if ( '\0' <= value && value < ' ' )
    #####: 9116:        return toString( static_cast<unsigned int>( value ) );
    #####: 9117:    char chstr[] = "' '";
    #####: 9118:    chstr[1] = value;
    #####: 9119:    return chstr;
        -: 9120:}
        -: 9121:
    #####: 9122:std::string toString( signed char value ) {
    #####: 9123:    return toString( static_cast<char>( value ) );
        -: 9124:}
        -: 9125:
    #####: 9126:std::string toString( unsigned char value ) {
    #####: 9127:    return toString( static_cast<char>( value ) );
        -: 9128:}
        -: 9129:
        -: 9130:#ifdef CATCH_CONFIG_CPP11_LONG_LONG
    #####: 9131:std::string toString( long long value ) {
    #####: 9132:    std::ostringstream oss;
    #####: 9133:    oss << value;
    #####: 9134:    if( value > Detail::hexThreshold )
    #####: 9135:        oss << " (0x" << std::hex << value << ')';
    #####: 9136:    return oss.str();
        -: 9137:}
    #####: 9138:std::string toString( unsigned long long value ) {
    #####: 9139:    std::ostringstream oss;
    #####: 9140:    oss << value;
    #####: 9141:    if( value > Detail::hexThreshold )
    #####: 9142:        oss << " (0x" << std::hex << value << ')';
    #####: 9143:    return oss.str();
        -: 9144:}
        -: 9145:#endif
        -: 9146:
        -: 9147:#ifdef CATCH_CONFIG_CPP11_NULLPTR
    #####: 9148:std::string toString( std::nullptr_t ) {
    #####: 9149:    return "nullptr";
        -: 9150:}
        -: 9151:#endif
        -: 9152:
        -: 9153:#ifdef __OBJC__
        -: 9154:    std::string toString( NSString const * const& nsstring ) {
        -: 9155:        if( !nsstring )
        -: 9156:            return "nil";
        -: 9157:        return "@" + toString([nsstring UTF8String]);
        -: 9158:    }
        -: 9159:    std::string toString( NSString * CATCH_ARC_STRONG & nsstring ) {
        -: 9160:        if( !nsstring )
        -: 9161:            return "nil";
        -: 9162:        return "@" + toString([nsstring UTF8String]);
        -: 9163:    }
        -: 9164:    std::string toString( NSObject* const& nsObject ) {
        -: 9165:        return toString( [nsObject description] );
        -: 9166:    }
        -: 9167:#endif
        -: 9168:
        -: 9169:} // end namespace Catch
        -: 9170:
        -: 9171:// #included from: catch_result_builder.hpp
        -: 9172:#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED
        -: 9173:
        -: 9174:namespace Catch {
        -: 9175:
        6: 9176:    ResultBuilder::ResultBuilder(   char const* macroName,
        -: 9177:                                    SourceLineInfo const& lineInfo,
        -: 9178:                                    char const* capturedExpression,
        -: 9179:                                    ResultDisposition::Flags resultDisposition,
        6: 9180:                                    char const* secondArg )
        -: 9181:    :   m_assertionInfo( macroName, lineInfo, capturedExpression, resultDisposition, secondArg ),
        -: 9182:        m_shouldDebugBreak( false ),
        -: 9183:        m_shouldThrow( false ),
        -: 9184:        m_guardException( false ),
        6: 9185:        m_usedStream( false )
        6: 9186:    {}
        -: 9187:
       6*: 9188:    ResultBuilder::~ResultBuilder() {
        -: 9189:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -: 9190:        if ( m_guardException ) {
        -: 9191:            stream().oss << "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
        -: 9192:            captureResult( ResultWas::ThrewException );
        -: 9193:            getCurrentContext().getResultCapture()->exceptionEarlyReported();
        -: 9194:        }
        -: 9195:#endif
       6*: 9196:    }
------------------
_ZN5Catch13ResultBuilderD0Ev:
    #####: 9188:    ResultBuilder::~ResultBuilder() {
        -: 9189:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -: 9190:        if ( m_guardException ) {
        -: 9191:            stream().oss << "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
        -: 9192:            captureResult( ResultWas::ThrewException );
        -: 9193:            getCurrentContext().getResultCapture()->exceptionEarlyReported();
        -: 9194:        }
        -: 9195:#endif
    #####: 9196:    }
------------------
_ZN5Catch13ResultBuilderD2Ev:
        6: 9188:    ResultBuilder::~ResultBuilder() {
        -: 9189:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -: 9190:        if ( m_guardException ) {
        -: 9191:            stream().oss << "Exception translation was disabled by CATCH_CONFIG_FAST_COMPILE";
        -: 9192:            captureResult( ResultWas::ThrewException );
        -: 9193:            getCurrentContext().getResultCapture()->exceptionEarlyReported();
        -: 9194:        }
        -: 9195:#endif
        6: 9196:    }
------------------
        -: 9197:
    #####: 9198:    ResultBuilder& ResultBuilder::setResultType( ResultWas::OfType result ) {
    #####: 9199:        m_data.resultType = result;
    #####: 9200:        return *this;
        -: 9201:    }
        6: 9202:    ResultBuilder& ResultBuilder::setResultType( bool result ) {
       6*: 9203:        m_data.resultType = result ? ResultWas::Ok : ResultWas::ExpressionFailed;
        6: 9204:        return *this;
        -: 9205:    }
        -: 9206:
        6: 9207:    void ResultBuilder::endExpression( DecomposedExpression const& expr ) {
        -: 9208:        // Flip bool results if FalseTest flag is set
        6: 9209:        if( isFalseTest( m_assertionInfo.resultDisposition ) ) {
    #####: 9210:            m_data.negate( expr.isBinaryExpression() );
        -: 9211:        }
        -: 9212:
        6: 9213:        getResultCapture().assertionRun();
        -: 9214:
       6*: 9215:        if(getCurrentContext().getConfig()->includeSuccessfulResults() || m_data.resultType != ResultWas::Ok)
        -: 9216:        {
    #####: 9217:            AssertionResult result = build( expr );
    #####: 9218:            handleResult( result );
        -: 9219:        }
        -: 9220:        else
        6: 9221:            getResultCapture().assertionPassed();
        6: 9222:    }
        -: 9223:
    #####: 9224:    void ResultBuilder::useActiveException( ResultDisposition::Flags resultDisposition ) {
    #####: 9225:        m_assertionInfo.resultDisposition = resultDisposition;
    #####: 9226:        stream().oss << Catch::translateActiveException();
    #####: 9227:        captureResult( ResultWas::ThrewException );
    #####: 9228:    }
        -: 9229:
    #####: 9230:    void ResultBuilder::captureResult( ResultWas::OfType resultType ) {
    #####: 9231:        setResultType( resultType );
    #####: 9232:        captureExpression();
    #####: 9233:    }
        -: 9234:
    #####: 9235:    void ResultBuilder::captureExpectedException( std::string const& expectedMessage ) {
    #####: 9236:        if( expectedMessage.empty() )
    #####: 9237:            captureExpectedException( Matchers::Impl::MatchAllOf<std::string>() );
        -: 9238:        else
    #####: 9239:            captureExpectedException( Matchers::Equals( expectedMessage ) );
    #####: 9240:    }
        -: 9241:
    #####: 9242:    void ResultBuilder::captureExpectedException( Matchers::Impl::MatcherBase<std::string> const& matcher ) {
        -: 9243:
    #####: 9244:        assert( !isFalseTest( m_assertionInfo.resultDisposition ) );
    #####: 9245:        AssertionResultData data = m_data;
    #####: 9246:        data.resultType = ResultWas::Ok;
    #####: 9247:        data.reconstructedExpression = capturedExpressionWithSecondArgument(m_assertionInfo.capturedExpression, m_assertionInfo.secondArg);
        -: 9248:
    #####: 9249:        std::string actualMessage = Catch::translateActiveException();
    #####: 9250:        if( !matcher.match( actualMessage ) ) {
    #####: 9251:            data.resultType = ResultWas::ExpressionFailed;
    #####: 9252:            data.reconstructedExpression = actualMessage;
        -: 9253:        }
    #####: 9254:        AssertionResult result( m_assertionInfo, data );
    #####: 9255:        handleResult( result );
    #####: 9256:    }
        -: 9257:
    #####: 9258:    void ResultBuilder::captureExpression() {
    #####: 9259:        AssertionResult result = build();
    #####: 9260:        handleResult( result );
    #####: 9261:    }
        -: 9262:
    #####: 9263:    void ResultBuilder::handleResult( AssertionResult const& result )
        -: 9264:    {
    #####: 9265:        getResultCapture().assertionEnded( result );
        -: 9266:
    #####: 9267:        if( !result.isOk() ) {
    #####: 9268:            if( getCurrentContext().getConfig()->shouldDebugBreak() )
    #####: 9269:                m_shouldDebugBreak = true;
    #####: 9270:            if( getCurrentContext().getRunner()->aborting() || (m_assertionInfo.resultDisposition & ResultDisposition::Normal) )
    #####: 9271:                m_shouldThrow = true;
        -: 9272:        }
    #####: 9273:    }
        -: 9274:
        6: 9275:    void ResultBuilder::react() {
        -: 9276:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -: 9277:        if (m_shouldDebugBreak) {
        -: 9278:            ///////////////////////////////////////////////////////////////////
        -: 9279:            // To inspect the state during test, you need to go one level up the callstack
        -: 9280:            // To go back to the test and change execution, jump over the throw statement
        -: 9281:            ///////////////////////////////////////////////////////////////////
        -: 9282:            CATCH_BREAK_INTO_DEBUGGER();
        -: 9283:        }
        -: 9284:#endif
        6: 9285:        if( m_shouldThrow )
    #####: 9286:            throw Catch::TestFailureException();
        6: 9287:    }
        -: 9288:
        6: 9289:    bool ResultBuilder::shouldDebugBreak() const { return m_shouldDebugBreak; }
    #####: 9290:    bool ResultBuilder::allowThrows() const { return getCurrentContext().getConfig()->allowThrows(); }
        -: 9291:
    #####: 9292:    AssertionResult ResultBuilder::build() const
        -: 9293:    {
    #####: 9294:        return build( *this );
        -: 9295:    }
        -: 9296:
        -: 9297:    // CAVEAT: The returned AssertionResult stores a pointer to the argument expr,
        -: 9298:    //         a temporary DecomposedExpression, which in turn holds references to
        -: 9299:    //         operands, possibly temporary as well.
        -: 9300:    //         It should immediately be passed to handleResult; if the expression
        -: 9301:    //         needs to be reported, its string expansion must be composed before
        -: 9302:    //         the temporaries are destroyed.
    #####: 9303:    AssertionResult ResultBuilder::build( DecomposedExpression const& expr ) const
        -: 9304:    {
    #####: 9305:        assert( m_data.resultType != ResultWas::Unknown );
    #####: 9306:        AssertionResultData data = m_data;
        -: 9307:
    #####: 9308:        if(m_usedStream)
    #####: 9309:            data.message = m_stream().oss.str();
    #####: 9310:        data.decomposedExpression = &expr; // for lazy reconstruction
    #####: 9311:        return AssertionResult( m_assertionInfo, data );
        -: 9312:    }
        -: 9313:
    #####: 9314:    void ResultBuilder::reconstructExpression( std::string& dest ) const {
    #####: 9315:        dest = capturedExpressionWithSecondArgument(m_assertionInfo.capturedExpression, m_assertionInfo.secondArg);
    #####: 9316:    }
        -: 9317:
    #####: 9318:    void ResultBuilder::setExceptionGuard() {
    #####: 9319:        m_guardException = true;
    #####: 9320:    }
    #####: 9321:    void ResultBuilder::unsetExceptionGuard() {
    #####: 9322:        m_guardException = false;
    #####: 9323:    }
        -: 9324:
        -: 9325:} // end namespace Catch
        -: 9326:
        -: 9327:// #included from: catch_tag_alias_registry.hpp
        -: 9328:#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED
        -: 9329:
        -: 9330:namespace Catch {
        -: 9331:
       1*: 9332:    TagAliasRegistry::~TagAliasRegistry() {}
------------------
_ZN5Catch16TagAliasRegistryD0Ev:
    #####: 9332:    TagAliasRegistry::~TagAliasRegistry() {}
------------------
_ZN5Catch16TagAliasRegistryD2Ev:
        1: 9332:    TagAliasRegistry::~TagAliasRegistry() {}
------------------
        -: 9333:
    #####: 9334:    Option<TagAlias> TagAliasRegistry::find( std::string const& alias ) const {
    #####: 9335:        std::map<std::string, TagAlias>::const_iterator it = m_registry.find( alias );
    #####: 9336:        if( it != m_registry.end() )
    #####: 9337:            return it->second;
        -: 9338:        else
    #####: 9339:            return Option<TagAlias>();
        -: 9340:    }
        -: 9341:
        1: 9342:    std::string TagAliasRegistry::expandAliases( std::string const& unexpandedTestSpec ) const {
        1: 9343:        std::string expandedTestSpec = unexpandedTestSpec;
       1*: 9344:        for( std::map<std::string, TagAlias>::const_iterator it = m_registry.begin(), itEnd = m_registry.end();
        1: 9345:                it != itEnd;
    #####: 9346:                ++it ) {
    #####: 9347:            std::size_t pos = expandedTestSpec.find( it->first );
    #####: 9348:            if( pos != std::string::npos ) {
    #####: 9349:                expandedTestSpec =  expandedTestSpec.substr( 0, pos ) +
    #####: 9350:                                    it->second.tag +
    #####: 9351:                                    expandedTestSpec.substr( pos + it->first.size() );
        -: 9352:            }
        -: 9353:        }
        1: 9354:        return expandedTestSpec;
        -: 9355:    }
        -: 9356:
    #####: 9357:    void TagAliasRegistry::add( std::string const& alias, std::string const& tag, SourceLineInfo const& lineInfo ) {
        -: 9358:
    #####: 9359:        if( !startsWith( alias, "[@" ) || !endsWith( alias, ']' ) ) {
    #####: 9360:            std::ostringstream oss;
    #####: 9361:            oss << Colour( Colour::Red )
    #####: 9362:                << "error: tag alias, \"" << alias << "\" is not of the form [@alias name].\n"
    #####: 9363:                << Colour( Colour::FileName )
    #####: 9364:                << lineInfo << '\n';
    #####: 9365:            throw std::domain_error( oss.str().c_str() );
        -: 9366:        }
    #####: 9367:        if( !m_registry.insert( std::make_pair( alias, TagAlias( tag, lineInfo ) ) ).second ) {
    #####: 9368:            std::ostringstream oss;
    #####: 9369:            oss << Colour( Colour::Red )
        -: 9370:                << "error: tag alias, \"" << alias << "\" already registered.\n"
    #####: 9371:                << "\tFirst seen at "
    #####: 9372:                << Colour( Colour::Red ) << find(alias)->lineInfo << '\n'
    #####: 9373:                << Colour( Colour::Red ) << "\tRedefined at "
    #####: 9374:                << Colour( Colour::FileName) << lineInfo << '\n';
    #####: 9375:            throw std::domain_error( oss.str().c_str() );
        -: 9376:        }
    #####: 9377:    }
        -: 9378:
       1*: 9379:    ITagAliasRegistry::~ITagAliasRegistry() {}
------------------
_ZN5Catch17ITagAliasRegistryD0Ev:
    #####: 9379:    ITagAliasRegistry::~ITagAliasRegistry() {}
------------------
_ZN5Catch17ITagAliasRegistryD2Ev:
        1: 9379:    ITagAliasRegistry::~ITagAliasRegistry() {}
------------------
        -: 9380:
        1: 9381:    ITagAliasRegistry const& ITagAliasRegistry::get() {
        1: 9382:        return getRegistryHub().getTagAliasRegistry();
        -: 9383:    }
        -: 9384:
    #####: 9385:    RegistrarForTagAliases::RegistrarForTagAliases( char const* alias, char const* tag, SourceLineInfo const& lineInfo ) {
    #####: 9386:        getMutableRegistryHub().registerTagAlias( alias, tag, lineInfo );
    #####: 9387:    }
        -: 9388:
        -: 9389:} // end namespace Catch
        -: 9390:
        -: 9391:// #included from: catch_matchers_string.hpp
        -: 9392:
        -: 9393:namespace Catch {
        -: 9394:namespace Matchers {
        -: 9395:
        -: 9396:    namespace StdString {
        -: 9397:
    #####: 9398:        CasedString::CasedString( std::string const& str, CaseSensitive::Choice caseSensitivity )
        -: 9399:        :   m_caseSensitivity( caseSensitivity ),
    #####: 9400:            m_str( adjustString( str ) )
    #####: 9401:        {}
    #####: 9402:        std::string CasedString::adjustString( std::string const& str ) const {
    #####: 9403:            return m_caseSensitivity == CaseSensitive::No
        -: 9404:                   ? toLower( str )
    #####: 9405:                   : str;
        -: 9406:        }
    #####: 9407:        std::string CasedString::caseSensitivitySuffix() const {
    #####: 9408:            return m_caseSensitivity == CaseSensitive::No
        -: 9409:                   ? " (case insensitive)"
    #####: 9410:                   : std::string();
        -: 9411:        }
        -: 9412:
    #####: 9413:        StringMatcherBase::StringMatcherBase( std::string const& operation, CasedString const& comparator )
        -: 9414:        : m_comparator( comparator ),
    #####: 9415:          m_operation( operation ) {
    #####: 9416:        }
        -: 9417:
    #####: 9418:        std::string StringMatcherBase::describe() const {
    #####: 9419:            std::string description;
    #####: 9420:            description.reserve(5 + m_operation.size() + m_comparator.m_str.size() +
    #####: 9421:                                        m_comparator.caseSensitivitySuffix().size());
    #####: 9422:            description += m_operation;
    #####: 9423:            description += ": \"";
    #####: 9424:            description += m_comparator.m_str;
    #####: 9425:            description += "\"";
    #####: 9426:            description += m_comparator.caseSensitivitySuffix();
    #####: 9427:            return description;
        -: 9428:        }
        -: 9429:
    #####: 9430:        EqualsMatcher::EqualsMatcher( CasedString const& comparator ) : StringMatcherBase( "equals", comparator ) {}
        -: 9431:
    #####: 9432:        bool EqualsMatcher::match( std::string const& source ) const {
    #####: 9433:            return m_comparator.adjustString( source ) == m_comparator.m_str;
        -: 9434:        }
        -: 9435:
    #####: 9436:        ContainsMatcher::ContainsMatcher( CasedString const& comparator ) : StringMatcherBase( "contains", comparator ) {}
        -: 9437:
    #####: 9438:        bool ContainsMatcher::match( std::string const& source ) const {
    #####: 9439:            return contains( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 9440:        }
        -: 9441:
    #####: 9442:        StartsWithMatcher::StartsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "starts with", comparator ) {}
        -: 9443:
    #####: 9444:        bool StartsWithMatcher::match( std::string const& source ) const {
    #####: 9445:            return startsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 9446:        }
        -: 9447:
    #####: 9448:        EndsWithMatcher::EndsWithMatcher( CasedString const& comparator ) : StringMatcherBase( "ends with", comparator ) {}
        -: 9449:
    #####: 9450:        bool EndsWithMatcher::match( std::string const& source ) const {
    #####: 9451:            return endsWith( m_comparator.adjustString( source ), m_comparator.m_str );
        -: 9452:        }
        -: 9453:
        -: 9454:    } // namespace StdString
        -: 9455:
    #####: 9456:    StdString::EqualsMatcher Equals( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 9457:        return StdString::EqualsMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 9458:    }
    #####: 9459:    StdString::ContainsMatcher Contains( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 9460:        return StdString::ContainsMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 9461:    }
    #####: 9462:    StdString::EndsWithMatcher EndsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 9463:        return StdString::EndsWithMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 9464:    }
    #####: 9465:    StdString::StartsWithMatcher StartsWith( std::string const& str, CaseSensitive::Choice caseSensitivity ) {
    #####: 9466:        return StdString::StartsWithMatcher( StdString::CasedString( str, caseSensitivity) );
        -: 9467:    }
        -: 9468:
        -: 9469:} // namespace Matchers
        -: 9470:} // namespace Catch
        -: 9471:// #included from: ../reporters/catch_reporter_multi.hpp
        -: 9472:#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED
        -: 9473:
        -: 9474:namespace Catch {
        -: 9475:
        -: 9476:class MultipleReporters : public SharedImpl<IStreamingReporter> {
        -: 9477:    typedef std::vector<Ptr<IStreamingReporter> > Reporters;
        -: 9478:    Reporters m_reporters;
        -: 9479:
        -: 9480:public:
    #####: 9481:    void add( Ptr<IStreamingReporter> const& reporter ) {
    #####: 9482:        m_reporters.push_back( reporter );
    #####: 9483:    }
        -: 9484:
        -: 9485:public: // IStreamingReporter
        -: 9486:
    #####: 9487:    virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
    #####: 9488:        return m_reporters[0]->getPreferences();
        -: 9489:    }
        -: 9490:
    #####: 9491:    virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {
    #####: 9492:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9493:                it != itEnd;
    #####: 9494:                ++it )
    #####: 9495:            (*it)->noMatchingTestCases( spec );
    #####: 9496:    }
        -: 9497:
    #####: 9498:    virtual void testRunStarting( TestRunInfo const& testRunInfo ) CATCH_OVERRIDE {
    #####: 9499:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9500:                it != itEnd;
    #####: 9501:                ++it )
    #####: 9502:            (*it)->testRunStarting( testRunInfo );
    #####: 9503:    }
        -: 9504:
    #####: 9505:    virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {
    #####: 9506:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9507:                it != itEnd;
    #####: 9508:                ++it )
    #####: 9509:            (*it)->testGroupStarting( groupInfo );
    #####: 9510:    }
        -: 9511:
    #####: 9512:    virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {
    #####: 9513:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9514:                it != itEnd;
    #####: 9515:                ++it )
    #####: 9516:            (*it)->testCaseStarting( testInfo );
    #####: 9517:    }
        -: 9518:
    #####: 9519:    virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {
    #####: 9520:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9521:                it != itEnd;
    #####: 9522:                ++it )
    #####: 9523:            (*it)->sectionStarting( sectionInfo );
    #####: 9524:    }
        -: 9525:
    #####: 9526:    virtual void assertionStarting( AssertionInfo const& assertionInfo ) CATCH_OVERRIDE {
    #####: 9527:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9528:                it != itEnd;
    #####: 9529:                ++it )
    #####: 9530:            (*it)->assertionStarting( assertionInfo );
    #####: 9531:    }
        -: 9532:
        -: 9533:    // The return value indicates if the messages buffer should be cleared:
    #####: 9534:    virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####: 9535:        bool clearBuffer = false;
    #####: 9536:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9537:                it != itEnd;
    #####: 9538:                ++it )
    #####: 9539:            clearBuffer |= (*it)->assertionEnded( assertionStats );
    #####: 9540:        return clearBuffer;
        -: 9541:    }
        -: 9542:
    #####: 9543:    virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {
    #####: 9544:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9545:                it != itEnd;
    #####: 9546:                ++it )
    #####: 9547:            (*it)->sectionEnded( sectionStats );
    #####: 9548:    }
        -: 9549:
    #####: 9550:    virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####: 9551:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9552:                it != itEnd;
    #####: 9553:                ++it )
    #####: 9554:            (*it)->testCaseEnded( testCaseStats );
    #####: 9555:    }
        -: 9556:
    #####: 9557:    virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####: 9558:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9559:                it != itEnd;
    #####: 9560:                ++it )
    #####: 9561:            (*it)->testGroupEnded( testGroupStats );
    #####: 9562:    }
        -: 9563:
    #####: 9564:    virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {
    #####: 9565:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9566:                it != itEnd;
    #####: 9567:                ++it )
    #####: 9568:            (*it)->testRunEnded( testRunStats );
    #####: 9569:    }
        -: 9570:
    #####: 9571:    virtual void skipTest( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {
    #####: 9572:        for( Reporters::const_iterator it = m_reporters.begin(), itEnd = m_reporters.end();
    #####: 9573:                it != itEnd;
    #####: 9574:                ++it )
    #####: 9575:            (*it)->skipTest( testInfo );
    #####: 9576:    }
        -: 9577:
    #####: 9578:    virtual MultipleReporters* tryAsMulti() CATCH_OVERRIDE {
    #####: 9579:        return this;
        -: 9580:    }
        -: 9581:
        -: 9582:};
        -: 9583:
        1: 9584:Ptr<IStreamingReporter> addReporter( Ptr<IStreamingReporter> const& existingReporter, Ptr<IStreamingReporter> const& additionalReporter ) {
        1: 9585:    Ptr<IStreamingReporter> resultingReporter;
        -: 9586:
        1: 9587:    if( existingReporter ) {
    #####: 9588:        MultipleReporters* multi = existingReporter->tryAsMulti();
    #####: 9589:        if( !multi ) {
    #####: 9590:            multi = new MultipleReporters;
    #####: 9591:            resultingReporter = Ptr<IStreamingReporter>( multi );
    #####: 9592:            if( existingReporter )
    #####: 9593:                multi->add( existingReporter );
        -: 9594:        }
        -: 9595:        else
    #####: 9596:            resultingReporter = existingReporter;
    #####: 9597:        multi->add( additionalReporter );
        -: 9598:    }
        -: 9599:    else
        1: 9600:        resultingReporter = additionalReporter;
        -: 9601:
        1: 9602:    return resultingReporter;
        -: 9603:}
        -: 9604:
        -: 9605:} // end namespace Catch
        -: 9606:
        -: 9607:// #included from: ../reporters/catch_reporter_xml.hpp
        -: 9608:#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED
        -: 9609:
        -: 9610:// #included from: catch_reporter_bases.hpp
        -: 9611:#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED
        -: 9612:
        -: 9613:#include <cstring>
        -: 9614:#include <cfloat>
        -: 9615:#include <cstdio>
        -: 9616:#include <assert.h>
        -: 9617:
        -: 9618:namespace Catch {
        -: 9619:
        -: 9620:    namespace {
        -: 9621:        // Because formatting using c++ streams is stateful, drop down to C is required
        -: 9622:        // Alternatively we could use stringstream, but its performance is... not good.
    #####: 9623:        std::string getFormattedDuration( double duration ) {
        -: 9624:            // Max exponent + 1 is required to represent the whole part
        -: 9625:            // + 1 for decimal point
        -: 9626:            // + 3 for the 3 decimal places
        -: 9627:            // + 1 for null terminator
    #####: 9628:            const size_t maxDoubleSize = DBL_MAX_10_EXP + 1 + 1 + 3 + 1;
        -: 9629:            char buffer[maxDoubleSize];
        -: 9630:
        -: 9631:            // Save previous errno, to prevent sprintf from overwriting it
    #####: 9632:            ErrnoGuard guard;
        -: 9633:#ifdef _MSC_VER
        -: 9634:            sprintf_s(buffer, "%.3f", duration);
        -: 9635:#else
    #####: 9636:            sprintf(buffer, "%.3f", duration);
        -: 9637:#endif
    #####: 9638:            return std::string(buffer);
        -: 9639:        }
        -: 9640:    }
        -: 9641:
        -: 9642:    struct StreamingReporterBase : SharedImpl<IStreamingReporter> {
        -: 9643:
        1: 9644:        StreamingReporterBase( ReporterConfig const& _config )
        1: 9645:        :   m_config( _config.fullConfig() ),
        1: 9646:            stream( _config.stream() )
        -: 9647:        {
        1: 9648:            m_reporterPrefs.shouldRedirectStdOut = false;
        1: 9649:        }
        -: 9650:
        6: 9651:        virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
        6: 9652:            return m_reporterPrefs;
        -: 9653:        }
        -: 9654:
        -: 9655:        virtual ~StreamingReporterBase() CATCH_OVERRIDE;
        -: 9656:
    #####: 9657:        virtual void noMatchingTestCases( std::string const& ) CATCH_OVERRIDE {}
        -: 9658:
        1: 9659:        virtual void testRunStarting( TestRunInfo const& _testRunInfo ) CATCH_OVERRIDE {
        1: 9660:            currentTestRunInfo = _testRunInfo;
        1: 9661:        }
        1: 9662:        virtual void testGroupStarting( GroupInfo const& _groupInfo ) CATCH_OVERRIDE {
        1: 9663:            currentGroupInfo = _groupInfo;
        1: 9664:        }
        -: 9665:
        1: 9666:        virtual void testCaseStarting( TestCaseInfo const& _testInfo ) CATCH_OVERRIDE {
        1: 9667:            currentTestCaseInfo = _testInfo;
        1: 9668:        }
       12: 9669:        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {
       12: 9670:            m_sectionStack.push_back( _sectionInfo );
       12: 9671:        }
        -: 9672:
       12: 9673:        virtual void sectionEnded( SectionStats const& /* _sectionStats */ ) CATCH_OVERRIDE {
       12: 9674:            m_sectionStack.pop_back();
       12: 9675:        }
        1: 9676:        virtual void testCaseEnded( TestCaseStats const& /* _testCaseStats */ ) CATCH_OVERRIDE {
        1: 9677:            currentTestCaseInfo.reset();
        1: 9678:        }
        1: 9679:        virtual void testGroupEnded( TestGroupStats const& /* _testGroupStats */ ) CATCH_OVERRIDE {
        1: 9680:            currentGroupInfo.reset();
        1: 9681:        }
        1: 9682:        virtual void testRunEnded( TestRunStats const& /* _testRunStats */ ) CATCH_OVERRIDE {
        1: 9683:            currentTestCaseInfo.reset();
        1: 9684:            currentGroupInfo.reset();
        1: 9685:            currentTestRunInfo.reset();
        1: 9686:        }
        -: 9687:
    #####: 9688:        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {
        -: 9689:            // Don't do anything with this by default.
        -: 9690:            // It can optionally be overridden in the derived class.
    #####: 9691:        }
        -: 9692:
        -: 9693:        Ptr<IConfig const> m_config;
        -: 9694:        std::ostream& stream;
        -: 9695:
        -: 9696:        LazyStat<TestRunInfo> currentTestRunInfo;
        -: 9697:        LazyStat<GroupInfo> currentGroupInfo;
        -: 9698:        LazyStat<TestCaseInfo> currentTestCaseInfo;
        -: 9699:
        -: 9700:        std::vector<SectionInfo> m_sectionStack;
        -: 9701:        ReporterPreferences m_reporterPrefs;
        -: 9702:    };
        -: 9703:
        -: 9704:    struct CumulativeReporterBase : SharedImpl<IStreamingReporter> {
        -: 9705:        template<typename T, typename ChildNodeT>
        -: 9706:        struct Node : SharedImpl<> {
    #####: 9707:            explicit Node( T const& _value ) : value( _value ) {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_12TestRunStatsENS1_INS_14TestGroupStatsENS1_INS_13TestCaseStatsENS0_11SectionNodeEEEEEEC2ERKS2_:
    #####: 9707:            explicit Node( T const& _value ) : value( _value ) {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_14TestGroupStatsENS1_INS_13TestCaseStatsENS0_11SectionNodeEEEEC2ERKS2_:
    #####: 9707:            explicit Node( T const& _value ) : value( _value ) {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_13TestCaseStatsENS0_11SectionNodeEEC2ERKS2_:
    #####: 9707:            explicit Node( T const& _value ) : value( _value ) {}
------------------
    #####: 9708:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_13TestCaseStatsENS0_11SectionNodeEED0Ev:
    #####: 9708:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_13TestCaseStatsENS0_11SectionNodeEED2Ev:
    #####: 9708:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_14TestGroupStatsENS1_INS_13TestCaseStatsENS0_11SectionNodeEEEED0Ev:
    #####: 9708:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_14TestGroupStatsENS1_INS_13TestCaseStatsENS0_11SectionNodeEEEED2Ev:
    #####: 9708:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_12TestRunStatsENS1_INS_14TestGroupStatsENS1_INS_13TestCaseStatsENS0_11SectionNodeEEEEEED0Ev:
    #####: 9708:            virtual ~Node() {}
------------------
_ZN5Catch22CumulativeReporterBase4NodeINS_12TestRunStatsENS1_INS_14TestGroupStatsENS1_INS_13TestCaseStatsENS0_11SectionNodeEEEEEED2Ev:
    #####: 9708:            virtual ~Node() {}
------------------
        -: 9709:
        -: 9710:            typedef std::vector<Ptr<ChildNodeT> > ChildNodes;
        -: 9711:            T value;
        -: 9712:            ChildNodes children;
        -: 9713:        };
        -: 9714:        struct SectionNode : SharedImpl<> {
    #####: 9715:            explicit SectionNode( SectionStats const& _stats ) : stats( _stats ) {}
        -: 9716:            virtual ~SectionNode();
        -: 9717:
        -: 9718:            bool operator == ( SectionNode const& other ) const {
        -: 9719:                return stats.sectionInfo.lineInfo == other.stats.sectionInfo.lineInfo;
        -: 9720:            }
        -: 9721:            bool operator == ( Ptr<SectionNode> const& other ) const {
        -: 9722:                return operator==( *other );
        -: 9723:            }
        -: 9724:
        -: 9725:            SectionStats stats;
        -: 9726:            typedef std::vector<Ptr<SectionNode> > ChildSections;
        -: 9727:            typedef std::vector<AssertionStats> Assertions;
        -: 9728:            ChildSections childSections;
        -: 9729:            Assertions assertions;
        -: 9730:            std::string stdOut;
        -: 9731:            std::string stdErr;
        -: 9732:        };
        -: 9733:
        -: 9734:        struct BySectionInfo {
    #####: 9735:            BySectionInfo( SectionInfo const& other ) : m_other( other ) {}
    #####: 9736:            BySectionInfo( BySectionInfo const& other ) : m_other( other.m_other ) {}
    #####: 9737:            bool operator() ( Ptr<SectionNode> const& node ) const {
    #####: 9738:                return ((node->stats.sectionInfo.name == m_other.name) &&
    #####: 9739:                        (node->stats.sectionInfo.lineInfo == m_other.lineInfo));
        -: 9740:            }
        -: 9741:        private:
        -: 9742:            void operator=( BySectionInfo const& );
        -: 9743:            SectionInfo const& m_other;
        -: 9744:        };
        -: 9745:
        -: 9746:        typedef Node<TestCaseStats, SectionNode> TestCaseNode;
        -: 9747:        typedef Node<TestGroupStats, TestCaseNode> TestGroupNode;
        -: 9748:        typedef Node<TestRunStats, TestGroupNode> TestRunNode;
        -: 9749:
    #####: 9750:        CumulativeReporterBase( ReporterConfig const& _config )
    #####: 9751:        :   m_config( _config.fullConfig() ),
    #####: 9752:            stream( _config.stream() )
        -: 9753:        {
    #####: 9754:            m_reporterPrefs.shouldRedirectStdOut = false;
    #####: 9755:        }
        -: 9756:        ~CumulativeReporterBase();
        -: 9757:
    #####: 9758:        virtual ReporterPreferences getPreferences() const CATCH_OVERRIDE {
    #####: 9759:            return m_reporterPrefs;
        -: 9760:        }
        -: 9761:
    #####: 9762:        virtual void testRunStarting( TestRunInfo const& ) CATCH_OVERRIDE {}
    #####: 9763:        virtual void testGroupStarting( GroupInfo const& ) CATCH_OVERRIDE {}
        -: 9764:
    #####: 9765:        virtual void testCaseStarting( TestCaseInfo const& ) CATCH_OVERRIDE {}
        -: 9766:
    #####: 9767:        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {
    #####: 9768:            SectionStats incompleteStats( sectionInfo, Counts(), 0, false );
    #####: 9769:            Ptr<SectionNode> node;
    #####: 9770:            if( m_sectionStack.empty() ) {
    #####: 9771:                if( !m_rootSection )
    #####: 9772:                    m_rootSection = new SectionNode( incompleteStats );
    #####: 9773:                node = m_rootSection;
        -: 9774:            }
        -: 9775:            else {
    #####: 9776:                SectionNode& parentNode = *m_sectionStack.back();
        -: 9777:                SectionNode::ChildSections::const_iterator it =
    #####: 9778:                    std::find_if(   parentNode.childSections.begin(),
        -: 9779:                                    parentNode.childSections.end(),
    #####: 9780:                                    BySectionInfo( sectionInfo ) );
    #####: 9781:                if( it == parentNode.childSections.end() ) {
    #####: 9782:                    node = new SectionNode( incompleteStats );
    #####: 9783:                    parentNode.childSections.push_back( node );
        -: 9784:                }
        -: 9785:                else
    #####: 9786:                    node = *it;
        -: 9787:            }
    #####: 9788:            m_sectionStack.push_back( node );
    #####: 9789:            m_deepestSection = node;
    #####: 9790:        }
        -: 9791:
    #####: 9792:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}
        -: 9793:
    #####: 9794:        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####: 9795:            assert( !m_sectionStack.empty() );
    #####: 9796:            SectionNode& sectionNode = *m_sectionStack.back();
    #####: 9797:            sectionNode.assertions.push_back( assertionStats );
        -: 9798:            // AssertionResult holds a pointer to a temporary DecomposedExpression,
        -: 9799:            // which getExpandedExpression() calls to build the expression string.
        -: 9800:            // Our section stack copy of the assertionResult will likely outlive the
        -: 9801:            // temporary, so it must be expanded or discarded now to avoid calling
        -: 9802:            // a destroyed object later.
    #####: 9803:            prepareExpandedExpression( sectionNode.assertions.back().assertionResult );
    #####: 9804:            return true;
        -: 9805:        }
    #####: 9806:        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {
    #####: 9807:            assert( !m_sectionStack.empty() );
    #####: 9808:            SectionNode& node = *m_sectionStack.back();
    #####: 9809:            node.stats = sectionStats;
    #####: 9810:            m_sectionStack.pop_back();
    #####: 9811:        }
    #####: 9812:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####: 9813:            Ptr<TestCaseNode> node = new TestCaseNode( testCaseStats );
    #####: 9814:            assert( m_sectionStack.size() == 0 );
    #####: 9815:            node->children.push_back( m_rootSection );
    #####: 9816:            m_testCases.push_back( node );
    #####: 9817:            m_rootSection.reset();
        -: 9818:
    #####: 9819:            assert( m_deepestSection );
    #####: 9820:            m_deepestSection->stdOut = testCaseStats.stdOut;
    #####: 9821:            m_deepestSection->stdErr = testCaseStats.stdErr;
    #####: 9822:        }
    #####: 9823:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####: 9824:            Ptr<TestGroupNode> node = new TestGroupNode( testGroupStats );
    #####: 9825:            node->children.swap( m_testCases );
    #####: 9826:            m_testGroups.push_back( node );
    #####: 9827:        }
    #####: 9828:        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {
    #####: 9829:            Ptr<TestRunNode> node = new TestRunNode( testRunStats );
    #####: 9830:            node->children.swap( m_testGroups );
    #####: 9831:            m_testRuns.push_back( node );
    #####: 9832:            testRunEndedCumulative();
    #####: 9833:        }
        -: 9834:        virtual void testRunEndedCumulative() = 0;
        -: 9835:
    #####: 9836:        virtual void skipTest( TestCaseInfo const& ) CATCH_OVERRIDE {}
        -: 9837:
    #####: 9838:        virtual void prepareExpandedExpression( AssertionResult& result ) const {
    #####: 9839:            if( result.isOk() )
    #####: 9840:                result.discardDecomposedExpression();
        -: 9841:            else
    #####: 9842:                result.expandDecomposedExpression();
    #####: 9843:        }
        -: 9844:
        -: 9845:        Ptr<IConfig const> m_config;
        -: 9846:        std::ostream& stream;
        -: 9847:        std::vector<AssertionStats> m_assertions;
        -: 9848:        std::vector<std::vector<Ptr<SectionNode> > > m_sections;
        -: 9849:        std::vector<Ptr<TestCaseNode> > m_testCases;
        -: 9850:        std::vector<Ptr<TestGroupNode> > m_testGroups;
        -: 9851:
        -: 9852:        std::vector<Ptr<TestRunNode> > m_testRuns;
        -: 9853:
        -: 9854:        Ptr<SectionNode> m_rootSection;
        -: 9855:        Ptr<SectionNode> m_deepestSection;
        -: 9856:        std::vector<Ptr<SectionNode> > m_sectionStack;
        -: 9857:        ReporterPreferences m_reporterPrefs;
        -: 9858:
        -: 9859:    };
        -: 9860:
        -: 9861:    template<char C>
    #####: 9862:    char const* getLineOfChars() {
        -: 9863:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 9864:        if( !*line ) {
    #####: 9865:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 9866:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 9867:        }
    #####: 9868:        return line;
        -: 9869:    }
------------------
_ZN5Catch14getLineOfCharsILc46EEEPKcv:
    #####: 9862:    char const* getLineOfChars() {
        -: 9863:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 9864:        if( !*line ) {
    #####: 9865:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 9866:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 9867:        }
    #####: 9868:        return line;
        -: 9869:    }
------------------
_ZN5Catch14getLineOfCharsILc45EEEPKcv:
    #####: 9862:    char const* getLineOfChars() {
        -: 9863:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 9864:        if( !*line ) {
    #####: 9865:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 9866:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 9867:        }
    #####: 9868:        return line;
        -: 9869:    }
------------------
_ZN5Catch14getLineOfCharsILc126EEEPKcv:
    #####: 9862:    char const* getLineOfChars() {
        -: 9863:        static char line[CATCH_CONFIG_CONSOLE_WIDTH] = {0};
    #####: 9864:        if( !*line ) {
    #####: 9865:            std::memset( line, C, CATCH_CONFIG_CONSOLE_WIDTH-1 );
    #####: 9866:            line[CATCH_CONFIG_CONSOLE_WIDTH-1] = 0;
        -: 9867:        }
    #####: 9868:        return line;
        -: 9869:    }
------------------
        -: 9870:
        -: 9871:    struct TestEventListenerBase : StreamingReporterBase {
        -: 9872:        TestEventListenerBase( ReporterConfig const& _config )
        -: 9873:        :   StreamingReporterBase( _config )
        -: 9874:        {}
        -: 9875:
        -: 9876:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {}
        -: 9877:        virtual bool assertionEnded( AssertionStats const& ) CATCH_OVERRIDE {
        -: 9878:            return false;
        -: 9879:        }
        -: 9880:    };
        -: 9881:
        -: 9882:} // end namespace Catch
        -: 9883:
        -: 9884:// #included from: ../internal/catch_reporter_registrars.hpp
        -: 9885:#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED
        -: 9886:
        -: 9887:namespace Catch {
        -: 9888:
        -: 9889:    template<typename T>
        -: 9890:    class LegacyReporterRegistrar {
        -: 9891:
        -: 9892:        class ReporterFactory : public IReporterFactory {
        -: 9893:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
        -: 9894:                return new LegacyReporterAdapter( new T( config ) );
        -: 9895:            }
        -: 9896:
        -: 9897:            virtual std::string getDescription() const {
        -: 9898:                return T::getDescription();
        -: 9899:            }
        -: 9900:        };
        -: 9901:
        -: 9902:    public:
        -: 9903:
        -: 9904:        LegacyReporterRegistrar( std::string const& name ) {
        -: 9905:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        -: 9906:        }
        -: 9907:    };
        -: 9908:
        -: 9909:    template<typename T>
        -: 9910:    class ReporterRegistrar {
        -: 9911:
        -: 9912:        class ReporterFactory : public SharedImpl<IReporterFactory> {
        -: 9913:
        -: 9914:            // *** Please Note ***:
        -: 9915:            // - If you end up here looking at a compiler error because it's trying to register
        -: 9916:            // your custom reporter class be aware that the native reporter interface has changed
        -: 9917:            // to IStreamingReporter. The "legacy" interface, IReporter, is still supported via
        -: 9918:            // an adapter. Just use REGISTER_LEGACY_REPORTER to take advantage of the adapter.
        -: 9919:            // However please consider updating to the new interface as the old one is now
        -: 9920:            // deprecated and will probably be removed quite soon!
        -: 9921:            // Please contact me via github if you have any questions at all about this.
        -: 9922:            // In fact, ideally, please contact me anyway to let me know you've hit this - as I have
        -: 9923:            // no idea who is actually using custom reporters at all (possibly no-one!).
        -: 9924:            // The new interface is designed to minimise exposure to interface changes in the future.
       1*: 9925:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
       1*: 9926:                return new T( config );
        -: 9927:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_11XmlReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
    #####: 9925:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
    #####: 9926:                return new T( config );
        -: 9927:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_13JunitReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
    #####: 9925:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
    #####: 9926:                return new T( config );
        -: 9927:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15ConsoleReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
        1: 9925:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
        1: 9926:                return new T( config );
        -: 9927:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15CompactReporterEE15ReporterFactory6createERKNS_14ReporterConfigE:
    #####: 9925:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
    #####: 9926:                return new T( config );
        -: 9927:            }
------------------
        -: 9928:
    #####: 9929:            virtual std::string getDescription() const {
    #####: 9930:                return T::getDescription();
        -: 9931:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_11XmlReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 9929:            virtual std::string getDescription() const {
    #####: 9930:                return T::getDescription();
        -: 9931:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_13JunitReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 9929:            virtual std::string getDescription() const {
    #####: 9930:                return T::getDescription();
        -: 9931:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15ConsoleReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 9929:            virtual std::string getDescription() const {
    #####: 9930:                return T::getDescription();
        -: 9931:            }
------------------
_ZNK5Catch17ReporterRegistrarINS_15CompactReporterEE15ReporterFactory14getDescriptionB5cxx11Ev:
    #####: 9929:            virtual std::string getDescription() const {
    #####: 9930:                return T::getDescription();
        -: 9931:            }
------------------
        -: 9932:        };
        -: 9933:
        -: 9934:    public:
        -: 9935:
        4: 9936:        ReporterRegistrar( std::string const& name ) {
        4: 9937:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        4: 9938:        }
------------------
_ZN5Catch17ReporterRegistrarINS_15CompactReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 9936:        ReporterRegistrar( std::string const& name ) {
        1: 9937:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        1: 9938:        }
------------------
_ZN5Catch17ReporterRegistrarINS_15ConsoleReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 9936:        ReporterRegistrar( std::string const& name ) {
        1: 9937:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        1: 9938:        }
------------------
_ZN5Catch17ReporterRegistrarINS_13JunitReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 9936:        ReporterRegistrar( std::string const& name ) {
        1: 9937:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        1: 9938:        }
------------------
_ZN5Catch17ReporterRegistrarINS_11XmlReporterEEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE:
        1: 9936:        ReporterRegistrar( std::string const& name ) {
        1: 9937:            getMutableRegistryHub().registerReporter( name, new ReporterFactory() );
        1: 9938:        }
------------------
        -: 9939:    };
        -: 9940:
        -: 9941:    template<typename T>
        -: 9942:    class ListenerRegistrar {
        -: 9943:
        -: 9944:        class ListenerFactory : public SharedImpl<IReporterFactory> {
        -: 9945:
        -: 9946:            virtual IStreamingReporter* create( ReporterConfig const& config ) const {
        -: 9947:                return new T( config );
        -: 9948:            }
        -: 9949:            virtual std::string getDescription() const {
        -: 9950:                return std::string();
        -: 9951:            }
        -: 9952:        };
        -: 9953:
        -: 9954:    public:
        -: 9955:
        -: 9956:        ListenerRegistrar() {
        -: 9957:            getMutableRegistryHub().registerListener( new ListenerFactory() );
        -: 9958:        }
        -: 9959:    };
        -: 9960:}
        -: 9961:
        -: 9962:#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) \
        -: 9963:    namespace{ Catch::LegacyReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }
        -: 9964:
        -: 9965:#define INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType ) \
        -: 9966:    namespace{ Catch::ReporterRegistrar<reporterType> catch_internal_RegistrarFor##reporterType( name ); }
        -: 9967:
        -: 9968:// Deprecated - use the form without INTERNAL_
        -: 9969:#define INTERNAL_CATCH_REGISTER_LISTENER( listenerType ) \
        -: 9970:    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }
        -: 9971:
        -: 9972:#define CATCH_REGISTER_LISTENER( listenerType ) \
        -: 9973:    namespace{ Catch::ListenerRegistrar<listenerType> catch_internal_RegistrarFor##listenerType; }
        -: 9974:
        -: 9975:// #included from: ../internal/catch_xmlwriter.hpp
        -: 9976:#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED
        -: 9977:
        -: 9978:#include <sstream>
        -: 9979:#include <string>
        -: 9980:#include <vector>
        -: 9981:#include <iomanip>
        -: 9982:
        -: 9983:namespace Catch {
        -: 9984:
        -: 9985:    class XmlEncode {
        -: 9986:    public:
        -: 9987:        enum ForWhat { ForTextNodes, ForAttributes };
        -: 9988:
    #####: 9989:        XmlEncode( std::string const& str, ForWhat forWhat = ForTextNodes )
    #####: 9990:        :   m_str( str ),
    #####: 9991:            m_forWhat( forWhat )
    #####: 9992:        {}
        -: 9993:
    #####: 9994:        void encodeTo( std::ostream& os ) const {
        -: 9995:
        -: 9996:            // Apostrophe escaping not necessary if we always use " to write attributes
        -: 9997:            // (see: http://www.w3.org/TR/xml/#syntax)
        -: 9998:
    #####: 9999:            for( std::size_t i = 0; i < m_str.size(); ++ i ) {
    #####:10000:                char c = m_str[i];
    #####:10001:                switch( c ) {
    #####:10002:                    case '<':   os << "&lt;"; break;
    #####:10003:                    case '&':   os << "&amp;"; break;
        -:10004:
    #####:10005:                    case '>':
        -:10006:                        // See: http://www.w3.org/TR/xml/#syntax
    #####:10007:                        if( i > 2 && m_str[i-1] == ']' && m_str[i-2] == ']' )
    #####:10008:                            os << "&gt;";
        -:10009:                        else
    #####:10010:                            os << c;
    #####:10011:                        break;
        -:10012:
    #####:10013:                    case '\"':
    #####:10014:                        if( m_forWhat == ForAttributes )
    #####:10015:                            os << "&quot;";
        -:10016:                        else
    #####:10017:                            os << c;
    #####:10018:                        break;
        -:10019:
    #####:10020:                    default:
        -:10021:                        // Escape control chars - based on contribution by @espenalb in PR #465 and
        -:10022:                        // by @mrpi PR #588
    #####:10023:                        if ( ( c >= 0 && c < '\x09' ) || ( c > '\x0D' && c < '\x20') || c=='\x7F' ) {
        -:10024:                            // see http://stackoverflow.com/questions/404107/why-are-control-characters-illegal-in-xml-1-0
    #####:10025:                            os << "\\x" << std::uppercase << std::hex << std::setfill('0') << std::setw(2)
    #####:10026:                               << static_cast<int>( c );
        -:10027:                        }
        -:10028:                        else
    #####:10029:                            os << c;
        -:10030:                }
        -:10031:            }
    #####:10032:        }
        -:10033:
    #####:10034:        friend std::ostream& operator << ( std::ostream& os, XmlEncode const& xmlEncode ) {
    #####:10035:            xmlEncode.encodeTo( os );
    #####:10036:            return os;
        -:10037:        }
        -:10038:
        -:10039:    private:
        -:10040:        std::string m_str;
        -:10041:        ForWhat m_forWhat;
        -:10042:    };
        -:10043:
        -:10044:    class XmlWriter {
        -:10045:    public:
        -:10046:
        -:10047:        class ScopedElement {
        -:10048:        public:
    #####:10049:            ScopedElement( XmlWriter* writer )
    #####:10050:            :   m_writer( writer )
    #####:10051:            {}
        -:10052:
        -:10053:            ScopedElement( ScopedElement const& other )
        -:10054:            :   m_writer( other.m_writer ){
        -:10055:                other.m_writer = CATCH_NULL;
        -:10056:            }
        -:10057:
    #####:10058:            ~ScopedElement() {
    #####:10059:                if( m_writer )
    #####:10060:                    m_writer->endElement();
    #####:10061:            }
        -:10062:
    #####:10063:            ScopedElement& writeText( std::string const& text, bool indent = true ) {
    #####:10064:                m_writer->writeText( text, indent );
    #####:10065:                return *this;
        -:10066:            }
        -:10067:
        -:10068:            template<typename T>
    #####:10069:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10070:                m_writer->writeAttribute( name, attribute );
    #####:10071:                return *this;
        -:10072:            }
------------------
_ZN5Catch9XmlWriter13ScopedElement14writeAttributeIbEERS1_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10069:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10070:                m_writer->writeAttribute( name, attribute );
    #####:10071:                return *this;
        -:10072:            }
------------------
_ZN5Catch9XmlWriter13ScopedElement14writeAttributeIdEERS1_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10069:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10070:                m_writer->writeAttribute( name, attribute );
    #####:10071:                return *this;
        -:10072:            }
------------------
_ZN5Catch9XmlWriter13ScopedElement14writeAttributeImEERS1_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10069:            ScopedElement& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10070:                m_writer->writeAttribute( name, attribute );
    #####:10071:                return *this;
        -:10072:            }
------------------
        -:10073:
        -:10074:        private:
        -:10075:            mutable XmlWriter* m_writer;
        -:10076:        };
        -:10077:
        -:10078:        XmlWriter()
        -:10079:        :   m_tagIsOpen( false ),
        -:10080:            m_needsNewline( false ),
        -:10081:            m_os( Catch::cout() )
        -:10082:        {
        -:10083:            writeDeclaration();
        -:10084:        }
        -:10085:
    #####:10086:        XmlWriter( std::ostream& os )
    #####:10087:        :   m_tagIsOpen( false ),
        -:10088:            m_needsNewline( false ),
    #####:10089:            m_os( os )
        -:10090:        {
    #####:10091:            writeDeclaration();
    #####:10092:        }
        -:10093:
    #####:10094:        ~XmlWriter() {
    #####:10095:            while( !m_tags.empty() )
    #####:10096:                endElement();
    #####:10097:        }
        -:10098:
    #####:10099:        XmlWriter& startElement( std::string const& name ) {
    #####:10100:            ensureTagClosed();
    #####:10101:            newlineIfNecessary();
    #####:10102:            m_os << m_indent << '<' << name;
    #####:10103:            m_tags.push_back( name );
    #####:10104:            m_indent += "  ";
    #####:10105:            m_tagIsOpen = true;
    #####:10106:            return *this;
        -:10107:        }
        -:10108:
    #####:10109:        ScopedElement scopedElement( std::string const& name ) {
    #####:10110:            ScopedElement scoped( this );
    #####:10111:            startElement( name );
    #####:10112:            return scoped;
        -:10113:        }
        -:10114:
    #####:10115:        XmlWriter& endElement() {
    #####:10116:            newlineIfNecessary();
    #####:10117:            m_indent = m_indent.substr( 0, m_indent.size()-2 );
    #####:10118:            if( m_tagIsOpen ) {
    #####:10119:                m_os << "/>";
    #####:10120:                m_tagIsOpen = false;
        -:10121:            }
        -:10122:            else {
    #####:10123:                m_os << m_indent << "</" << m_tags.back() << ">";
        -:10124:            }
    #####:10125:            m_os << std::endl;
    #####:10126:            m_tags.pop_back();
    #####:10127:            return *this;
        -:10128:        }
        -:10129:
    #####:10130:        XmlWriter& writeAttribute( std::string const& name, std::string const& attribute ) {
    #####:10131:            if( !name.empty() && !attribute.empty() )
    #####:10132:                m_os << ' ' << name << "=\"" << XmlEncode( attribute, XmlEncode::ForAttributes ) << '"';
    #####:10133:            return *this;
        -:10134:        }
        -:10135:
    #####:10136:        XmlWriter& writeAttribute( std::string const& name, bool attribute ) {
    #####:10137:            m_os << ' ' << name << "=\"" << ( attribute ? "true" : "false" ) << '"';
    #####:10138:            return *this;
        -:10139:        }
        -:10140:
        -:10141:        template<typename T>
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIA5_cEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIdEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIA1_cEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIA4_cEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIjEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeImEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
_ZN5Catch9XmlWriter14writeAttributeIPKcEERS0_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
    #####:10142:        XmlWriter& writeAttribute( std::string const& name, T const& attribute ) {
    #####:10143:            std::ostringstream oss;
    #####:10144:            oss << attribute;
    #####:10145:            return writeAttribute( name, oss.str() );
        -:10146:        }
------------------
        -:10147:
    #####:10148:        XmlWriter& writeText( std::string const& text, bool indent = true ) {
    #####:10149:            if( !text.empty() ){
    #####:10150:                bool tagWasOpen = m_tagIsOpen;
    #####:10151:                ensureTagClosed();
    #####:10152:                if( tagWasOpen && indent )
    #####:10153:                    m_os << m_indent;
    #####:10154:                m_os << XmlEncode( text );
    #####:10155:                m_needsNewline = true;
        -:10156:            }
    #####:10157:            return *this;
        -:10158:        }
        -:10159:
        -:10160:        XmlWriter& writeComment( std::string const& text ) {
        -:10161:            ensureTagClosed();
        -:10162:            m_os << m_indent << "<!--" << text << "-->";
        -:10163:            m_needsNewline = true;
        -:10164:            return *this;
        -:10165:        }
        -:10166:
    #####:10167:        void writeStylesheetRef( std::string const& url ) {
    #####:10168:            m_os << "<?xml-stylesheet type=\"text/xsl\" href=\"" << url << "\"?>\n";
    #####:10169:        }
        -:10170:
        -:10171:        XmlWriter& writeBlankLine() {
        -:10172:            ensureTagClosed();
        -:10173:            m_os << '\n';
        -:10174:            return *this;
        -:10175:        }
        -:10176:
    #####:10177:        void ensureTagClosed() {
    #####:10178:            if( m_tagIsOpen ) {
    #####:10179:                m_os << ">" << std::endl;
    #####:10180:                m_tagIsOpen = false;
        -:10181:            }
    #####:10182:        }
        -:10183:
        -:10184:    private:
        -:10185:        XmlWriter( XmlWriter const& );
        -:10186:        void operator=( XmlWriter const& );
        -:10187:
    #####:10188:        void writeDeclaration() {
    #####:10189:            m_os << "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
    #####:10190:        }
        -:10191:
    #####:10192:        void newlineIfNecessary() {
    #####:10193:            if( m_needsNewline ) {
    #####:10194:                m_os << std::endl;
    #####:10195:                m_needsNewline = false;
        -:10196:            }
    #####:10197:        }
        -:10198:
        -:10199:        bool m_tagIsOpen;
        -:10200:        bool m_needsNewline;
        -:10201:        std::vector<std::string> m_tags;
        -:10202:        std::string m_indent;
        -:10203:        std::ostream& m_os;
        -:10204:    };
        -:10205:
        -:10206:}
        -:10207:
        -:10208:namespace Catch {
        -:10209:    class XmlReporter : public StreamingReporterBase {
        -:10210:    public:
    #####:10211:        XmlReporter( ReporterConfig const& _config )
    #####:10212:        :   StreamingReporterBase( _config ),
        -:10213:            m_xml(_config.stream()),
    #####:10214:            m_sectionDepth( 0 )
        -:10215:        {
    #####:10216:            m_reporterPrefs.shouldRedirectStdOut = true;
    #####:10217:        }
        -:10218:
        -:10219:        virtual ~XmlReporter() CATCH_OVERRIDE;
        -:10220:
    #####:10221:        static std::string getDescription() {
    #####:10222:            return "Reports test results as an XML document";
        -:10223:        }
        -:10224:
    #####:10225:        virtual std::string getStylesheetRef() const {
    #####:10226:            return std::string();
        -:10227:        }
        -:10228:
    #####:10229:        void writeSourceInfo( SourceLineInfo const& sourceInfo ) {
        -:10230:            m_xml
    #####:10231:                .writeAttribute( "filename", sourceInfo.file )
    #####:10232:                .writeAttribute( "line", sourceInfo.line );
    #####:10233:        }
        -:10234:
        -:10235:    public: // StreamingReporterBase
        -:10236:
    #####:10237:        virtual void noMatchingTestCases( std::string const& s ) CATCH_OVERRIDE {
    #####:10238:            StreamingReporterBase::noMatchingTestCases( s );
    #####:10239:        }
        -:10240:
    #####:10241:        virtual void testRunStarting( TestRunInfo const& testInfo ) CATCH_OVERRIDE {
    #####:10242:            StreamingReporterBase::testRunStarting( testInfo );
    #####:10243:            std::string stylesheetRef = getStylesheetRef();
    #####:10244:            if( !stylesheetRef.empty() )
    #####:10245:                m_xml.writeStylesheetRef( stylesheetRef );
    #####:10246:            m_xml.startElement( "Catch" );
    #####:10247:            if( !m_config->name().empty() )
    #####:10248:                m_xml.writeAttribute( "name", m_config->name() );
    #####:10249:        }
        -:10250:
    #####:10251:        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {
    #####:10252:            StreamingReporterBase::testGroupStarting( groupInfo );
    #####:10253:            m_xml.startElement( "Group" )
    #####:10254:                .writeAttribute( "name", groupInfo.name );
    #####:10255:        }
        -:10256:
    #####:10257:        virtual void testCaseStarting( TestCaseInfo const& testInfo ) CATCH_OVERRIDE {
    #####:10258:            StreamingReporterBase::testCaseStarting(testInfo);
    #####:10259:            m_xml.startElement( "TestCase" )
    #####:10260:                .writeAttribute( "name", trim( testInfo.name ) )
    #####:10261:                .writeAttribute( "description", testInfo.description )
    #####:10262:                .writeAttribute( "tags", testInfo.tagsAsString );
        -:10263:
    #####:10264:            writeSourceInfo( testInfo.lineInfo );
        -:10265:
    #####:10266:            if ( m_config->showDurations() == ShowDurations::Always )
    #####:10267:                m_testCaseTimer.start();
    #####:10268:            m_xml.ensureTagClosed();
    #####:10269:        }
        -:10270:
    #####:10271:        virtual void sectionStarting( SectionInfo const& sectionInfo ) CATCH_OVERRIDE {
    #####:10272:            StreamingReporterBase::sectionStarting( sectionInfo );
    #####:10273:            if( m_sectionDepth++ > 0 ) {
    #####:10274:                m_xml.startElement( "Section" )
    #####:10275:                    .writeAttribute( "name", trim( sectionInfo.name ) )
    #####:10276:                    .writeAttribute( "description", sectionInfo.description );
    #####:10277:                writeSourceInfo( sectionInfo.lineInfo );
    #####:10278:                m_xml.ensureTagClosed();
        -:10279:            }
    #####:10280:        }
        -:10281:
    #####:10282:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE { }
        -:10283:
    #####:10284:        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
        -:10285:
    #####:10286:            AssertionResult const& result = assertionStats.assertionResult;
        -:10287:
    #####:10288:            bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
        -:10289:
    #####:10290:            if( includeResults || result.getResultType() == ResultWas::Warning ) {
        -:10291:                // Print any info messages in <Info> tags.
    #####:10292:                for( std::vector<MessageInfo>::const_iterator it = assertionStats.infoMessages.begin(), itEnd = assertionStats.infoMessages.end();
    #####:10293:                     it != itEnd;
    #####:10294:                     ++it ) {
    #####:10295:                    if( it->type == ResultWas::Info && includeResults ) {
    #####:10296:                        m_xml.scopedElement( "Info" )
    #####:10297:                                .writeText( it->message );
    #####:10298:                    } else if ( it->type == ResultWas::Warning ) {
    #####:10299:                        m_xml.scopedElement( "Warning" )
    #####:10300:                                .writeText( it->message );
        -:10301:                    }
        -:10302:                }
        -:10303:            }
        -:10304:
        -:10305:            // Drop out if result was successful but we're not printing them.
    #####:10306:            if( !includeResults && result.getResultType() != ResultWas::Warning )
    #####:10307:                return true;
        -:10308:
        -:10309:            // Print the expression if there is one.
    #####:10310:            if( result.hasExpression() ) {
    #####:10311:                m_xml.startElement( "Expression" )
    #####:10312:                    .writeAttribute( "success", result.succeeded() )
    #####:10313:                    .writeAttribute( "type", result.getTestMacroName() );
        -:10314:
    #####:10315:                writeSourceInfo( result.getSourceInfo() );
        -:10316:
    #####:10317:                m_xml.scopedElement( "Original" )
    #####:10318:                    .writeText( result.getExpression() );
    #####:10319:                m_xml.scopedElement( "Expanded" )
    #####:10320:                    .writeText( result.getExpandedExpression() );
        -:10321:            }
        -:10322:
        -:10323:            // And... Print a result applicable to each result type.
    #####:10324:            switch( result.getResultType() ) {
    #####:10325:                case ResultWas::ThrewException:
    #####:10326:                    m_xml.startElement( "Exception" );
    #####:10327:                    writeSourceInfo( result.getSourceInfo() );
    #####:10328:                    m_xml.writeText( result.getMessage() );
    #####:10329:                    m_xml.endElement();
    #####:10330:                    break;
    #####:10331:                case ResultWas::FatalErrorCondition:
    #####:10332:                    m_xml.startElement( "FatalErrorCondition" );
    #####:10333:                    writeSourceInfo( result.getSourceInfo() );
    #####:10334:                    m_xml.writeText( result.getMessage() );
    #####:10335:                    m_xml.endElement();
    #####:10336:                    break;
    #####:10337:                case ResultWas::Info:
    #####:10338:                    m_xml.scopedElement( "Info" )
    #####:10339:                        .writeText( result.getMessage() );
    #####:10340:                    break;
    #####:10341:                case ResultWas::Warning:
        -:10342:                    // Warning will already have been written
    #####:10343:                    break;
    #####:10344:                case ResultWas::ExplicitFailure:
    #####:10345:                    m_xml.startElement( "Failure" );
    #####:10346:                    writeSourceInfo( result.getSourceInfo() );
    #####:10347:                    m_xml.writeText( result.getMessage() );
    #####:10348:                    m_xml.endElement();
    #####:10349:                    break;
    #####:10350:                default:
    #####:10351:                    break;
        -:10352:            }
        -:10353:
    #####:10354:            if( result.hasExpression() )
    #####:10355:                m_xml.endElement();
        -:10356:
    #####:10357:            return true;
        -:10358:        }
        -:10359:
    #####:10360:        virtual void sectionEnded( SectionStats const& sectionStats ) CATCH_OVERRIDE {
    #####:10361:            StreamingReporterBase::sectionEnded( sectionStats );
    #####:10362:            if( --m_sectionDepth > 0 ) {
    #####:10363:                XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResults" );
    #####:10364:                e.writeAttribute( "successes", sectionStats.assertions.passed );
    #####:10365:                e.writeAttribute( "failures", sectionStats.assertions.failed );
    #####:10366:                e.writeAttribute( "expectedFailures", sectionStats.assertions.failedButOk );
        -:10367:
    #####:10368:                if ( m_config->showDurations() == ShowDurations::Always )
    #####:10369:                    e.writeAttribute( "durationInSeconds", sectionStats.durationInSeconds );
        -:10370:
    #####:10371:                m_xml.endElement();
        -:10372:            }
    #####:10373:        }
        -:10374:
    #####:10375:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####:10376:            StreamingReporterBase::testCaseEnded( testCaseStats );
    #####:10377:            XmlWriter::ScopedElement e = m_xml.scopedElement( "OverallResult" );
    #####:10378:            e.writeAttribute( "success", testCaseStats.totals.assertions.allOk() );
        -:10379:
    #####:10380:            if ( m_config->showDurations() == ShowDurations::Always )
    #####:10381:                e.writeAttribute( "durationInSeconds", m_testCaseTimer.getElapsedSeconds() );
        -:10382:
    #####:10383:            if( !testCaseStats.stdOut.empty() )
    #####:10384:                m_xml.scopedElement( "StdOut" ).writeText( trim( testCaseStats.stdOut ), false );
    #####:10385:            if( !testCaseStats.stdErr.empty() )
    #####:10386:                m_xml.scopedElement( "StdErr" ).writeText( trim( testCaseStats.stdErr ), false );
        -:10387:
    #####:10388:            m_xml.endElement();
    #####:10389:        }
        -:10390:
    #####:10391:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####:10392:            StreamingReporterBase::testGroupEnded( testGroupStats );
        -:10393:            // TODO: Check testGroupStats.aborting and act accordingly.
    #####:10394:            m_xml.scopedElement( "OverallResults" )
    #####:10395:                .writeAttribute( "successes", testGroupStats.totals.assertions.passed )
    #####:10396:                .writeAttribute( "failures", testGroupStats.totals.assertions.failed )
    #####:10397:                .writeAttribute( "expectedFailures", testGroupStats.totals.assertions.failedButOk );
    #####:10398:            m_xml.endElement();
    #####:10399:        }
        -:10400:
    #####:10401:        virtual void testRunEnded( TestRunStats const& testRunStats ) CATCH_OVERRIDE {
    #####:10402:            StreamingReporterBase::testRunEnded( testRunStats );
    #####:10403:            m_xml.scopedElement( "OverallResults" )
    #####:10404:                .writeAttribute( "successes", testRunStats.totals.assertions.passed )
    #####:10405:                .writeAttribute( "failures", testRunStats.totals.assertions.failed )
    #####:10406:                .writeAttribute( "expectedFailures", testRunStats.totals.assertions.failedButOk );
    #####:10407:            m_xml.endElement();
    #####:10408:        }
        -:10409:
        -:10410:    private:
        -:10411:        Timer m_testCaseTimer;
        -:10412:        XmlWriter m_xml;
        -:10413:        int m_sectionDepth;
        -:10414:    };
        -:10415:
        -:10416:     INTERNAL_CATCH_REGISTER_REPORTER( "xml", XmlReporter )
        -:10417:
        -:10418:} // end namespace Catch
        -:10419:
        -:10420:// #included from: ../reporters/catch_reporter_junit.hpp
        -:10421:#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED
        -:10422:
        -:10423:#include <assert.h>
        -:10424:
        -:10425:namespace Catch {
        -:10426:
        -:10427:    namespace {
    #####:10428:        std::string getCurrentTimestamp() {
        -:10429:            // Beware, this is not reentrant because of backward compatibility issues
        -:10430:            // Also, UTC only, again because of backward compatibility (%z is C++11)
        -:10431:            time_t rawtime;
    #####:10432:            std::time(&rawtime);
    #####:10433:            const size_t timeStampSize = sizeof("2017-01-16T17:06:45Z");
        -:10434:
        -:10435:#ifdef _MSC_VER
        -:10436:            std::tm timeInfo = {};
        -:10437:            gmtime_s(&timeInfo, &rawtime);
        -:10438:#else
        -:10439:            std::tm* timeInfo;
    #####:10440:            timeInfo = std::gmtime(&rawtime);
        -:10441:#endif
        -:10442:
        -:10443:            char timeStamp[timeStampSize];
    #####:10444:            const char * const fmt = "%Y-%m-%dT%H:%M:%SZ";
        -:10445:
        -:10446:#ifdef _MSC_VER
        -:10447:            std::strftime(timeStamp, timeStampSize, fmt, &timeInfo);
        -:10448:#else
    #####:10449:            std::strftime(timeStamp, timeStampSize, fmt, timeInfo);
        -:10450:#endif
    #####:10451:            return std::string(timeStamp);
        -:10452:        }
        -:10453:
        -:10454:    }
        -:10455:
        -:10456:    class JunitReporter : public CumulativeReporterBase {
        -:10457:    public:
    #####:10458:        JunitReporter( ReporterConfig const& _config )
    #####:10459:        :   CumulativeReporterBase( _config ),
        -:10460:            xml( _config.stream() ),
        -:10461:            unexpectedExceptions( 0 ),
    #####:10462:            m_okToFail( false )
        -:10463:        {
    #####:10464:            m_reporterPrefs.shouldRedirectStdOut = true;
    #####:10465:        }
        -:10466:
        -:10467:        virtual ~JunitReporter() CATCH_OVERRIDE;
        -:10468:
    #####:10469:        static std::string getDescription() {
    #####:10470:            return "Reports test results in an XML format that looks like Ant's junitreport target";
        -:10471:        }
        -:10472:
    #####:10473:        virtual void noMatchingTestCases( std::string const& /*spec*/ ) CATCH_OVERRIDE {}
        -:10474:
    #####:10475:        virtual void testRunStarting( TestRunInfo const& runInfo ) CATCH_OVERRIDE {
    #####:10476:            CumulativeReporterBase::testRunStarting( runInfo );
    #####:10477:            xml.startElement( "testsuites" );
    #####:10478:        }
        -:10479:
    #####:10480:        virtual void testGroupStarting( GroupInfo const& groupInfo ) CATCH_OVERRIDE {
    #####:10481:            suiteTimer.start();
    #####:10482:            stdOutForSuite.str("");
    #####:10483:            stdErrForSuite.str("");
    #####:10484:            unexpectedExceptions = 0;
    #####:10485:            CumulativeReporterBase::testGroupStarting( groupInfo );
    #####:10486:        }
        -:10487:
    #####:10488:        virtual void testCaseStarting( TestCaseInfo const& testCaseInfo ) CATCH_OVERRIDE {
    #####:10489:            m_okToFail = testCaseInfo.okToFail();
    #####:10490:        }
    #####:10491:        virtual bool assertionEnded( AssertionStats const& assertionStats ) CATCH_OVERRIDE {
    #####:10492:            if( assertionStats.assertionResult.getResultType() == ResultWas::ThrewException && !m_okToFail )
    #####:10493:                unexpectedExceptions++;
    #####:10494:            return CumulativeReporterBase::assertionEnded( assertionStats );
        -:10495:        }
        -:10496:
    #####:10497:        virtual void testCaseEnded( TestCaseStats const& testCaseStats ) CATCH_OVERRIDE {
    #####:10498:            stdOutForSuite << testCaseStats.stdOut;
    #####:10499:            stdErrForSuite << testCaseStats.stdErr;
    #####:10500:            CumulativeReporterBase::testCaseEnded( testCaseStats );
    #####:10501:        }
        -:10502:
    #####:10503:        virtual void testGroupEnded( TestGroupStats const& testGroupStats ) CATCH_OVERRIDE {
    #####:10504:            double suiteTime = suiteTimer.getElapsedSeconds();
    #####:10505:            CumulativeReporterBase::testGroupEnded( testGroupStats );
    #####:10506:            writeGroup( *m_testGroups.back(), suiteTime );
    #####:10507:        }
        -:10508:
    #####:10509:        virtual void testRunEndedCumulative() CATCH_OVERRIDE {
    #####:10510:            xml.endElement();
    #####:10511:        }
        -:10512:
    #####:10513:        void writeGroup( TestGroupNode const& groupNode, double suiteTime ) {
    #####:10514:            XmlWriter::ScopedElement e = xml.scopedElement( "testsuite" );
    #####:10515:            TestGroupStats const& stats = groupNode.value;
    #####:10516:            xml.writeAttribute( "name", stats.groupInfo.name );
    #####:10517:            xml.writeAttribute( "errors", unexpectedExceptions );
    #####:10518:            xml.writeAttribute( "failures", stats.totals.assertions.failed-unexpectedExceptions );
    #####:10519:            xml.writeAttribute( "tests", stats.totals.assertions.total() );
    #####:10520:            xml.writeAttribute( "hostname", "tbd" ); // !TBD
    #####:10521:            if( m_config->showDurations() == ShowDurations::Never )
    #####:10522:                xml.writeAttribute( "time", "" );
        -:10523:            else
    #####:10524:                xml.writeAttribute( "time", suiteTime );
    #####:10525:            xml.writeAttribute( "timestamp", getCurrentTimestamp() );
        -:10526:
        -:10527:            // Write test cases
    #####:10528:            for( TestGroupNode::ChildNodes::const_iterator
    #####:10529:                    it = groupNode.children.begin(), itEnd = groupNode.children.end();
    #####:10530:                    it != itEnd;
    #####:10531:                    ++it )
    #####:10532:                writeTestCase( **it );
        -:10533:
    #####:10534:            xml.scopedElement( "system-out" ).writeText( trim( stdOutForSuite.str() ), false );
    #####:10535:            xml.scopedElement( "system-err" ).writeText( trim( stdErrForSuite.str() ), false );
    #####:10536:        }
        -:10537:
    #####:10538:        void writeTestCase( TestCaseNode const& testCaseNode ) {
    #####:10539:            TestCaseStats const& stats = testCaseNode.value;
        -:10540:
        -:10541:            // All test cases have exactly one section - which represents the
        -:10542:            // test case itself. That section may have 0-n nested sections
    #####:10543:            assert( testCaseNode.children.size() == 1 );
    #####:10544:            SectionNode const& rootSection = *testCaseNode.children.front();
        -:10545:
    #####:10546:            std::string className = stats.testInfo.className;
        -:10547:
    #####:10548:            if( className.empty() ) {
    #####:10549:                if( rootSection.childSections.empty() )
    #####:10550:                    className = "global";
        -:10551:            }
    #####:10552:            writeSection( className, "", rootSection );
    #####:10553:        }
        -:10554:
    #####:10555:        void writeSection(  std::string const& className,
        -:10556:                            std::string const& rootName,
        -:10557:                            SectionNode const& sectionNode ) {
    #####:10558:            std::string name = trim( sectionNode.stats.sectionInfo.name );
    #####:10559:            if( !rootName.empty() )
    #####:10560:                name = rootName + '/' + name;
        -:10561:
    #####:10562:            if( !sectionNode.assertions.empty() ||
    #####:10563:                !sectionNode.stdOut.empty() ||
    #####:10564:                !sectionNode.stdErr.empty() ) {
    #####:10565:                XmlWriter::ScopedElement e = xml.scopedElement( "testcase" );
    #####:10566:                if( className.empty() ) {
    #####:10567:                    xml.writeAttribute( "classname", name );
    #####:10568:                    xml.writeAttribute( "name", "root" );
        -:10569:                }
        -:10570:                else {
    #####:10571:                    xml.writeAttribute( "classname", className );
    #####:10572:                    xml.writeAttribute( "name", name );
        -:10573:                }
    #####:10574:                xml.writeAttribute( "time", Catch::toString( sectionNode.stats.durationInSeconds ) );
        -:10575:
    #####:10576:                writeAssertions( sectionNode );
        -:10577:
    #####:10578:                if( !sectionNode.stdOut.empty() )
    #####:10579:                    xml.scopedElement( "system-out" ).writeText( trim( sectionNode.stdOut ), false );
    #####:10580:                if( !sectionNode.stdErr.empty() )
    #####:10581:                    xml.scopedElement( "system-err" ).writeText( trim( sectionNode.stdErr ), false );
        -:10582:            }
    #####:10583:            for( SectionNode::ChildSections::const_iterator
    #####:10584:                    it = sectionNode.childSections.begin(),
    #####:10585:                    itEnd = sectionNode.childSections.end();
    #####:10586:                    it != itEnd;
    #####:10587:                    ++it )
    #####:10588:                if( className.empty() )
    #####:10589:                    writeSection( name, "", **it );
        -:10590:                else
    #####:10591:                    writeSection( className, name, **it );
    #####:10592:        }
        -:10593:
    #####:10594:        void writeAssertions( SectionNode const& sectionNode ) {
    #####:10595:            for( SectionNode::Assertions::const_iterator
    #####:10596:                    it = sectionNode.assertions.begin(), itEnd = sectionNode.assertions.end();
    #####:10597:                    it != itEnd;
    #####:10598:                    ++it )
    #####:10599:                writeAssertion( *it );
    #####:10600:        }
    #####:10601:        void writeAssertion( AssertionStats const& stats ) {
    #####:10602:            AssertionResult const& result = stats.assertionResult;
    #####:10603:            if( !result.isOk() ) {
    #####:10604:                std::string elementName;
    #####:10605:                switch( result.getResultType() ) {
    #####:10606:                    case ResultWas::ThrewException:
        -:10607:                    case ResultWas::FatalErrorCondition:
    #####:10608:                        elementName = "error";
    #####:10609:                        break;
    #####:10610:                    case ResultWas::ExplicitFailure:
    #####:10611:                        elementName = "failure";
    #####:10612:                        break;
    #####:10613:                    case ResultWas::ExpressionFailed:
    #####:10614:                        elementName = "failure";
    #####:10615:                        break;
    #####:10616:                    case ResultWas::DidntThrowException:
    #####:10617:                        elementName = "failure";
    #####:10618:                        break;
        -:10619:
        -:10620:                    // We should never see these here:
    #####:10621:                    case ResultWas::Info:
        -:10622:                    case ResultWas::Warning:
        -:10623:                    case ResultWas::Ok:
        -:10624:                    case ResultWas::Unknown:
        -:10625:                    case ResultWas::FailureBit:
        -:10626:                    case ResultWas::Exception:
    #####:10627:                        elementName = "internalError";
    #####:10628:                        break;
        -:10629:                }
        -:10630:
    #####:10631:                XmlWriter::ScopedElement e = xml.scopedElement( elementName );
        -:10632:
    #####:10633:                xml.writeAttribute( "message", result.getExpandedExpression() );
    #####:10634:                xml.writeAttribute( "type", result.getTestMacroName() );
        -:10635:
    #####:10636:                std::ostringstream oss;
    #####:10637:                if( !result.getMessage().empty() )
    #####:10638:                    oss << result.getMessage() << '\n';
    #####:10639:                for( std::vector<MessageInfo>::const_iterator
    #####:10640:                        it = stats.infoMessages.begin(),
    #####:10641:                        itEnd = stats.infoMessages.end();
    #####:10642:                            it != itEnd;
    #####:10643:                            ++it )
    #####:10644:                    if( it->type == ResultWas::Info )
    #####:10645:                        oss << it->message << '\n';
        -:10646:
    #####:10647:                oss << "at " << result.getSourceInfo();
    #####:10648:                xml.writeText( oss.str(), false );
        -:10649:            }
    #####:10650:        }
        -:10651:
        -:10652:        XmlWriter xml;
        -:10653:        Timer suiteTimer;
        -:10654:        std::ostringstream stdOutForSuite;
        -:10655:        std::ostringstream stdErrForSuite;
        -:10656:        unsigned int unexpectedExceptions;
        -:10657:        bool m_okToFail;
        -:10658:    };
        -:10659:
        -:10660:    INTERNAL_CATCH_REGISTER_REPORTER( "junit", JunitReporter )
        -:10661:
        -:10662:} // end namespace Catch
        -:10663:
        -:10664:// #included from: ../reporters/catch_reporter_console.hpp
        -:10665:#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED
        -:10666:
        -:10667:#include <cfloat>
        -:10668:#include <cstdio>
        -:10669:
        -:10670:namespace Catch {
        -:10671:
        -:10672:    struct ConsoleReporter : StreamingReporterBase {
        1:10673:        ConsoleReporter( ReporterConfig const& _config )
        1:10674:        :   StreamingReporterBase( _config ),
        1:10675:            m_headerPrinted( false )
        1:10676:        {}
        -:10677:
        -:10678:        virtual ~ConsoleReporter() CATCH_OVERRIDE;
    #####:10679:        static std::string getDescription() {
    #####:10680:            return "Reports test results as plain lines of text";
        -:10681:        }
        -:10682:
    #####:10683:        virtual void noMatchingTestCases( std::string const& spec ) CATCH_OVERRIDE {
    #####:10684:            stream << "No test cases matched '" << spec << '\'' << std::endl;
    #####:10685:        }
        -:10686:
    #####:10687:        virtual void assertionStarting( AssertionInfo const& ) CATCH_OVERRIDE {
    #####:10688:        }
        -:10689:
    #####:10690:        virtual bool assertionEnded( AssertionStats const& _assertionStats ) CATCH_OVERRIDE {
    #####:10691:            AssertionResult const& result = _assertionStats.assertionResult;
        -:10692:
    #####:10693:            bool includeResults = m_config->includeSuccessfulResults() || !result.isOk();
        -:10694:
        -:10695:            // Drop out if result was successful but we're not printing them.
    #####:10696:            if( !includeResults && result.getResultType() != ResultWas::Warning )
    #####:10697:                return false;
        -:10698:
    #####:10699:            lazyPrint();
        -:10700:
    #####:10701:            AssertionPrinter printer( stream, _assertionStats, includeResults );
    #####:10702:            printer.print();
    #####:10703:            stream << std::endl;
    #####:10704:            return true;
        -:10705:        }
        -:10706:
       12:10707:        virtual void sectionStarting( SectionInfo const& _sectionInfo ) CATCH_OVERRIDE {
       12:10708:            m_headerPrinted = false;
       12:10709:            StreamingReporterBase::sectionStarting( _sectionInfo );
       12:10710:        }
       12:10711:        virtual void sectionEnded( SectionStats const& _sectionStats ) CATCH_OVERRIDE {
       12:10712:            if( _sectionStats.missingAssertions ) {
    #####:10713:                lazyPrint();
    #####:10714:                Colour colour( Colour::ResultError );
    #####:10715:                if( m_sectionStack.size() > 1 )
    #####:10716:                    stream << "\nNo assertions in section";
        -:10717:                else
    #####:10718:                    stream << "\nNo assertions in test case";
    #####:10719:                stream << " '" << _sectionStats.sectionInfo.name << "'\n" << std::endl;
        -:10720:            }
       12:10721:            if( m_config->showDurations() == ShowDurations::Always ) {
    #####:10722:                stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
        -:10723:            }
       12:10724:            if( m_headerPrinted ) {
    #####:10725:                m_headerPrinted = false;
        -:10726:            }
       12:10727:            StreamingReporterBase::sectionEnded( _sectionStats );
       12:10728:        }
        -:10729:
        1:10730:        virtual void testCaseEnded( TestCaseStats const& _testCaseStats ) CATCH_OVERRIDE {
        1:10731:            StreamingReporterBase::testCaseEnded( _testCaseStats );
        1:10732:            m_headerPrinted = false;
        1:10733:        }
        1:10734:        virtual void testGroupEnded( TestGroupStats const& _testGroupStats ) CATCH_OVERRIDE {
        1:10735:            if( currentGroupInfo.used ) {
    #####:10736:                printSummaryDivider();
    #####:10737:                stream << "Summary for group '" << _testGroupStats.groupInfo.name << "':\n";
    #####:10738:                printTotals( _testGroupStats.totals );
    #####:10739:                stream << '\n' << std::endl;
        -:10740:            }
        1:10741:            StreamingReporterBase::testGroupEnded( _testGroupStats );
        1:10742:        }
        1:10743:        virtual void testRunEnded( TestRunStats const& _testRunStats ) CATCH_OVERRIDE {
        1:10744:            printTotalsDivider( _testRunStats.totals );
        1:10745:            printTotals( _testRunStats.totals );
        1:10746:            stream << std::endl;
        1:10747:            StreamingReporterBase::testRunEnded( _testRunStats );
        1:10748:        }
        -:10749:
        -:10750:    private:
        -:10751:
        -:10752:        class AssertionPrinter {
        -:10753:            void operator= ( AssertionPrinter const& );
        -:10754:        public:
    #####:10755:            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )
    #####:10756:            :   stream( _stream ),
        -:10757:                stats( _stats ),
    #####:10758:                result( _stats.assertionResult ),
        -:10759:                colour( Colour::None ),
    #####:10760:                message( result.getMessage() ),
    #####:10761:                messages( _stats.infoMessages ),
    #####:10762:                printInfoMessages( _printInfoMessages )
        -:10763:            {
    #####:10764:                switch( result.getResultType() ) {
    #####:10765:                    case ResultWas::Ok:
    #####:10766:                        colour = Colour::Success;
    #####:10767:                        passOrFail = "PASSED";
        -:10768:                        //if( result.hasMessage() )
    #####:10769:                        if( _stats.infoMessages.size() == 1 )
    #####:10770:                            messageLabel = "with message";
    #####:10771:                        if( _stats.infoMessages.size() > 1 )
    #####:10772:                            messageLabel = "with messages";
    #####:10773:                        break;
    #####:10774:                    case ResultWas::ExpressionFailed:
    #####:10775:                        if( result.isOk() ) {
    #####:10776:                            colour = Colour::Success;
    #####:10777:                            passOrFail = "FAILED - but was ok";
        -:10778:                        }
        -:10779:                        else {
    #####:10780:                            colour = Colour::Error;
    #####:10781:                            passOrFail = "FAILED";
        -:10782:                        }
    #####:10783:                        if( _stats.infoMessages.size() == 1 )
    #####:10784:                            messageLabel = "with message";
    #####:10785:                        if( _stats.infoMessages.size() > 1 )
    #####:10786:                            messageLabel = "with messages";
    #####:10787:                        break;
    #####:10788:                    case ResultWas::ThrewException:
    #####:10789:                        colour = Colour::Error;
    #####:10790:                        passOrFail = "FAILED";
    #####:10791:                        messageLabel = "due to unexpected exception with ";
    #####:10792:                        if (_stats.infoMessages.size() == 1)
    #####:10793:                            messageLabel += "message";
    #####:10794:                        if (_stats.infoMessages.size() > 1)
    #####:10795:                            messageLabel += "messages";
    #####:10796:                        break;
    #####:10797:                    case ResultWas::FatalErrorCondition:
    #####:10798:                        colour = Colour::Error;
    #####:10799:                        passOrFail = "FAILED";
    #####:10800:                        messageLabel = "due to a fatal error condition";
    #####:10801:                        break;
    #####:10802:                    case ResultWas::DidntThrowException:
    #####:10803:                        colour = Colour::Error;
    #####:10804:                        passOrFail = "FAILED";
    #####:10805:                        messageLabel = "because no exception was thrown where one was expected";
    #####:10806:                        break;
    #####:10807:                    case ResultWas::Info:
    #####:10808:                        messageLabel = "info";
    #####:10809:                        break;
    #####:10810:                    case ResultWas::Warning:
    #####:10811:                        messageLabel = "warning";
    #####:10812:                        break;
    #####:10813:                    case ResultWas::ExplicitFailure:
    #####:10814:                        passOrFail = "FAILED";
    #####:10815:                        colour = Colour::Error;
    #####:10816:                        if( _stats.infoMessages.size() == 1 )
    #####:10817:                            messageLabel = "explicitly with message";
    #####:10818:                        if( _stats.infoMessages.size() > 1 )
    #####:10819:                            messageLabel = "explicitly with messages";
    #####:10820:                        break;
        -:10821:                    // These cases are here to prevent compiler warnings
    #####:10822:                    case ResultWas::Unknown:
        -:10823:                    case ResultWas::FailureBit:
        -:10824:                    case ResultWas::Exception:
    #####:10825:                        passOrFail = "** internal error **";
    #####:10826:                        colour = Colour::Error;
    #####:10827:                        break;
        -:10828:                }
    #####:10829:            }
        -:10830:
    #####:10831:            void print() const {
    #####:10832:                printSourceInfo();
    #####:10833:                if( stats.totals.assertions.total() > 0 ) {
    #####:10834:                    if( result.isOk() )
    #####:10835:                        stream << '\n';
    #####:10836:                    printResultType();
    #####:10837:                    printOriginalExpression();
    #####:10838:                    printReconstructedExpression();
        -:10839:                }
        -:10840:                else {
    #####:10841:                    stream << '\n';
        -:10842:                }
    #####:10843:                printMessage();
    #####:10844:            }
        -:10845:
        -:10846:        private:
    #####:10847:            void printResultType() const {
    #####:10848:                if( !passOrFail.empty() ) {
    #####:10849:                    Colour colourGuard( colour );
    #####:10850:                    stream << passOrFail << ":\n";
        -:10851:                }
    #####:10852:            }
    #####:10853:            void printOriginalExpression() const {
    #####:10854:                if( result.hasExpression() ) {
    #####:10855:                    Colour colourGuard( Colour::OriginalExpression );
    #####:10856:                    stream  << "  ";
    #####:10857:                    stream << result.getExpressionInMacro();
    #####:10858:                    stream << '\n';
        -:10859:                }
    #####:10860:            }
    #####:10861:            void printReconstructedExpression() const {
    #####:10862:                if( result.hasExpandedExpression() ) {
    #####:10863:                    stream << "with expansion:\n";
    #####:10864:                    Colour colourGuard( Colour::ReconstructedExpression );
    #####:10865:                    stream << Text( result.getExpandedExpression(), TextAttributes().setIndent(2) ) << '\n';
        -:10866:                }
    #####:10867:            }
    #####:10868:            void printMessage() const {
    #####:10869:                if( !messageLabel.empty() )
    #####:10870:                    stream << messageLabel << ':' << '\n';
    #####:10871:                for( std::vector<MessageInfo>::const_iterator it = messages.begin(), itEnd = messages.end();
    #####:10872:                        it != itEnd;
    #####:10873:                        ++it ) {
        -:10874:                    // If this assertion is a warning ignore any INFO messages
    #####:10875:                    if( printInfoMessages || it->type != ResultWas::Info )
    #####:10876:                        stream << Text( it->message, TextAttributes().setIndent(2) ) << '\n';
        -:10877:                }
    #####:10878:            }
    #####:10879:            void printSourceInfo() const {
    #####:10880:                Colour colourGuard( Colour::FileName );
    #####:10881:                stream << result.getSourceInfo() << ": ";
    #####:10882:            }
        -:10883:
        -:10884:            std::ostream& stream;
        -:10885:            AssertionStats const& stats;
        -:10886:            AssertionResult const& result;
        -:10887:            Colour::Code colour;
        -:10888:            std::string passOrFail;
        -:10889:            std::string messageLabel;
        -:10890:            std::string message;
        -:10891:            std::vector<MessageInfo> messages;
        -:10892:            bool printInfoMessages;
        -:10893:        };
        -:10894:
    #####:10895:        void lazyPrint() {
        -:10896:
    #####:10897:            if( !currentTestRunInfo.used )
    #####:10898:                lazyPrintRunInfo();
    #####:10899:            if( !currentGroupInfo.used )
    #####:10900:                lazyPrintGroupInfo();
        -:10901:
    #####:10902:            if( !m_headerPrinted ) {
    #####:10903:                printTestCaseAndSectionHeader();
    #####:10904:                m_headerPrinted = true;
        -:10905:            }
    #####:10906:        }
    #####:10907:        void lazyPrintRunInfo() {
    #####:10908:            stream  << '\n' << getLineOfChars<'~'>() << '\n';
    #####:10909:            Colour colour( Colour::SecondaryText );
    #####:10910:            stream  << currentTestRunInfo->name
    #####:10911:                    << " is a Catch v"  << libraryVersion() << " host application.\n"
    #####:10912:                    << "Run with -? for options\n\n";
        -:10913:
    #####:10914:            if( m_config->rngSeed() != 0 )
    #####:10915:                stream << "Randomness seeded to: " << m_config->rngSeed() << "\n\n";
        -:10916:
    #####:10917:            currentTestRunInfo.used = true;
    #####:10918:        }
    #####:10919:        void lazyPrintGroupInfo() {
    #####:10920:            if( !currentGroupInfo->name.empty() && currentGroupInfo->groupsCounts > 1 ) {
    #####:10921:                printClosedHeader( "Group: " + currentGroupInfo->name );
    #####:10922:                currentGroupInfo.used = true;
        -:10923:            }
    #####:10924:        }
    #####:10925:        void printTestCaseAndSectionHeader() {
    #####:10926:            assert( !m_sectionStack.empty() );
    #####:10927:            printOpenHeader( currentTestCaseInfo->name );
        -:10928:
    #####:10929:            if( m_sectionStack.size() > 1 ) {
    #####:10930:                Colour colourGuard( Colour::Headers );
        -:10931:
        -:10932:                std::vector<SectionInfo>::const_iterator
    #####:10933:                    it = m_sectionStack.begin()+1, // Skip first section (test case)
    #####:10934:                    itEnd = m_sectionStack.end();
    #####:10935:                for( ; it != itEnd; ++it )
    #####:10936:                    printHeaderString( it->name, 2 );
        -:10937:            }
        -:10938:
    #####:10939:            SourceLineInfo lineInfo = m_sectionStack.back().lineInfo;
        -:10940:
    #####:10941:            if( !lineInfo.empty() ){
    #####:10942:                stream << getLineOfChars<'-'>() << '\n';
    #####:10943:                Colour colourGuard( Colour::FileName );
    #####:10944:                stream << lineInfo << '\n';
        -:10945:            }
    #####:10946:            stream << getLineOfChars<'.'>() << '\n' << std::endl;
    #####:10947:        }
        -:10948:
    #####:10949:        void printClosedHeader( std::string const& _name ) {
    #####:10950:            printOpenHeader( _name );
    #####:10951:            stream << getLineOfChars<'.'>() << '\n';
    #####:10952:        }
    #####:10953:        void printOpenHeader( std::string const& _name ) {
    #####:10954:            stream  << getLineOfChars<'-'>() << '\n';
        -:10955:            {
    #####:10956:                Colour colourGuard( Colour::Headers );
    #####:10957:                printHeaderString( _name );
        -:10958:            }
    #####:10959:        }
        -:10960:
        -:10961:        // if string has a : in first line will set indent to follow it on
        -:10962:        // subsequent lines
    #####:10963:        void printHeaderString( std::string const& _string, std::size_t indent = 0 ) {
    #####:10964:            std::size_t i = _string.find( ": " );
    #####:10965:            if( i != std::string::npos )
    #####:10966:                i+=2;
        -:10967:            else
    #####:10968:                i = 0;
    #####:10969:            stream << Text( _string, TextAttributes()
    #####:10970:                                        .setIndent( indent+i)
    #####:10971:                                        .setInitialIndent( indent ) ) << '\n';
    #####:10972:        }
        -:10973:
        -:10974:        struct SummaryColumn {
        -:10975:
    #####:10976:            SummaryColumn( std::string const& _label, Colour::Code _colour )
    #####:10977:            :   label( _label ),
    #####:10978:                colour( _colour )
    #####:10979:            {}
    #####:10980:            SummaryColumn addRow( std::size_t count ) {
    #####:10981:                std::ostringstream oss;
    #####:10982:                oss << count;
    #####:10983:                std::string row = oss.str();
    #####:10984:                for( std::vector<std::string>::iterator it = rows.begin(); it != rows.end(); ++it ) {
    #####:10985:                    while( it->size() < row.size() )
    #####:10986:                        *it = ' ' + *it;
    #####:10987:                    while( it->size() > row.size() )
    #####:10988:                        row = ' ' + row;
        -:10989:                }
    #####:10990:                rows.push_back( row );
    #####:10991:                return *this;
        -:10992:            }
        -:10993:
        -:10994:            std::string label;
        -:10995:            Colour::Code colour;
        -:10996:            std::vector<std::string> rows;
        -:10997:
        -:10998:        };
        -:10999:
        1:11000:        void printTotals( Totals const& totals ) {
        1:11001:            if( totals.testCases.total() == 0 ) {
    #####:11002:                stream << Colour( Colour::Warning ) << "No tests ran\n";
        -:11003:            }
       1*:11004:            else if( totals.assertions.total() > 0 && totals.testCases.allPassed() ) {
        1:11005:                stream << Colour( Colour::ResultSuccess ) << "All tests passed";
        1:11006:                stream << " ("
        2:11007:                        << pluralise( totals.assertions.passed, "assertion" ) << " in "
        2:11008:                        << pluralise( totals.testCases.passed, "test case" ) << ')'
        1:11009:                        << '\n';
        -:11010:            }
        -:11011:            else {
        -:11012:
    #####:11013:                std::vector<SummaryColumn> columns;
    #####:11014:                columns.push_back( SummaryColumn( "", Colour::None )
    #####:11015:                                        .addRow( totals.testCases.total() )
    #####:11016:                                        .addRow( totals.assertions.total() ) );
    #####:11017:                columns.push_back( SummaryColumn( "passed", Colour::Success )
    #####:11018:                                        .addRow( totals.testCases.passed )
    #####:11019:                                        .addRow( totals.assertions.passed ) );
    #####:11020:                columns.push_back( SummaryColumn( "failed", Colour::ResultError )
    #####:11021:                                        .addRow( totals.testCases.failed )
    #####:11022:                                        .addRow( totals.assertions.failed ) );
    #####:11023:                columns.push_back( SummaryColumn( "failed as expected", Colour::ResultExpectedFailure )
    #####:11024:                                        .addRow( totals.testCases.failedButOk )
    #####:11025:                                        .addRow( totals.assertions.failedButOk ) );
        -:11026:
    #####:11027:                printSummaryRow( "test cases", columns, 0 );
    #####:11028:                printSummaryRow( "assertions", columns, 1 );
        -:11029:            }
        1:11030:        }
    #####:11031:        void printSummaryRow( std::string const& label, std::vector<SummaryColumn> const& cols, std::size_t row ) {
    #####:11032:            for( std::vector<SummaryColumn>::const_iterator it = cols.begin(); it != cols.end(); ++it ) {
    #####:11033:                std::string value = it->rows[row];
    #####:11034:                if( it->label.empty() ) {
    #####:11035:                    stream << label << ": ";
    #####:11036:                    if( value != "0" )
    #####:11037:                        stream << value;
        -:11038:                    else
    #####:11039:                        stream << Colour( Colour::Warning ) << "- none -";
        -:11040:                }
    #####:11041:                else if( value != "0" ) {
    #####:11042:                    stream  << Colour( Colour::LightGrey ) << " | ";
    #####:11043:                    stream  << Colour( it->colour )
    #####:11044:                            << value << ' ' << it->label;
        -:11045:                }
        -:11046:            }
    #####:11047:            stream << '\n';
    #####:11048:        }
        -:11049:
        3:11050:        static std::size_t makeRatio( std::size_t number, std::size_t total ) {
       3*:11051:            std::size_t ratio = total > 0 ? CATCH_CONFIG_CONSOLE_WIDTH * number/ total : 0;
       3*:11052:            return ( ratio == 0 && number > 0 ) ? 1 : ratio;
        -:11053:        }
        1:11054:        static std::size_t& findMax( std::size_t& i, std::size_t& j, std::size_t& k ) {
       1*:11055:            if( i > j && i > k )
    #####:11056:                return i;
        1:11057:            else if( j > k )
    #####:11058:                return j;
        -:11059:            else
        1:11060:                return k;
        -:11061:        }
        -:11062:
        1:11063:        void printTotalsDivider( Totals const& totals ) {
        1:11064:            if( totals.testCases.total() > 0 ) {
        1:11065:                std::size_t failedRatio = makeRatio( totals.testCases.failed, totals.testCases.total() );
        1:11066:                std::size_t failedButOkRatio = makeRatio( totals.testCases.failedButOk, totals.testCases.total() );
        1:11067:                std::size_t passedRatio = makeRatio( totals.testCases.passed, totals.testCases.total() );
       1*:11068:                while( failedRatio + failedButOkRatio + passedRatio < CATCH_CONFIG_CONSOLE_WIDTH-1 )
    #####:11069:                    findMax( failedRatio, failedButOkRatio, passedRatio )++;
        2:11070:                while( failedRatio + failedButOkRatio + passedRatio > CATCH_CONFIG_CONSOLE_WIDTH-1 )
        1:11071:                    findMax( failedRatio, failedButOkRatio, passedRatio )--;
        -:11072:
        1:11073:                stream << Colour( Colour::Error ) << std::string( failedRatio, '=' );
        1:11074:                stream << Colour( Colour::ResultExpectedFailure ) << std::string( failedButOkRatio, '=' );
        1:11075:                if( totals.testCases.allPassed() )
        1:11076:                    stream << Colour( Colour::ResultSuccess ) << std::string( passedRatio, '=' );
        -:11077:                else
    #####:11078:                    stream << Colour( Colour::Success ) << std::string( passedRatio, '=' );
        -:11079:            }
        -:11080:            else {
    #####:11081:                stream << Colour( Colour::Warning ) << std::string( CATCH_CONFIG_CONSOLE_WIDTH-1, '=' );
        -:11082:            }
        1:11083:            stream << '\n';
        1:11084:        }
    #####:11085:        void printSummaryDivider() {
    #####:11086:            stream << getLineOfChars<'-'>() << '\n';
    #####:11087:        }
        -:11088:
        -:11089:    private:
        -:11090:        bool m_headerPrinted;
        -:11091:    };
        -:11092:
        -:11093:    INTERNAL_CATCH_REGISTER_REPORTER( "console", ConsoleReporter )
        -:11094:
        -:11095:} // end namespace Catch
        -:11096:
        -:11097:// #included from: ../reporters/catch_reporter_compact.hpp
        -:11098:#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED
        -:11099:
        -:11100:namespace Catch {
        -:11101:
        -:11102:    struct CompactReporter : StreamingReporterBase {
        -:11103:
    #####:11104:        CompactReporter( ReporterConfig const& _config )
    #####:11105:        : StreamingReporterBase( _config )
    #####:11106:        {}
        -:11107:
        -:11108:        virtual ~CompactReporter();
        -:11109:
    #####:11110:        static std::string getDescription() {
    #####:11111:            return "Reports test results on a single line, suitable for IDEs";
        -:11112:        }
        -:11113:
    #####:11114:        virtual ReporterPreferences getPreferences() const {
    #####:11115:            ReporterPreferences prefs;
    #####:11116:            prefs.shouldRedirectStdOut = false;
    #####:11117:            return prefs;
        -:11118:        }
        -:11119:
    #####:11120:        virtual void noMatchingTestCases( std::string const& spec ) {
    #####:11121:            stream << "No test cases matched '" << spec << '\'' << std::endl;
    #####:11122:        }
        -:11123:
    #####:11124:        virtual void assertionStarting( AssertionInfo const& ) {}
        -:11125:
    #####:11126:        virtual bool assertionEnded( AssertionStats const& _assertionStats ) {
    #####:11127:            AssertionResult const& result = _assertionStats.assertionResult;
        -:11128:
    #####:11129:            bool printInfoMessages = true;
        -:11130:
        -:11131:            // Drop out if result was successful and we're not printing those
    #####:11132:            if( !m_config->includeSuccessfulResults() && result.isOk() ) {
    #####:11133:                if( result.getResultType() != ResultWas::Warning )
    #####:11134:                    return false;
    #####:11135:                printInfoMessages = false;
        -:11136:            }
        -:11137:
    #####:11138:            AssertionPrinter printer( stream, _assertionStats, printInfoMessages );
    #####:11139:            printer.print();
        -:11140:
    #####:11141:            stream << std::endl;
    #####:11142:            return true;
        -:11143:        }
        -:11144:
    #####:11145:        virtual void sectionEnded(SectionStats const& _sectionStats) CATCH_OVERRIDE {
    #####:11146:            if (m_config->showDurations() == ShowDurations::Always) {
    #####:11147:                stream << getFormattedDuration(_sectionStats.durationInSeconds) << " s: " << _sectionStats.sectionInfo.name << std::endl;
        -:11148:            }
    #####:11149:        }
        -:11150:
    #####:11151:        virtual void testRunEnded( TestRunStats const& _testRunStats ) {
    #####:11152:            printTotals( _testRunStats.totals );
    #####:11153:            stream << '\n' << std::endl;
    #####:11154:            StreamingReporterBase::testRunEnded( _testRunStats );
    #####:11155:        }
        -:11156:
        -:11157:    private:
        -:11158:        class AssertionPrinter {
        -:11159:            void operator= ( AssertionPrinter const& );
        -:11160:        public:
    #####:11161:            AssertionPrinter( std::ostream& _stream, AssertionStats const& _stats, bool _printInfoMessages )
    #####:11162:            : stream( _stream )
        -:11163:            , stats( _stats )
    #####:11164:            , result( _stats.assertionResult )
    #####:11165:            , messages( _stats.infoMessages )
    #####:11166:            , itMessage( _stats.infoMessages.begin() )
    #####:11167:            , printInfoMessages( _printInfoMessages )
    #####:11168:            {}
        -:11169:
    #####:11170:            void print() {
    #####:11171:                printSourceInfo();
        -:11172:
    #####:11173:                itMessage = messages.begin();
        -:11174:
    #####:11175:                switch( result.getResultType() ) {
    #####:11176:                    case ResultWas::Ok:
    #####:11177:                        printResultType( Colour::ResultSuccess, passedString() );
    #####:11178:                        printOriginalExpression();
    #####:11179:                        printReconstructedExpression();
    #####:11180:                        if ( ! result.hasExpression() )
    #####:11181:                            printRemainingMessages( Colour::None );
        -:11182:                        else
    #####:11183:                            printRemainingMessages();
    #####:11184:                        break;
    #####:11185:                    case ResultWas::ExpressionFailed:
    #####:11186:                        if( result.isOk() )
    #####:11187:                            printResultType( Colour::ResultSuccess, failedString() + std::string( " - but was ok" ) );
        -:11188:                        else
    #####:11189:                            printResultType( Colour::Error, failedString() );
    #####:11190:                        printOriginalExpression();
    #####:11191:                        printReconstructedExpression();
    #####:11192:                        printRemainingMessages();
    #####:11193:                        break;
    #####:11194:                    case ResultWas::ThrewException:
    #####:11195:                        printResultType( Colour::Error, failedString() );
    #####:11196:                        printIssue( "unexpected exception with message:" );
    #####:11197:                        printMessage();
    #####:11198:                        printExpressionWas();
    #####:11199:                        printRemainingMessages();
    #####:11200:                        break;
    #####:11201:                    case ResultWas::FatalErrorCondition:
    #####:11202:                        printResultType( Colour::Error, failedString() );
    #####:11203:                        printIssue( "fatal error condition with message:" );
    #####:11204:                        printMessage();
    #####:11205:                        printExpressionWas();
    #####:11206:                        printRemainingMessages();
    #####:11207:                        break;
    #####:11208:                    case ResultWas::DidntThrowException:
    #####:11209:                        printResultType( Colour::Error, failedString() );
    #####:11210:                        printIssue( "expected exception, got none" );
    #####:11211:                        printExpressionWas();
    #####:11212:                        printRemainingMessages();
    #####:11213:                        break;
    #####:11214:                    case ResultWas::Info:
    #####:11215:                        printResultType( Colour::None, "info" );
    #####:11216:                        printMessage();
    #####:11217:                        printRemainingMessages();
    #####:11218:                        break;
    #####:11219:                    case ResultWas::Warning:
    #####:11220:                        printResultType( Colour::None, "warning" );
    #####:11221:                        printMessage();
    #####:11222:                        printRemainingMessages();
    #####:11223:                        break;
    #####:11224:                    case ResultWas::ExplicitFailure:
    #####:11225:                        printResultType( Colour::Error, failedString() );
    #####:11226:                        printIssue( "explicitly" );
    #####:11227:                        printRemainingMessages( Colour::None );
    #####:11228:                        break;
        -:11229:                    // These cases are here to prevent compiler warnings
    #####:11230:                    case ResultWas::Unknown:
        -:11231:                    case ResultWas::FailureBit:
        -:11232:                    case ResultWas::Exception:
    #####:11233:                        printResultType( Colour::Error, "** internal error **" );
    #####:11234:                        break;
        -:11235:                }
    #####:11236:            }
        -:11237:
        -:11238:        private:
        -:11239:            // Colour::LightGrey
        -:11240:
    #####:11241:            static Colour::Code dimColour() { return Colour::FileName; }
        -:11242:
        -:11243:#ifdef CATCH_PLATFORM_MAC
        -:11244:            static const char* failedString() { return "FAILED"; }
        -:11245:            static const char* passedString() { return "PASSED"; }
        -:11246:#else
    #####:11247:            static const char* failedString() { return "failed"; }
    #####:11248:            static const char* passedString() { return "passed"; }
        -:11249:#endif
        -:11250:
    #####:11251:            void printSourceInfo() const {
    #####:11252:                Colour colourGuard( Colour::FileName );
    #####:11253:                stream << result.getSourceInfo() << ':';
    #####:11254:            }
        -:11255:
    #####:11256:            void printResultType( Colour::Code colour, std::string const& passOrFail ) const {
    #####:11257:                if( !passOrFail.empty() ) {
        -:11258:                    {
    #####:11259:                        Colour colourGuard( colour );
    #####:11260:                        stream << ' ' << passOrFail;
        -:11261:                    }
    #####:11262:                    stream << ':';
        -:11263:                }
    #####:11264:            }
        -:11265:
    #####:11266:            void printIssue( std::string const& issue ) const {
    #####:11267:                stream << ' ' << issue;
    #####:11268:            }
        -:11269:
    #####:11270:            void printExpressionWas() {
    #####:11271:                if( result.hasExpression() ) {
    #####:11272:                    stream << ';';
        -:11273:                    {
    #####:11274:                        Colour colour( dimColour() );
    #####:11275:                        stream << " expression was:";
        -:11276:                    }
    #####:11277:                    printOriginalExpression();
        -:11278:                }
    #####:11279:            }
        -:11280:
    #####:11281:            void printOriginalExpression() const {
    #####:11282:                if( result.hasExpression() ) {
    #####:11283:                    stream << ' ' << result.getExpression();
        -:11284:                }
    #####:11285:            }
        -:11286:
    #####:11287:            void printReconstructedExpression() const {
    #####:11288:                if( result.hasExpandedExpression() ) {
        -:11289:                    {
    #####:11290:                        Colour colour( dimColour() );
    #####:11291:                        stream << " for: ";
        -:11292:                    }
    #####:11293:                    stream << result.getExpandedExpression();
        -:11294:                }
    #####:11295:            }
        -:11296:
    #####:11297:            void printMessage() {
    #####:11298:                if ( itMessage != messages.end() ) {
    #####:11299:                    stream << " '" << itMessage->message << '\'';
    #####:11300:                    ++itMessage;
        -:11301:                }
    #####:11302:            }
        -:11303:
    #####:11304:            void printRemainingMessages( Colour::Code colour = dimColour() ) {
    #####:11305:                if ( itMessage == messages.end() )
    #####:11306:                    return;
        -:11307:
        -:11308:                // using messages.end() directly yields compilation error:
    #####:11309:                std::vector<MessageInfo>::const_iterator itEnd = messages.end();
    #####:11310:                const std::size_t N = static_cast<std::size_t>( std::distance( itMessage, itEnd ) );
        -:11311:
        -:11312:                {
    #####:11313:                    Colour colourGuard( colour );
    #####:11314:                    stream << " with " << pluralise( N, "message" ) << ':';
        -:11315:                }
        -:11316:
    #####:11317:                for(; itMessage != itEnd; ) {
        -:11318:                    // If this assertion is a warning ignore any INFO messages
    #####:11319:                    if( printInfoMessages || itMessage->type != ResultWas::Info ) {
    #####:11320:                        stream << " '" << itMessage->message << '\'';
    #####:11321:                        if ( ++itMessage != itEnd ) {
    #####:11322:                            Colour colourGuard( dimColour() );
    #####:11323:                            stream << " and";
        -:11324:                        }
        -:11325:                    }
        -:11326:                }
        -:11327:            }
        -:11328:
        -:11329:        private:
        -:11330:            std::ostream& stream;
        -:11331:            AssertionStats const& stats;
        -:11332:            AssertionResult const& result;
        -:11333:            std::vector<MessageInfo> messages;
        -:11334:            std::vector<MessageInfo>::const_iterator itMessage;
        -:11335:            bool printInfoMessages;
        -:11336:        };
        -:11337:
        -:11338:        // Colour, message variants:
        -:11339:        // - white: No tests ran.
        -:11340:        // -   red: Failed [both/all] N test cases, failed [both/all] M assertions.
        -:11341:        // - white: Passed [both/all] N test cases (no assertions).
        -:11342:        // -   red: Failed N tests cases, failed M assertions.
        -:11343:        // - green: Passed [both/all] N tests cases with M assertions.
        -:11344:
    #####:11345:        std::string bothOrAll( std::size_t count ) const {
    #####:11346:            return count == 1 ? std::string() : count == 2 ? "both " : "all " ;
        -:11347:        }
        -:11348:
    #####:11349:        void printTotals( const Totals& totals ) const {
    #####:11350:            if( totals.testCases.total() == 0 ) {
    #####:11351:                stream << "No tests ran.";
        -:11352:            }
    #####:11353:            else if( totals.testCases.failed == totals.testCases.total() ) {
    #####:11354:                Colour colour( Colour::ResultError );
        -:11355:                const std::string qualify_assertions_failed =
    #####:11356:                    totals.assertions.failed == totals.assertions.total() ?
    #####:11357:                        bothOrAll( totals.assertions.failed ) : std::string();
    #####:11358:                stream <<
    #####:11359:                    "Failed " << bothOrAll( totals.testCases.failed )
    #####:11360:                              << pluralise( totals.testCases.failed, "test case"  ) << ", "
    #####:11361:                    "failed " << qualify_assertions_failed <<
    #####:11362:                                 pluralise( totals.assertions.failed, "assertion" ) << '.';
        -:11363:            }
    #####:11364:            else if( totals.assertions.total() == 0 ) {
    #####:11365:                stream <<
    #####:11366:                    "Passed " << bothOrAll( totals.testCases.total() )
    #####:11367:                              << pluralise( totals.testCases.total(), "test case" )
    #####:11368:                              << " (no assertions).";
        -:11369:            }
    #####:11370:            else if( totals.assertions.failed ) {
    #####:11371:                Colour colour( Colour::ResultError );
    #####:11372:                stream <<
    #####:11373:                    "Failed " << pluralise( totals.testCases.failed, "test case"  ) << ", "
    #####:11374:                    "failed " << pluralise( totals.assertions.failed, "assertion" ) << '.';
        -:11375:            }
        -:11376:            else {
    #####:11377:                Colour colour( Colour::ResultSuccess );
    #####:11378:                stream <<
    #####:11379:                    "Passed " << bothOrAll( totals.testCases.passed )
    #####:11380:                              << pluralise( totals.testCases.passed, "test case"  ) <<
    #####:11381:                    " with "  << pluralise( totals.assertions.passed, "assertion" ) << '.';
        -:11382:            }
    #####:11383:        }
        -:11384:    };
        -:11385:
        -:11386:    INTERNAL_CATCH_REGISTER_REPORTER( "compact", CompactReporter )
        -:11387:
        -:11388:} // end namespace Catch
        -:11389:
        -:11390:namespace Catch {
        -:11391:    // These are all here to avoid warnings about not having any out of line
        -:11392:    // virtual methods
      54*:11393:    NonCopyable::~NonCopyable() {}
------------------
_ZN5Catch11NonCopyableD0Ev:
    #####:11393:    NonCopyable::~NonCopyable() {}
------------------
_ZN5Catch11NonCopyableD2Ev:
       54:11393:    NonCopyable::~NonCopyable() {}
------------------
      17*:11394:    IShared::~IShared() {}
------------------
_ZN5Catch7ISharedD0Ev:
    #####:11394:    IShared::~IShared() {}
------------------
_ZN5Catch7ISharedD2Ev:
       17:11394:    IShared::~IShared() {}
------------------
       1*:11395:    IStream::~IStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch7IStreamD0Ev:
    #####:11395:    IStream::~IStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch7IStreamD2Ev:
        1:11395:    IStream::~IStream() CATCH_NOEXCEPT {}
------------------
    #####:11396:    FileStream::~FileStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch10FileStreamD0Ev:
    #####:11396:    FileStream::~FileStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch10FileStreamD2Ev:
    #####:11396:    FileStream::~FileStream() CATCH_NOEXCEPT {}
------------------
        2:11397:    CoutStream::~CoutStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch10CoutStreamD0Ev:
        1:11397:    CoutStream::~CoutStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch10CoutStreamD2Ev:
        1:11397:    CoutStream::~CoutStream() CATCH_NOEXCEPT {}
------------------
    #####:11398:    DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch14DebugOutStreamD0Ev:
    #####:11398:    DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}
------------------
_ZN5Catch14DebugOutStreamD2Ev:
    #####:11398:    DebugOutStream::~DebugOutStream() CATCH_NOEXCEPT {}
------------------
    #####:11399:    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
------------------
_ZN5Catch13StreamBufBaseD0Ev:
    #####:11399:    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
------------------
_ZN5Catch13StreamBufBaseD2Ev:
    #####:11399:    StreamBufBase::~StreamBufBase() CATCH_NOEXCEPT {}
------------------
       1*:11400:    IContext::~IContext() {}
------------------
_ZN5Catch8IContextD0Ev:
    #####:11400:    IContext::~IContext() {}
------------------
_ZN5Catch8IContextD2Ev:
        1:11400:    IContext::~IContext() {}
------------------
       1*:11401:    IResultCapture::~IResultCapture() {}
------------------
_ZN5Catch14IResultCaptureD0Ev:
    #####:11401:    IResultCapture::~IResultCapture() {}
------------------
_ZN5Catch14IResultCaptureD2Ev:
        1:11401:    IResultCapture::~IResultCapture() {}
------------------
       1*:11402:    ITestCase::~ITestCase() {}
------------------
_ZN5Catch9ITestCaseD0Ev:
    #####:11402:    ITestCase::~ITestCase() {}
------------------
_ZN5Catch9ITestCaseD2Ev:
        1:11402:    ITestCase::~ITestCase() {}
------------------
       1*:11403:    ITestCaseRegistry::~ITestCaseRegistry() {}
------------------
_ZN5Catch17ITestCaseRegistryD0Ev:
    #####:11403:    ITestCaseRegistry::~ITestCaseRegistry() {}
------------------
_ZN5Catch17ITestCaseRegistryD2Ev:
        1:11403:    ITestCaseRegistry::~ITestCaseRegistry() {}
------------------
       1*:11404:    IRegistryHub::~IRegistryHub() {}
------------------
_ZN5Catch12IRegistryHubD0Ev:
    #####:11404:    IRegistryHub::~IRegistryHub() {}
------------------
_ZN5Catch12IRegistryHubD2Ev:
        1:11404:    IRegistryHub::~IRegistryHub() {}
------------------
       1*:11405:    IMutableRegistryHub::~IMutableRegistryHub() {}
------------------
_ZN5Catch19IMutableRegistryHubD0Ev:
    #####:11405:    IMutableRegistryHub::~IMutableRegistryHub() {}
------------------
_ZN5Catch19IMutableRegistryHubD2Ev:
        1:11405:    IMutableRegistryHub::~IMutableRegistryHub() {}
------------------
    #####:11406:    IExceptionTranslator::~IExceptionTranslator() {}
------------------
_ZN5Catch20IExceptionTranslatorD0Ev:
    #####:11406:    IExceptionTranslator::~IExceptionTranslator() {}
------------------
_ZN5Catch20IExceptionTranslatorD2Ev:
    #####:11406:    IExceptionTranslator::~IExceptionTranslator() {}
------------------
       1*:11407:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
------------------
_ZN5Catch28IExceptionTranslatorRegistryD0Ev:
    #####:11407:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
------------------
_ZN5Catch28IExceptionTranslatorRegistryD2Ev:
        1:11407:    IExceptionTranslatorRegistry::~IExceptionTranslatorRegistry() {}
------------------
    #####:11408:    IReporter::~IReporter() {}
------------------
_ZN5Catch9IReporterD0Ev:
    #####:11408:    IReporter::~IReporter() {}
------------------
_ZN5Catch9IReporterD2Ev:
    #####:11408:    IReporter::~IReporter() {}
------------------
       4*:11409:    IReporterFactory::~IReporterFactory() {}
------------------
_ZN5Catch16IReporterFactoryD0Ev:
    #####:11409:    IReporterFactory::~IReporterFactory() {}
------------------
_ZN5Catch16IReporterFactoryD2Ev:
        4:11409:    IReporterFactory::~IReporterFactory() {}
------------------
       1*:11410:    IReporterRegistry::~IReporterRegistry() {}
------------------
_ZN5Catch17IReporterRegistryD0Ev:
    #####:11410:    IReporterRegistry::~IReporterRegistry() {}
------------------
_ZN5Catch17IReporterRegistryD2Ev:
        1:11410:    IReporterRegistry::~IReporterRegistry() {}
------------------
       1*:11411:    IStreamingReporter::~IStreamingReporter() {}
------------------
_ZN5Catch18IStreamingReporterD0Ev:
    #####:11411:    IStreamingReporter::~IStreamingReporter() {}
------------------
_ZN5Catch18IStreamingReporterD2Ev:
        1:11411:    IStreamingReporter::~IStreamingReporter() {}
------------------
    #####:11412:    AssertionStats::~AssertionStats() {}
------------------
_ZN5Catch14AssertionStatsD0Ev:
    #####:11412:    AssertionStats::~AssertionStats() {}
------------------
_ZN5Catch14AssertionStatsD2Ev:
    #####:11412:    AssertionStats::~AssertionStats() {}
------------------
      12*:11413:    SectionStats::~SectionStats() {}
------------------
_ZN5Catch12SectionStatsD0Ev:
    #####:11413:    SectionStats::~SectionStats() {}
------------------
_ZN5Catch12SectionStatsD2Ev:
       12:11413:    SectionStats::~SectionStats() {}
------------------
       1*:11414:    TestCaseStats::~TestCaseStats() {}
------------------
_ZN5Catch13TestCaseStatsD0Ev:
    #####:11414:    TestCaseStats::~TestCaseStats() {}
------------------
_ZN5Catch13TestCaseStatsD2Ev:
        1:11414:    TestCaseStats::~TestCaseStats() {}
------------------
       1*:11415:    TestGroupStats::~TestGroupStats() {}
------------------
_ZN5Catch14TestGroupStatsD0Ev:
    #####:11415:    TestGroupStats::~TestGroupStats() {}
------------------
_ZN5Catch14TestGroupStatsD2Ev:
        1:11415:    TestGroupStats::~TestGroupStats() {}
------------------
       1*:11416:    TestRunStats::~TestRunStats() {}
------------------
_ZN5Catch12TestRunStatsD0Ev:
    #####:11416:    TestRunStats::~TestRunStats() {}
------------------
_ZN5Catch12TestRunStatsD2Ev:
        1:11416:    TestRunStats::~TestRunStats() {}
------------------
    #####:11417:    CumulativeReporterBase::SectionNode::~SectionNode() {}
------------------
_ZN5Catch22CumulativeReporterBase11SectionNodeD0Ev:
    #####:11417:    CumulativeReporterBase::SectionNode::~SectionNode() {}
------------------
_ZN5Catch22CumulativeReporterBase11SectionNodeD2Ev:
    #####:11417:    CumulativeReporterBase::SectionNode::~SectionNode() {}
------------------
    #####:11418:    CumulativeReporterBase::~CumulativeReporterBase() {}
------------------
_ZN5Catch22CumulativeReporterBaseD0Ev:
    #####:11418:    CumulativeReporterBase::~CumulativeReporterBase() {}
------------------
_ZN5Catch22CumulativeReporterBaseD2Ev:
    #####:11418:    CumulativeReporterBase::~CumulativeReporterBase() {}
------------------
        -:11419:
       1*:11420:    StreamingReporterBase::~StreamingReporterBase() {}
------------------
_ZN5Catch21StreamingReporterBaseD0Ev:
    #####:11420:    StreamingReporterBase::~StreamingReporterBase() {}
------------------
_ZN5Catch21StreamingReporterBaseD2Ev:
        1:11420:    StreamingReporterBase::~StreamingReporterBase() {}
------------------
        2:11421:    ConsoleReporter::~ConsoleReporter() {}
------------------
_ZN5Catch15ConsoleReporterD0Ev:
        1:11421:    ConsoleReporter::~ConsoleReporter() {}
------------------
_ZN5Catch15ConsoleReporterD2Ev:
        1:11421:    ConsoleReporter::~ConsoleReporter() {}
------------------
    #####:11422:    CompactReporter::~CompactReporter() {}
------------------
_ZN5Catch15CompactReporterD0Ev:
    #####:11422:    CompactReporter::~CompactReporter() {}
------------------
_ZN5Catch15CompactReporterD2Ev:
    #####:11422:    CompactReporter::~CompactReporter() {}
------------------
       1*:11423:    IRunner::~IRunner() {}
------------------
_ZN5Catch7IRunnerD0Ev:
    #####:11423:    IRunner::~IRunner() {}
------------------
_ZN5Catch7IRunnerD2Ev:
        1:11423:    IRunner::~IRunner() {}
------------------
       1*:11424:    IMutableContext::~IMutableContext() {}
------------------
_ZN5Catch15IMutableContextD0Ev:
    #####:11424:    IMutableContext::~IMutableContext() {}
------------------
_ZN5Catch15IMutableContextD2Ev:
        1:11424:    IMutableContext::~IMutableContext() {}
------------------
       1*:11425:    IConfig::~IConfig() {}
------------------
_ZN5Catch7IConfigD0Ev:
    #####:11425:    IConfig::~IConfig() {}
------------------
_ZN5Catch7IConfigD2Ev:
        1:11425:    IConfig::~IConfig() {}
------------------
    #####:11426:    XmlReporter::~XmlReporter() {}
------------------
_ZN5Catch11XmlReporterD0Ev:
    #####:11426:    XmlReporter::~XmlReporter() {}
------------------
_ZN5Catch11XmlReporterD2Ev:
    #####:11426:    XmlReporter::~XmlReporter() {}
------------------
    #####:11427:    JunitReporter::~JunitReporter() {}
------------------
_ZN5Catch13JunitReporterD0Ev:
    #####:11427:    JunitReporter::~JunitReporter() {}
------------------
_ZN5Catch13JunitReporterD2Ev:
    #####:11427:    JunitReporter::~JunitReporter() {}
------------------
       1*:11428:    TestRegistry::~TestRegistry() {}
------------------
_ZN5Catch12TestRegistryD0Ev:
    #####:11428:    TestRegistry::~TestRegistry() {}
------------------
_ZN5Catch12TestRegistryD2Ev:
        1:11428:    TestRegistry::~TestRegistry() {}
------------------
        2:11429:    FreeFunctionTestCase::~FreeFunctionTestCase() {}
------------------
_ZN5Catch20FreeFunctionTestCaseD0Ev:
        1:11429:    FreeFunctionTestCase::~FreeFunctionTestCase() {}
------------------
_ZN5Catch20FreeFunctionTestCaseD2Ev:
        1:11429:    FreeFunctionTestCase::~FreeFunctionTestCase() {}
------------------
    #####:11430:    IGeneratorInfo::~IGeneratorInfo() {}
------------------
_ZN5Catch14IGeneratorInfoD0Ev:
    #####:11430:    IGeneratorInfo::~IGeneratorInfo() {}
------------------
_ZN5Catch14IGeneratorInfoD2Ev:
    #####:11430:    IGeneratorInfo::~IGeneratorInfo() {}
------------------
    #####:11431:    IGeneratorsForTest::~IGeneratorsForTest() {}
------------------
_ZN5Catch18IGeneratorsForTestD0Ev:
    #####:11431:    IGeneratorsForTest::~IGeneratorsForTest() {}
------------------
_ZN5Catch18IGeneratorsForTestD2Ev:
    #####:11431:    IGeneratorsForTest::~IGeneratorsForTest() {}
------------------
    #####:11432:    WildcardPattern::~WildcardPattern() {}
------------------
_ZN5Catch15WildcardPatternD0Ev:
    #####:11432:    WildcardPattern::~WildcardPattern() {}
------------------
_ZN5Catch15WildcardPatternD2Ev:
    #####:11432:    WildcardPattern::~WildcardPattern() {}
------------------
       2*:11433:    TestSpec::Pattern::~Pattern() {}
------------------
_ZN5Catch8TestSpec7PatternD0Ev:
    #####:11433:    TestSpec::Pattern::~Pattern() {}
------------------
_ZN5Catch8TestSpec7PatternD2Ev:
        2:11433:    TestSpec::Pattern::~Pattern() {}
------------------
    #####:11434:    TestSpec::NamePattern::~NamePattern() {}
------------------
_ZN5Catch8TestSpec11NamePatternD0Ev:
    #####:11434:    TestSpec::NamePattern::~NamePattern() {}
------------------
_ZN5Catch8TestSpec11NamePatternD2Ev:
    #####:11434:    TestSpec::NamePattern::~NamePattern() {}
------------------
        2:11435:    TestSpec::TagPattern::~TagPattern() {}
------------------
_ZN5Catch8TestSpec10TagPatternD0Ev:
        1:11435:    TestSpec::TagPattern::~TagPattern() {}
------------------
_ZN5Catch8TestSpec10TagPatternD2Ev:
        1:11435:    TestSpec::TagPattern::~TagPattern() {}
------------------
        2:11436:    TestSpec::ExcludedPattern::~ExcludedPattern() {}
------------------
_ZN5Catch8TestSpec15ExcludedPatternD0Ev:
        1:11436:    TestSpec::ExcludedPattern::~ExcludedPattern() {}
------------------
_ZN5Catch8TestSpec15ExcludedPatternD2Ev:
        1:11436:    TestSpec::ExcludedPattern::~ExcludedPattern() {}
------------------
    #####:11437:    Matchers::Impl::MatcherUntypedBase::~MatcherUntypedBase() {}
------------------
_ZN5Catch8Matchers4Impl18MatcherUntypedBaseD0Ev:
    #####:11437:    Matchers::Impl::MatcherUntypedBase::~MatcherUntypedBase() {}
------------------
_ZN5Catch8Matchers4Impl18MatcherUntypedBaseD2Ev:
    #####:11437:    Matchers::Impl::MatcherUntypedBase::~MatcherUntypedBase() {}
------------------
        -:11438:
    #####:11439:    void Config::dummy() {}
        -:11440:
        -:11441:    namespace TestCaseTracking {
       8*:11442:        ITracker::~ITracker() {}
------------------
_ZN5Catch16TestCaseTracking8ITrackerD0Ev:
    #####:11442:        ITracker::~ITracker() {}
------------------
_ZN5Catch16TestCaseTracking8ITrackerD2Ev:
        8:11442:        ITracker::~ITracker() {}
------------------
       8*:11443:        TrackerBase::~TrackerBase() {}
------------------
_ZN5Catch16TestCaseTracking11TrackerBaseD0Ev:
    #####:11443:        TrackerBase::~TrackerBase() {}
------------------
_ZN5Catch16TestCaseTracking11TrackerBaseD2Ev:
        8:11443:        TrackerBase::~TrackerBase() {}
------------------
       16:11444:        SectionTracker::~SectionTracker() {}
------------------
_ZN5Catch16TestCaseTracking14SectionTrackerD0Ev:
        8:11444:        SectionTracker::~SectionTracker() {}
------------------
_ZN5Catch16TestCaseTracking14SectionTrackerD2Ev:
        8:11444:        SectionTracker::~SectionTracker() {}
------------------
    #####:11445:        IndexTracker::~IndexTracker() {}
------------------
_ZN5Catch16TestCaseTracking12IndexTrackerD0Ev:
    #####:11445:        IndexTracker::~IndexTracker() {}
------------------
_ZN5Catch16TestCaseTracking12IndexTrackerD2Ev:
    #####:11445:        IndexTracker::~IndexTracker() {}
------------------
        -:11446:    }
        -:11447:}
        -:11448:
        -:11449:#ifdef __clang__
        -:11450:#pragma clang diagnostic pop
        -:11451:#endif
        -:11452:
        -:11453:#endif
        -:11454:
        -:11455:#ifdef CATCH_CONFIG_MAIN
        -:11456:// #included from: internal/catch_default_main.hpp
        -:11457:#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED
        -:11458:
        -:11459:#ifndef __OBJC__
        -:11460:
        -:11461:#if defined(WIN32) && defined(_UNICODE) && !defined(DO_NOT_USE_WMAIN)
        -:11462:// Standard C/C++ Win32 Unicode wmain entry point
        -:11463:extern "C" int wmain (int argc, wchar_t * argv[], wchar_t * []) {
        -:11464:#else
        -:11465:// Standard C/C++ main entry point
        1:11466:int main (int argc, char * argv[]) {
        -:11467:#endif
        -:11468:
        1:11469:    int result = Catch::Session().run( argc, argv );
        1:11470:    return ( result < 0xff ? result : 0xff );
        -:11471:}
        -:11472:
        -:11473:#else // __OBJC__
        -:11474:
        -:11475:// Objective-C entry point
        -:11476:int main (int argc, char * const argv[]) {
        -:11477:#if !CATCH_ARC_ENABLED
        -:11478:    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
        -:11479:#endif
        -:11480:
        -:11481:    Catch::registerTestMethods();
        -:11482:    int result = Catch::Session().run( argc, (char* const*)argv );
        -:11483:
        -:11484:#if !CATCH_ARC_ENABLED
        -:11485:    [pool drain];
        -:11486:#endif
        -:11487:
        -:11488:    return ( result < 0xff ? result : 0xff );
        -:11489:}
        -:11490:
        -:11491:#endif // __OBJC__
        -:11492:
        -:11493:#endif
        -:11494:
        -:11495:#ifdef CLARA_CONFIG_MAIN_NOT_DEFINED
        -:11496:#  undef CLARA_CONFIG_MAIN
        -:11497:#endif
        -:11498:
        -:11499://////
        -:11500:
        -:11501:// If this config identifier is defined then all CATCH macros are prefixed with CATCH_
        -:11502:#ifdef CATCH_CONFIG_PREFIX_ALL
        -:11503:
        -:11504:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -:11505:#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST_NO_TRY( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, expr )
        -:11506:#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST_NO_TRY( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )
        -:11507:#else
        -:11508:#define CATCH_REQUIRE( expr ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE", Catch::ResultDisposition::Normal, expr )
        -:11509:#define CATCH_REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( "CATCH_REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr  )
        -:11510:#endif
        -:11511:
        -:11512:#define CATCH_REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS", Catch::ResultDisposition::Normal, "", expr )
        -:11513:#define CATCH_REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -:11514:#define CATCH_REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( "CATCH_REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -:11515:#define CATCH_REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( "CATCH_REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, expr )
        -:11516:
        -:11517:#define CATCH_CHECK( expr ) INTERNAL_CATCH_TEST( "CATCH_CHECK", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11518:#define CATCH_CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( "CATCH_CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, expr )
        -:11519:#define CATCH_CHECKED_IF( expr ) INTERNAL_CATCH_IF( "CATCH_CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11520:#define CATCH_CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( "CATCH_CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11521:#define CATCH_CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( "CATCH_CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, expr )
        -:11522:
        -:11523:#define CATCH_CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, "", expr )
        -:11524:#define CATCH_CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CATCH_CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11525:#define CATCH_CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( "CATCH_CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:11526:#define CATCH_CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( "CATCH_CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11527:
        -:11528:#define CATCH_CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -:11529:
        -:11530:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -:11531:#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT_NO_TRY( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:11532:#else
        -:11533:#define CATCH_REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CATCH_REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:11534:#endif
        -:11535:
        -:11536:#define CATCH_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
        -:11537:#define CATCH_WARN( msg ) INTERNAL_CATCH_MSG( "CATCH_WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:11538:#define CATCH_SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( "CATCH_INFO", msg )
        -:11539:#define CATCH_CAPTURE( msg ) INTERNAL_CATCH_INFO( "CATCH_CAPTURE", #msg " := " << Catch::toString(msg) )
        -:11540:#define CATCH_SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( "CATCH_CAPTURE", #msg " := " << Catch::toString(msg) )
        -:11541:
        -:11542:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:11543:    #define CATCH_TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -:11544:    #define CATCH_TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -:11545:    #define CATCH_METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -:11546:    #define CATCH_REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -:11547:    #define CATCH_SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -:11548:    #define CATCH_FAIL( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:11549:    #define CATCH_FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:11550:    #define CATCH_SUCCEED( ... ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:11551:#else
        -:11552:    #define CATCH_TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
        -:11553:    #define CATCH_TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
        -:11554:    #define CATCH_METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
        -:11555:    #define CATCH_REGISTER_TEST_CASE( function, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( function, name, description )
        -:11556:    #define CATCH_SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
        -:11557:    #define CATCH_FAIL( msg ) INTERNAL_CATCH_MSG( "CATCH_FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, msg )
        -:11558:    #define CATCH_FAIL_CHECK( msg ) INTERNAL_CATCH_MSG( "CATCH_FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:11559:    #define CATCH_SUCCEED( msg ) INTERNAL_CATCH_MSG( "CATCH_SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:11560:#endif
        -:11561:#define CATCH_ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )
        -:11562:
        -:11563:#define CATCH_REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
        -:11564:#define CATCH_REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )
        -:11565:
        -:11566:#define CATCH_GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )
        -:11567:
        -:11568:// "BDD-style" convenience wrappers
        -:11569:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:11570:#define CATCH_SCENARIO( ... ) CATCH_TEST_CASE( "Scenario: " __VA_ARGS__ )
        -:11571:#define CATCH_SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -:11572:#else
        -:11573:#define CATCH_SCENARIO( name, tags ) CATCH_TEST_CASE( "Scenario: " name, tags )
        -:11574:#define CATCH_SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
        -:11575:#endif
        -:11576:#define CATCH_GIVEN( desc )    CATCH_SECTION( std::string( "Given: ") + desc, "" )
        -:11577:#define CATCH_WHEN( desc )     CATCH_SECTION( std::string( " When: ") + desc, "" )
        -:11578:#define CATCH_AND_WHEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )
        -:11579:#define CATCH_THEN( desc )     CATCH_SECTION( std::string( " Then: ") + desc, "" )
        -:11580:#define CATCH_AND_THEN( desc ) CATCH_SECTION( std::string( "  And: ") + desc, "" )
        -:11581:
        -:11582:// If CATCH_CONFIG_PREFIX_ALL is not defined then the CATCH_ prefix is not required
        -:11583:#else
        -:11584:
        -:11585:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -:11586:#define REQUIRE( expr ) INTERNAL_CATCH_TEST_NO_TRY( "REQUIRE", Catch::ResultDisposition::Normal, expr )
        -:11587:#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST_NO_TRY( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )
        -:11588:
        -:11589:#else
        -:11590:#define REQUIRE( expr ) INTERNAL_CATCH_TEST( "REQUIRE", Catch::ResultDisposition::Normal, expr  )
        -:11591:#define REQUIRE_FALSE( expr ) INTERNAL_CATCH_TEST( "REQUIRE_FALSE", Catch::ResultDisposition::Normal | Catch::ResultDisposition::FalseTest, expr )
        -:11592:#endif
        -:11593:
        -:11594:#define REQUIRE_THROWS( expr ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS", Catch::ResultDisposition::Normal, "", expr )
        -:11595:#define REQUIRE_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "REQUIRE_THROWS_AS", exceptionType, Catch::ResultDisposition::Normal, expr )
        -:11596:#define REQUIRE_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( "REQUIRE_THROWS_WITH", Catch::ResultDisposition::Normal, matcher, expr )
        -:11597:#define REQUIRE_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( "REQUIRE_NOTHROW", Catch::ResultDisposition::Normal, expr )
        -:11598:
        -:11599:#define CHECK( expr ) INTERNAL_CATCH_TEST( "CHECK", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11600:#define CHECK_FALSE( expr ) INTERNAL_CATCH_TEST( "CHECK_FALSE", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::FalseTest, expr )
        -:11601:#define CHECKED_IF( expr ) INTERNAL_CATCH_IF( "CHECKED_IF", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11602:#define CHECKED_ELSE( expr ) INTERNAL_CATCH_ELSE( "CHECKED_ELSE", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11603:#define CHECK_NOFAIL( expr ) INTERNAL_CATCH_TEST( "CHECK_NOFAIL", Catch::ResultDisposition::ContinueOnFailure | Catch::ResultDisposition::SuppressFail, expr )
        -:11604:
        -:11605:#define CHECK_THROWS( expr )  INTERNAL_CATCH_THROWS( "CHECK_THROWS", Catch::ResultDisposition::ContinueOnFailure, "", expr )
        -:11606:#define CHECK_THROWS_AS( expr, exceptionType ) INTERNAL_CATCH_THROWS_AS( "CHECK_THROWS_AS", exceptionType, Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11607:#define CHECK_THROWS_WITH( expr, matcher ) INTERNAL_CATCH_THROWS( "CHECK_THROWS_WITH", Catch::ResultDisposition::ContinueOnFailure, matcher, expr )
        -:11608:#define CHECK_NOTHROW( expr ) INTERNAL_CATCH_NO_THROW( "CHECK_NOTHROW", Catch::ResultDisposition::ContinueOnFailure, expr )
        -:11609:
        -:11610:#define CHECK_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "CHECK_THAT", matcher, Catch::ResultDisposition::ContinueOnFailure, arg )
        -:11611:
        -:11612:#if defined(CATCH_CONFIG_FAST_COMPILE)
        -:11613:#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT_NO_TRY( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:11614:#else
        -:11615:#define REQUIRE_THAT( arg, matcher ) INTERNAL_CHECK_THAT( "REQUIRE_THAT", matcher, Catch::ResultDisposition::Normal, arg )
        -:11616:#endif
        -:11617:
        -:11618:#define INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
        -:11619:#define WARN( msg ) INTERNAL_CATCH_MSG( "WARN", Catch::ResultWas::Warning, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:11620:#define SCOPED_INFO( msg ) INTERNAL_CATCH_INFO( "INFO", msg )
        -:11621:#define CAPTURE( msg ) INTERNAL_CATCH_INFO( "CAPTURE", #msg " := " << Catch::toString(msg) )
        -:11622:#define SCOPED_CAPTURE( msg ) INTERNAL_CATCH_INFO( "CAPTURE", #msg " := " << Catch::toString(msg) )
        -:11623:
        -:11624:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:11625:#define TEST_CASE( ... ) INTERNAL_CATCH_TESTCASE( __VA_ARGS__ )
        -:11626:#define TEST_CASE_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, __VA_ARGS__ )
        -:11627:#define METHOD_AS_TEST_CASE( method, ... ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, __VA_ARGS__ )
        -:11628:#define REGISTER_TEST_CASE( Function, ... ) INTERNAL_CATCH_REGISTER_TESTCASE( Function, __VA_ARGS__ )
        -:11629:#define SECTION( ... ) INTERNAL_CATCH_SECTION( __VA_ARGS__ )
        -:11630:#define FAIL( ... ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, __VA_ARGS__ )
        -:11631:#define FAIL_CHECK( ... ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:11632:#define SUCCEED( ... ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, __VA_ARGS__ )
        -:11633:#else
        -:11634:#define TEST_CASE( name, description ) INTERNAL_CATCH_TESTCASE( name, description )
        -:11635:    #define TEST_CASE_METHOD( className, name, description ) INTERNAL_CATCH_TEST_CASE_METHOD( className, name, description )
        -:11636:    #define METHOD_AS_TEST_CASE( method, name, description ) INTERNAL_CATCH_METHOD_AS_TEST_CASE( method, name, description )
        -:11637:    #define REGISTER_TEST_CASE( method, name, description ) INTERNAL_CATCH_REGISTER_TESTCASE( method, name, description )
        -:11638:    #define SECTION( name, description ) INTERNAL_CATCH_SECTION( name, description )
        -:11639:    #define FAIL( msg ) INTERNAL_CATCH_MSG( "FAIL", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::Normal, msg )
        -:11640:    #define FAIL_CHECK( msg ) INTERNAL_CATCH_MSG( "FAIL_CHECK", Catch::ResultWas::ExplicitFailure, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:11641:    #define SUCCEED( msg ) INTERNAL_CATCH_MSG( "SUCCEED", Catch::ResultWas::Ok, Catch::ResultDisposition::ContinueOnFailure, msg )
        -:11642:#endif
        -:11643:#define ANON_TEST_CASE() INTERNAL_CATCH_TESTCASE( "", "" )
        -:11644:
        -:11645:#define REGISTER_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_REPORTER( name, reporterType )
        -:11646:#define REGISTER_LEGACY_REPORTER( name, reporterType ) INTERNAL_CATCH_REGISTER_LEGACY_REPORTER( name, reporterType )
        -:11647:
        -:11648:#define GENERATE( expr) INTERNAL_CATCH_GENERATE( expr )
        -:11649:
        -:11650:#endif
        -:11651:
        -:11652:#define CATCH_TRANSLATE_EXCEPTION( signature ) INTERNAL_CATCH_TRANSLATE_EXCEPTION( signature )
        -:11653:
        -:11654:// "BDD-style" convenience wrappers
        -:11655:#ifdef CATCH_CONFIG_VARIADIC_MACROS
        -:11656:#define SCENARIO( ... ) TEST_CASE( "Scenario: " __VA_ARGS__ )
        -:11657:#define SCENARIO_METHOD( className, ... ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " __VA_ARGS__ )
        -:11658:#else
        -:11659:#define SCENARIO( name, tags ) TEST_CASE( "Scenario: " name, tags )
        -:11660:#define SCENARIO_METHOD( className, name, tags ) INTERNAL_CATCH_TEST_CASE_METHOD( className, "Scenario: " name, tags )
        -:11661:#endif
        -:11662:#define GIVEN( desc )    SECTION( std::string("   Given: ") + desc, "" )
        -:11663:#define WHEN( desc )     SECTION( std::string("    When: ") + desc, "" )
        -:11664:#define AND_WHEN( desc ) SECTION( std::string("And when: ") + desc, "" )
        -:11665:#define THEN( desc )     SECTION( std::string("    Then: ") + desc, "" )
        -:11666:#define AND_THEN( desc ) SECTION( std::string("     And: ") + desc, "" )
        -:11667:
        -:11668:using Catch::Detail::Approx;
        -:11669:
        -:11670:// #included from: internal/catch_reenable_warnings.h
        -:11671:
        -:11672:#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED
        -:11673:
        -:11674:#ifdef __clang__
        -:11675:#    ifdef __ICC // icpc defines the __clang__ macro
        -:11676:#        pragma warning(pop)
        -:11677:#    else
        -:11678:#        pragma clang diagnostic pop
        -:11679:#    endif
        -:11680:#elif defined __GNUC__
        -:11681:#    pragma GCC diagnostic pop
        -:11682:#endif
        -:11683:
        -:11684:#endif // TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED
        -:11685:
